/*
 *
 * Copyright (c) 2011-2014- Justin Dearing (zippy1981@gmail.com)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) version 2 licenses.
 * This software is not distributed under version 3 or later of the GPL.
 *
 * Version 1.0.2
 *
 */

if (!document) var document = { cookie: '' }; // fix crashes on node

/**
 * Javascript class that mimics how WCF serializes a object of type MongoDB.Bson.ObjectId
 * and converts between that format and the standard 24 character representation.
 */
var ObjectId = (function () {
    var increment = Math.floor(Math.random() * (16777216));
    var pid = Math.floor(Math.random() * (65536));
    var machine = Math.floor(Math.random() * (16777216));

    var setMachineCookie = function() {
        var cookieList = document.cookie.split('; ');
        for (var i in cookieList) {
            var cookie = cookieList[i].split('=');
            var cookieMachineId = parseInt(cookie[1], 10);
            if (cookie[0] == 'mongoMachineId' && cookieMachineId && cookieMachineId >= 0 && cookieMachineId <= 16777215) {
                machine = cookieMachineId;
                break;
            }
        }
        document.cookie = 'mongoMachineId=' + machine + ';expires=Tue, 19 Jan 2038 05:00:00 GMT;path=/';
    };
    if (typeof (localStorage) != 'undefined') {
        try {
            var mongoMachineId = parseInt(localStorage['mongoMachineId']);
            if (mongoMachineId >= 0 && mongoMachineId <= 16777215) {
                machine = Math.floor(localStorage['mongoMachineId']);
            }
            // Just always stick the value in.
            localStorage['mongoMachineId'] = machine;
        } catch (e) {
            setMachineCookie();
        }
    }
    else {
        setMachineCookie();
    }

    function ObjId() {
        if (!(this instanceof ObjectId)) {
            return new ObjectId(arguments[0], arguments[1], arguments[2], arguments[3]).toString();
        }

        if (typeof (arguments[0]) == 'object') {
            this.timestamp = arguments[0].timestamp;
            this.machine = arguments[0].machine;
            this.pid = arguments[0].pid;
            this.increment = arguments[0].increment;
        }
        else if (typeof (arguments[0]) == 'string' && arguments[0].length == 24) {
            this.timestamp = Number('0x' + arguments[0].substr(0, 8)),
                this.machine = Number('0x' + arguments[0].substr(8, 6)),
                this.pid = Number('0x' + arguments[0].substr(14, 4)),
                this.increment = Number('0x' + arguments[0].substr(18, 6))
        }
        else if (arguments.length == 4 && arguments[0] != null) {
            this.timestamp = arguments[0];
            this.machine = arguments[1];
            this.pid = arguments[2];
            this.increment = arguments[3];
        }
        else {
            this.timestamp = Math.floor(new Date().valueOf() / 1000);
            this.machine = machine;
            this.pid = pid;
            this.increment = increment++;
            if (increment > 0xffffff) {
                increment = 0;
            }
        }
    };
    return ObjId;
})();

ObjectId.prototype.getDate = function () {
    return new Date(this.timestamp * 1000);
};

ObjectId.prototype.toArray = function () {
    var strOid = this.toString();
    var array = [];
    var i;
    for(i = 0; i < 12; i++) {
        array[i] = parseInt(strOid.slice(i*2, i*2+2), 16);
    }
    return array;
};

/**
 * Turns a WCF representation of a BSON ObjectId into a 24 character string representation.
 */
ObjectId.prototype.toString = function () {
    if (this.timestamp === undefined
        || this.machine === undefined
        || this.pid === undefined
        || this.increment === undefined) {
        return 'Invalid ObjectId';
    }

    var timestamp = this.timestamp.toString(16);
    var machine = this.machine.toString(16);
    var pid = this.pid.toString(16);
    var increment = this.increment.toString(16);
    return '00000000'.substr(0, 8 - timestamp.length) + timestamp +
        '000000'.substr(0, 6 - machine.length) + machine +
        '0000'.substr(0, 4 - pid.length) + pid +
        '000000'.substr(0, 6 - increment.length) + increment;
};

/*!
	Papa Parse
	v4.1.2
	https://github.com/mholt/PapaParse
*/
!function(e){"use strict";function t(t,r){if(r=r||{},r.worker&&S.WORKERS_SUPPORTED){var n=f();return n.userStep=r.step,n.userChunk=r.chunk,n.userComplete=r.complete,n.userError=r.error,r.step=m(r.step),r.chunk=m(r.chunk),r.complete=m(r.complete),r.error=m(r.error),delete r.worker,void n.postMessage({input:t,config:r,workerId:n.id})}var o=null;return"string"==typeof t?o=r.download?new i(r):new a(r):(e.File&&t instanceof File||t instanceof Object)&&(o=new s(r)),o.stream(t)}function r(e,t){function r(){"object"==typeof t&&("string"==typeof t.delimiter&&1==t.delimiter.length&&-1==S.BAD_DELIMITERS.indexOf(t.delimiter)&&(u=t.delimiter),("boolean"==typeof t.quotes||t.quotes instanceof Array)&&(o=t.quotes),"string"==typeof t.newline&&(h=t.newline))}function n(e){if("object"!=typeof e)return[];var t=[];for(var r in e)t.push(r);return t}function i(e,t){var r="";"string"==typeof e&&(e=JSON.parse(e)),"string"==typeof t&&(t=JSON.parse(t));var n=e instanceof Array&&e.length>0,i=!(t[0]instanceof Array);if(n){for(var a=0;a<e.length;a++)a>0&&(r+=u),r+=s(e[a],a);t.length>0&&(r+=h)}for(var o=0;o<t.length;o++){for(var f=n?e.length:t[o].length,c=0;f>c;c++){c>0&&(r+=u);var d=n&&i?e[c]:c;r+=s(t[o][d],c)}o<t.length-1&&(r+=h)}return r}function s(e,t){if("undefined"==typeof e||null===e)return"";e=e.toString().replace(/"/g,'""');var r="boolean"==typeof o&&o||o instanceof Array&&o[t]||a(e,S.BAD_DELIMITERS)||e.indexOf(u)>-1||" "==e.charAt(0)||" "==e.charAt(e.length-1);return r?'"'+e+'"':e}function a(e,t){for(var r=0;r<t.length;r++)if(e.indexOf(t[r])>-1)return!0;return!1}var o=!1,u=",",h="\r\n";if(r(),"string"==typeof e&&(e=JSON.parse(e)),e instanceof Array){if(!e.length||e[0]instanceof Array)return i(null,e);if("object"==typeof e[0])return i(n(e[0]),e)}else if("object"==typeof e)return"string"==typeof e.data&&(e.data=JSON.parse(e.data)),e.data instanceof Array&&(e.fields||(e.fields=e.data[0]instanceof Array?e.fields:n(e.data[0])),e.data[0]instanceof Array||"object"==typeof e.data[0]||(e.data=[e.data])),i(e.fields||[],e.data||[]);throw"exception: Unable to serialize unrecognized input"}function n(t){function r(e){var t=_(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null),this._handle=new o(t),this._handle.streamer=this,this._config=t}this._handle=null,this._paused=!1,this._finished=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},r.call(this,t),this.parseChunk=function(t){if(this.isFirstChunk&&m(this._config.beforeFirstChunk)){var r=this._config.beforeFirstChunk(t);void 0!==r&&(t=r)}this.isFirstChunk=!1;var n=this._partialLine+t;this._partialLine="";var i=this._handle.parse(n,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var s=i.meta.cursor;this._finished||(this._partialLine=n.substring(s-this._baseIndex),this._baseIndex=s),i&&i.data&&(this._rowCount+=i.data.length);var a=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(y)e.postMessage({results:i,workerId:S.WORKER_ID,finished:a});else if(m(this._config.chunk)){if(this._config.chunk(i,this._handle),this._paused)return;i=void 0,this._completeResults=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(i.data),this._completeResults.errors=this._completeResults.errors.concat(i.errors),this._completeResults.meta=i.meta),!a||!m(this._config.complete)||i&&i.meta.aborted||this._config.complete(this._completeResults),a||i&&i.meta.paused||this._nextChunk(),i}},this._sendError=function(t){m(this._config.error)?this._config.error(t):y&&this._config.error&&e.postMessage({workerId:S.WORKER_ID,error:t,finished:!1})}}function i(e){function t(e){var t=e.getResponseHeader("Content-Range");return parseInt(t.substr(t.lastIndexOf("/")+1))}e=e||{},e.chunkSize||(e.chunkSize=S.RemoteChunkSize),n.call(this,e);var r;this._nextChunk=k?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(e){this._input=e,this._nextChunk()},this._readChunk=function(){if(this._finished)return void this._chunkLoaded();if(r=new XMLHttpRequest,k||(r.onload=g(this._chunkLoaded,this),r.onerror=g(this._chunkError,this)),r.open("GET",this._input,!k),this._config.chunkSize){var e=this._start+this._config.chunkSize-1;r.setRequestHeader("Range","bytes="+this._start+"-"+e),r.setRequestHeader("If-None-Match","webkit-no-cache")}try{r.send()}catch(t){this._chunkError(t.message)}k&&0==r.status?this._chunkError():this._start+=this._config.chunkSize},this._chunkLoaded=function(){if(4==r.readyState){if(r.status<200||r.status>=400)return void this._chunkError();this._finished=!this._config.chunkSize||this._start>t(r),this.parseChunk(r.responseText)}},this._chunkError=function(e){var t=r.statusText||e;this._sendError(t)}}function s(e){e=e||{},e.chunkSize||(e.chunkSize=S.LocalChunkSize),n.call(this,e);var t,r,i="undefined"!=typeof FileReader;this.stream=function(e){this._input=e,r=e.slice||e.webkitSlice||e.mozSlice,i?(t=new FileReader,t.onload=g(this._chunkLoaded,this),t.onerror=g(this._chunkError,this)):t=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var e=this._input;if(this._config.chunkSize){var n=Math.min(this._start+this._config.chunkSize,this._input.size);e=r.call(e,this._start,n)}var s=t.readAsText(e,this._config.encoding);i||this._chunkLoaded({target:{result:s}})},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result)},this._chunkError=function(){this._sendError(t.error)}}function a(e){e=e||{},n.call(this,e);var t,r;this.stream=function(e){return t=e,r=e,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var e=this._config.chunkSize,t=e?r.substr(0,e):r;return r=e?r.substr(e):"",this._finished=!r,this.parseChunk(t)}}}function o(e){function t(){if(b&&d&&(h("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+S.DefaultDelimiter+"'"),d=!1),e.skipEmptyLines)for(var t=0;t<b.data.length;t++)1==b.data[t].length&&""==b.data[t][0]&&b.data.splice(t--,1);return r()&&n(),i()}function r(){return e.header&&0==y.length}function n(){if(b){for(var e=0;r()&&e<b.data.length;e++)for(var t=0;t<b.data[e].length;t++)y.push(b.data[e][t]);b.data.splice(0,1)}}function i(){if(!b||!e.header&&!e.dynamicTyping)return b;for(var t=0;t<b.data.length;t++){for(var r={},n=0;n<b.data[t].length;n++){if(e.dynamicTyping){var i=b.data[t][n];b.data[t][n]="true"==i||"TRUE"==i?!0:"false"==i||"FALSE"==i?!1:o(i)}e.header&&(n>=y.length?(r.__parsed_extra||(r.__parsed_extra=[]),r.__parsed_extra.push(b.data[t][n])):r[y[n]]=b.data[t][n])}e.header&&(b.data[t]=r,n>y.length?h("FieldMismatch","TooManyFields","Too many fields: expected "+y.length+" fields but parsed "+n,t):n<y.length&&h("FieldMismatch","TooFewFields","Too few fields: expected "+y.length+" fields but parsed "+n,t))}return e.header&&b.meta&&(b.meta.fields=y),b}function s(t){for(var r,n,i,s=[",","	","|",";",S.RECORD_SEP,S.UNIT_SEP],a=0;a<s.length;a++){var o=s[a],h=0,f=0;i=void 0;for(var c=new u({delimiter:o,preview:10}).parse(t),d=0;d<c.data.length;d++){var l=c.data[d].length;f+=l,"undefined"!=typeof i?l>1&&(h+=Math.abs(l-i),i=l):i=l}c.data.length>0&&(f/=c.data.length),("undefined"==typeof n||n>h)&&f>1.99&&(n=h,r=o)}return e.delimiter=r,{successful:!!r,bestDelimiter:r}}function a(e){e=e.substr(0,1048576);var t=e.split("\r");if(1==t.length)return"\n";for(var r=0,n=0;n<t.length;n++)"\n"==t[n][0]&&r++;return r>=t.length/2?"\r\n":"\r"}function o(e){var t=l.test(e);return t?parseFloat(e):e}function h(e,t,r,n){b.errors.push({type:e,code:t,message:r,row:n})}var f,c,d,l=/^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i,p=this,g=0,v=!1,k=!1,y=[],b={data:[],errors:[],meta:{}};if(m(e.step)){var R=e.step;e.step=function(n){if(b=n,r())t();else{if(t(),0==b.data.length)return;g+=n.data.length,e.preview&&g>e.preview?c.abort():R(b,p)}}}this.parse=function(r,n,i){if(e.newline||(e.newline=a(r)),d=!1,!e.delimiter){var o=s(r);o.successful?e.delimiter=o.bestDelimiter:(d=!0,e.delimiter=S.DefaultDelimiter),b.meta.delimiter=e.delimiter}var h=_(e);return e.preview&&e.header&&h.preview++,f=r,c=new u(h),b=c.parse(f,n,i),t(),v?{meta:{paused:!0}}:b||{meta:{paused:!1}}},this.paused=function(){return v},this.pause=function(){v=!0,c.abort(),f=f.substr(c.getCharIndex())},this.resume=function(){v=!1,p.streamer.parseChunk(f)},this.aborted=function(){return k},this.abort=function(){k=!0,c.abort(),b.meta.aborted=!0,m(e.complete)&&e.complete(b),f=""}}function u(e){e=e||{};var t=e.delimiter,r=e.newline,n=e.comments,i=e.step,s=e.preview,a=e.fastMode;if(("string"!=typeof t||S.BAD_DELIMITERS.indexOf(t)>-1)&&(t=","),n===t)throw"Comment character same as delimiter";n===!0?n="#":("string"!=typeof n||S.BAD_DELIMITERS.indexOf(n)>-1)&&(n=!1),"\n"!=r&&"\r"!=r&&"\r\n"!=r&&(r="\n");var o=0,u=!1;this.parse=function(e,h,f){function c(e){b.push(e),S=o}function d(t){return f?p():("undefined"==typeof t&&(t=e.substr(o)),w.push(t),o=g,c(w),y&&_(),p())}function l(t){o=t,c(w),w=[],O=e.indexOf(r,o)}function p(e){return{data:b,errors:R,meta:{delimiter:t,linebreak:r,aborted:u,truncated:!!e,cursor:S+(h||0)}}}function _(){i(p()),b=[],R=[]}if("string"!=typeof e)throw"Input must be a string";var g=e.length,m=t.length,v=r.length,k=n.length,y="function"==typeof i;o=0;var b=[],R=[],w=[],S=0;if(!e)return p();if(a||a!==!1&&-1===e.indexOf('"')){for(var C=e.split(r),E=0;E<C.length;E++){var w=C[E];if(o+=w.length,E!==C.length-1)o+=r.length;else if(f)return p();if(!n||w.substr(0,k)!=n){if(y){if(b=[],c(w.split(t)),_(),u)return p()}else c(w.split(t));if(s&&E>=s)return b=b.slice(0,s),p(!0)}}return p()}for(var x=e.indexOf(t,o),O=e.indexOf(r,o);;)if('"'!=e[o])if(n&&0===w.length&&e.substr(o,k)===n){if(-1==O)return p();o=O+v,O=e.indexOf(r,o),x=e.indexOf(t,o)}else if(-1!==x&&(O>x||-1===O))w.push(e.substring(o,x)),o=x+m,x=e.indexOf(t,o);else{if(-1===O)break;if(w.push(e.substring(o,O)),l(O+v),y&&(_(),u))return p();if(s&&b.length>=s)return p(!0)}else{var I=o;for(o++;;){var I=e.indexOf('"',I+1);if(-1===I)return f||R.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:b.length,index:o}),d();if(I===g-1){var D=e.substring(o,I).replace(/""/g,'"');return d(D)}if('"'!=e[I+1]){if(e[I+1]==t){w.push(e.substring(o,I).replace(/""/g,'"')),o=I+1+m,x=e.indexOf(t,o),O=e.indexOf(r,o);break}if(e.substr(I+1,v)===r){if(w.push(e.substring(o,I).replace(/""/g,'"')),l(I+1+v),x=e.indexOf(t,o),y&&(_(),u))return p();if(s&&b.length>=s)return p(!0);break}}else I++}}return d()},this.abort=function(){u=!0},this.getCharIndex=function(){return o}}function h(){var e=document.getElementsByTagName("script");return e.length?e[e.length-1].src:""}function f(){if(!S.WORKERS_SUPPORTED)return!1;if(!b&&null===S.SCRIPT_PATH)throw new Error("Script path cannot be determined automatically when Papa Parse is loaded asynchronously. You need to set Papa.SCRIPT_PATH manually.");var t=S.SCRIPT_PATH||v;t+=(-1!==t.indexOf("?")?"&":"?")+"papaworker";var r=new e.Worker(t);return r.onmessage=c,r.id=w++,R[r.id]=r,r}function c(e){var t=e.data,r=R[t.workerId],n=!1;if(t.error)r.userError(t.error,t.file);else if(t.results&&t.results.data){var i=function(){n=!0,d(t.workerId,{data:[],errors:[],meta:{aborted:!0}})},s={abort:i,pause:l,resume:l};if(m(r.userStep)){for(var a=0;a<t.results.data.length&&(r.userStep({data:[t.results.data[a]],errors:t.results.errors,meta:t.results.meta},s),!n);a++);delete t.results}else m(r.userChunk)&&(r.userChunk(t.results,s,t.file),delete t.results)}t.finished&&!n&&d(t.workerId,t.results)}function d(e,t){var r=R[e];m(r.userComplete)&&r.userComplete(t),r.terminate(),delete R[e]}function l(){throw"Not implemented."}function p(t){var r=t.data;if("undefined"==typeof S.WORKER_ID&&r&&(S.WORKER_ID=r.workerId),"string"==typeof r.input)e.postMessage({workerId:S.WORKER_ID,results:S.parse(r.input,r.config),finished:!0});else if(e.File&&r.input instanceof File||r.input instanceof Object){var n=S.parse(r.input,r.config);n&&e.postMessage({workerId:S.WORKER_ID,results:n,finished:!0})}}function _(e){if("object"!=typeof e)return e;var t=e instanceof Array?[]:{};for(var r in e)t[r]=_(e[r]);return t}function g(e,t){return function(){e.apply(t,arguments)}}function m(e){return"function"==typeof e}var v,k=!e.document&&!!e.postMessage,y=k&&/(\?|&)papaworker(=|&|$)/.test(e.location.search),b=!1,R={},w=0,S={};if(S.parse=t,S.unparse=r,S.RECORD_SEP=String.fromCharCode(30),S.UNIT_SEP=String.fromCharCode(31),S.BYTE_ORDER_MARK="ï»¿",S.BAD_DELIMITERS=["\r","\n",'"',S.BYTE_ORDER_MARK],S.WORKERS_SUPPORTED=!k&&!!e.Worker,S.SCRIPT_PATH=null,S.LocalChunkSize=10485760,S.RemoteChunkSize=5242880,S.DefaultDelimiter=",",S.Parser=u,S.ParserHandle=o,S.NetworkStreamer=i,S.FileStreamer=s,S.StringStreamer=a,"undefined"!=typeof module&&module.exports?module.exports=S:m(e.define)&&e.define.amd?define(function(){return S}):e.Papa=S,e.jQuery){var C=e.jQuery;C.fn.parse=function(t){function r(){if(0==a.length)return void(m(t.complete)&&t.complete());var e=a[0];if(m(t.before)){var r=t.before(e.file,e.inputElem);if("object"==typeof r){if("abort"==r.action)return void n("AbortError",e.file,e.inputElem,r.reason);if("skip"==r.action)return void i();"object"==typeof r.config&&(e.instanceConfig=C.extend(e.instanceConfig,r.config))}else if("skip"==r)return void i()}var s=e.instanceConfig.complete;e.instanceConfig.complete=function(t){m(s)&&s(t,e.file,e.inputElem),i()},S.parse(e.file,e.instanceConfig)}function n(e,r,n,i){m(t.error)&&t.error({name:e},r,n,i)}function i(){a.splice(0,1),r()}var s=t.config||{},a=[];return this.each(function(){var t="INPUT"==C(this).prop("tagName").toUpperCase()&&"file"==C(this).attr("type").toLowerCase()&&e.FileReader;if(!t||!this.files||0==this.files.length)return!0;for(var r=0;r<this.files.length;r++)a.push({file:this.files[r],inputElem:this,instanceConfig:C.extend({},s)})}),r(),this}}y?e.onmessage=p:S.WORKERS_SUPPORTED&&(v=h(),document.body?document.addEventListener("DOMContentLoaded",function(){b=!0},!0):b=!0),i.prototype=Object.create(n.prototype),i.prototype.constructor=i,s.prototype=Object.create(n.prototype),s.prototype.constructor=s,a.prototype=Object.create(a.prototype),a.prototype.constructor=a}("undefined"!=typeof window?window:this);
/*! angular-pageslide-directive 2016-08-03 */
!function(a,b){"function"==typeof define&&define.amd?define(["angular"],b):"object"==typeof module&&module.exports?module.exports=b(require("angular")):b(a.angular)}(this,function(a){a.module("pageslide-directive",[]).directive("pageslide",["$document","$timeout",function(b,c){return{restrict:"EA",transclude:!1,scope:{psOpen:"=?",psAutoClose:"@",psSide:"@",psSpeed:"@",psClass:"@",psSize:"@",psZindex:"@",psPush:"@",psContainer:"@",psKeyListener:"@",psBodyClass:"@",psClickOutside:"@",onopen:"=?",onclose:"=?"},link:function(d,e,f){function g(a){r&&!p.contains(a.target)&&(r=!1,d.psOpen=!1,d.$apply()),d.psOpen&&(r=!0)}function h(a){if(n.bodyClass){var b=n.className+"-body",c=new RegExp(" "+b+"-closed| "+b+"-open");q.className=q.className.replace(c,""),q.className+=" "+b+"-"+a}}function i(){d.psOpen?"function"==typeof d.onopen&&d.onopen():"function"==typeof d.onclose&&d.onclose()}function j(){switch(n.side){case"right":p.style.width=n.size,p.style.height="100%",p.style.top="0px",p.style.bottom="0px",p.style.right="0px";break;case"left":p.style.width=n.size,p.style.height="100%",p.style.top="0px",p.style.bottom="0px",p.style.left="0px";break;case"top":p.style.height=n.size,p.style.width="100%",p.style.left="0px",p.style.top="0px",p.style.right="0px";break;case"bottom":p.style.height=n.size,p.style.width="100%",p.style.bottom="0px",p.style.left="0px",p.style.right="0px"}}function k(a,c){switch(c.side){case"right":a.style.right="-"+c.size,c.push&&(q.style.right="0px",q.style.left="0px");break;case"left":a.style.left="-"+c.size,c.push&&(q.style.left="0px",q.style.right="0px");break;case"top":a.style.top="-"+c.size,c.push&&(q.style.top="0px",q.style.bottom="0px");break;case"bottom":a.style.bottom="-"+c.size,c.push&&(q.style.bottom="0px",q.style.top="0px")}c.keyListener&&b.off("keydown",m),c.clickOutside&&b.off("click",g),r=!1,h("closed"),d.psOpen=!1}function l(a,c){switch(c.side){case"right":a.style.right="0px",c.push&&(q.style.right=c.size,q.style.left="-"+c.size);break;case"left":a.style.left="0px",c.push&&(q.style.left=c.size,q.style.right="-"+c.size);break;case"top":a.style.top="0px",c.push&&(q.style.top=c.size,q.style.bottom="-"+c.size);break;case"bottom":a.style.bottom="0px",c.push&&(q.style.bottom=c.size,q.style.top="-"+c.size)}d.psOpen=!0,c.keyListener&&b.on("keydown",m),c.clickOutside&&b.on("click",g),h("open")}function m(a){var b=27,e=a.keyCode||a.which;e===b&&(k(p,n),c(function(){d.$apply()}))}var n={};n.side=d.psSide||"right",n.speed=d.psSpeed||"0.5",n.size=d.psSize||"300px",n.zindex=d.psZindex||1e3,n.className=d.psClass||"ng-pageslide",n.push="true"===d.psPush,n.container=d.psContainer||!1,n.keyListener="true"===d.psKeyListener,n.bodyClass=d.psBodyClass||!1,n.clickOutside="false"!==d.psClickOutside,n.push=n.push&&!n.container,e.addClass(n.className);var o,p,q,r=!1;if(q=n.container?document.getElementById(n.container):document.body,h("closed"),p=e[0],"div"!==p.tagName.toLowerCase()&&"pageslide"!==p.tagName.toLowerCase())throw new Error("Pageslide can only be applied to <div> or <pageslide> elements");if(0===p.children.length)throw new Error("You need to have content inside the <pageslide>");o=a.element(p.children),q.appendChild(p),p.style.zIndex=n.zindex,p.style.position="fixed",p.style.transitionDuration=n.speed+"s",p.style.webkitTransitionDuration=n.speed+"s",p.style.height=n.size,p.style.transitionProperty="top, bottom, left, right",n.push&&(q.style.position="absolute",q.style.transitionDuration=n.speed+"s",q.style.webkitTransitionDuration=n.speed+"s",q.style.transitionProperty="top, bottom, left, right"),n.container&&(p.style.position="absolute",q.style.position="relative",q.style.overflow="hidden"),p.addEventListener("transitionend",i),j(),d.$watch("psOpen",function(a){a?l(p,n):k(p,n)}),d.$watch("psSize",function(a,b){b!==a&&(n.size=a,j())}),d.$on("$destroy",function(){p.parentNode===q&&(n.clickOutside&&b.off("click",g),q.removeChild(p)),p.removeEventListener("transitionend",i)}),d.psAutoClose&&(d.$on("$locationChangeStart",function(){k(p,n)}),d.$on("$stateChangeStart",function(){k(p,n)}))}}}])});
(function() {
"use strict";

angular.module('ngTreetable', [])

    /**
     * @ngdoc service
     */
    .factory('ngTreetableParams', ['$log', function($log) {
        var params = function(baseConfiguration) {
            var self = this;

            /**
             * @ngdoc method
             * @param {<any>} parent A parent node to fetch children of, or null if fetching root nodes.
             */
            this.getNodes = function(parent) {}

            /**
             * @ngdoc method
             * @param {<any>} node A node returned from getNodes
             */
            this.getTemplate = function(node) {}

            /**
             * @ngdoc property
             */
            this.options = {};

            /**
             * @ngdoc method
             */
            this.refresh = function() {}


            if (angular.isObject(baseConfiguration)) {
                angular.forEach(baseConfiguration, function(val, key) {
                    if (['getNodes', 'getTemplate', 'options'].indexOf(key) > -1) {
                        self[key] = val;
                    } else {
                        $log.warn('ngTreetableParams - Ignoring unexpected property "' + key + '".');
                    }
                });
            }

        }
        return params;
    }])

    .controller('TreetableController', ['$scope', '$element', '$compile', '$templateCache', '$q', '$http', function($scope, $element, $compile, $templateCache, $q, $http) {

        var params = $scope.ttParams;
        var table = $element;
        console.log("inside tt Table");

        $scope.compileElement = function(node, parentId, parentNode) {
            var tpl = params.getTemplate(node);

            var templatePromise = $http.get(params.getTemplate(node), {cache: $templateCache}).then(function(result) {
                return result.data;
            });

            return templatePromise.then(function(template) {
                var template_scope = $scope.$parent.$new();
                angular.extend(template_scope, {
                    node: node,
                    parentNode: parentNode
                });
                template_scope._ttParentId = parentId;
                return $compile(template)(template_scope).get(0);
            })

        }

        /**
         * Expands the given node.
         * @param parentElement the parent node element, or null for the root
         * @param shouldExpand whether all descendants of `parentElement` should also be expanded
         */
        $scope.addChildren = function(parentElement, shouldExpand) {
            var parentNode = parentElement ? parentElement.scope().node : null;
            var parentId = parentElement ? parentElement.data('ttId') : null;

            if (parentElement) {
                parentElement.scope().loading = true;
            }

            $q.when(params.getNodes(parentNode)).then(function(data) {
                var elementPromises = [];
                angular.forEach(data, function(node) {
                    elementPromises.push($scope.compileElement(node, parentId, parentNode));
                });

                $q.all(elementPromises).then(function(newElements) {
                    var parentTtNode = parentId != null ? table.treetable("node", parentId) : null;

                    $element.treetable('loadBranch', parentTtNode, newElements);

                    if (shouldExpand) {
                        angular.forEach(newElements, function(el) {
                            $scope.addChildren($(el), shouldExpand);
                        });
                    }

                    if (parentElement) {
                        parentElement.scope().loading = false;
                    }
                });

            });
        }

        /**
         * Callback for onNodeExpand to add nodes.
         */
        $scope.onNodeExpand = function() {
            if (this.row.scope().loading) return; // make sure we're not already loading
            table.treetable('unloadBranch', this); // make sure we don't double-load
            $scope.addChildren(this.row, $scope.shouldExpand());
        }

        /**
         * Callback for onNodeCollapse to remove nodes.
         */
        $scope.onNodeCollapse = function() {
            if (this.row.scope().loading) return; // make sure we're not already loading
            table.treetable('unloadBranch', this);
        }

        /**
         * Rebuilds the entire table.
         */
        $scope.refresh = function() {
            var rootNodes = table.data('treetable').nodes;
            while (rootNodes.length > 0) {
                table.treetable('removeNode', rootNodes[0].id);
            }
            $scope.addChildren(null, $scope.shouldExpand());
        }

        // attach to params for convenience
        params.refresh = $scope.refresh;


        /**
         * Build options for the internal treetable library.
         */
        $scope.getOptions = function() {
            var opts = angular.extend({
                expandable: true,
                onNodeExpand: $scope.onNodeExpand,
                onNodeCollapse: $scope.onNodeCollapse
            }, params.options);

            if (params.options) {
                // Inject required event handlers before custom ones
                angular.forEach(['onNodeCollapse', 'onNodeExpand'], function(event) {
                    if (params.options[event]) {
                        opts[event] = function() {
                            $scope[event].apply(this, arguments);
                            params.options[event].apply(this, arguments);
                        }
                    }
                });
            }

            return opts;
        }

        $scope.shouldExpand = function() {
            return $scope.options.initialState === 'expanded';
        }

        $scope.options = $scope.getOptions();
        table.treetable($scope.options);
        $scope.addChildren(null, $scope.shouldExpand());

    }])

    .directive('ttTable', [function() {
        return {
            restrict: 'AC',
            scope: {
                ttParams: '='
            },
            controller: 'TreetableController'
        }
    }])

    .directive('ttNode', [function() {
        var ttNodeCounter = 0;
        return {
            restrict: 'AC',
            scope: {
                isBranch: '=',
                parent: '=',
                id: '='
            },
            link: function(scope, element, attrs) {
                var branch = angular.isDefined(scope.isBranch) ? scope.isBranch : true;

                // Look for a parent set by the tt-tree directive if one isn't explicitly set
                var parent = angular.isDefined(scope.parent) ? scope.parent : scope.$parent._ttParentId;

                element.attr('data-tt-id', ttNodeCounter++);
                element.attr('data-tt-branch', branch);
                element.attr('data-tt-parent-id', parent);
                element.attr('data-node-id',scope.id);
             }
        }

    }]);

})();

/**
 * angular-treetable
 * @version v0.3.1 - 2014-12-07
 * @link http://github.com/garrettheel/angular-treetable
 * @author Garrett Heel (garrettheel@gmail.com)
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
!function(){"use strict";angular.module("ngTreetable",[]).factory("ngTreetableParams",["$log",function(a){var b=function(b){var c=this;this.getNodes=function(){},this.getTemplate=function(){},this.options={},this.refresh=function(){},angular.isObject(b)&&angular.forEach(b,function(b,d){["getNodes","getTemplate","options"].indexOf(d)>-1?c[d]=b:a.warn('ngTreetableParams - Ignoring unexpected property "'+d+'".')})};return b}]).controller("TreetableController",["$scope","$element","$compile","$templateCache","$q","$http",function(a,b,c,d,e,f){var g=a.ttParams,h=b;a.compileElement=function(b,e,h){var i=(g.getTemplate(b),f.get(g.getTemplate(b),{cache:d}).then(function(a){return a.data}));return i.then(function(d){var f=a.$parent.$new();return angular.extend(f,{node:b,parentNode:h}),f._ttParentId=e,c(d)(f).get(0)})},a.addChildren=function(c,d){var f=c?c.scope().node:null,i=c?c.data("ttId"):null;c&&(c.scope().loading=!0),e.when(g.getNodes(f)).then(function(g){var j=[];angular.forEach(g,function(b){j.push(a.compileElement(b,i,f))}),e.all(j).then(function(e){var f=null!=i?h.treetable("node",i):null;b.treetable("loadBranch",f,e),d&&angular.forEach(e,function(b){a.addChildren($(b),d)}),c&&(c.scope().loading=!1)})})},a.onNodeExpand=function(){this.row.scope().loading||(h.treetable("unloadBranch",this),a.addChildren(this.row,a.shouldExpand()))},a.onNodeCollapse=function(){this.row.scope().loading||h.treetable("unloadBranch",this)},a.refresh=function(){for(var b=h.data("treetable").nodes;b.length>0;)h.treetable("removeNode",b[0].id);a.addChildren(null,a.shouldExpand())},g.refresh=a.refresh,a.getOptions=function(){var b=angular.extend({expandable:!0,onNodeExpand:a.onNodeExpand,onNodeCollapse:a.onNodeCollapse},g.options);return g.options&&angular.forEach(["onNodeCollapse","onNodeExpand"],function(c){g.options[c]&&(b[c]=function(){a[c].apply(this,arguments),g.options[c].apply(this,arguments)})}),b},a.shouldExpand=function(){return"expanded"===a.options.initialState},a.options=a.getOptions(),h.treetable(a.options),a.addChildren(null,a.shouldExpand())}]).directive("ttTable",[function(){return{restrict:"AC",scope:{ttParams:"="},controller:"TreetableController"}}]).directive("ttNode",[function(){var a=0;return{restrict:"AC",scope:{isBranch:"=",parent:"="},link:function(b,c){var d=angular.isDefined(b.isBranch)?b.isBranch:!0,e=angular.isDefined(b.parent)?b.parent:b.$parent._ttParentId;c.attr("data-tt-id",a++),c.attr("data-tt-branch",d),c.attr("data-tt-parent-id",e)}}}])}();
/*
 * jQuery treetable Plugin 3.1.0
 * http://ludo.cubicphuse.nl/jquery-treetable
 *
 * Copyright 2013, Ludo van den Boom
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
(function() {
    var $, Node, Tree, methods;

    $ = jQuery;

    Node = (function() {
        function Node(row, tree, settings) {
            var parentId;

            this.row = row;
            this.tree = tree;
            this.settings = settings;

            // TODO Ensure id/parentId is always a string (not int)
            this.id = this.row.data(this.settings.nodeIdAttr);

            // TODO Move this to a setParentId function?
            parentId = this.row.data(this.settings.parentIdAttr);
            if (parentId != null && parentId !== "") {
                this.parentId = parentId;
            }

            this.treeCell = $(this.row.children(this.settings.columnElType)[this.settings.column]);
            this.expander = $(this.settings.expanderTemplate);
            this.indenter = $(this.settings.indenterTemplate);
            this.children = [];
            this.initialized = false;
            this.treeCell.prepend(this.indenter);
        }

        Node.prototype.addChild = function(child) {
            return this.children.push(child);
        };

        Node.prototype.ancestors = function() {
            var ancestors, node;
            node = this;
            ancestors = [];
            while (node = node.parentNode()) {
                ancestors.push(node);
            }
            return ancestors;
        };

        Node.prototype.collapse = function() {
            if (this.collapsed()) {
                return this;
            }

            this.row.removeClass("expanded").addClass("collapsed");

            this._hideChildren();
            this.expander.attr("title", this.settings.stringExpand);

            if (this.initialized && this.settings.onNodeCollapse != null) {
                this.settings.onNodeCollapse.apply(this);
            }

            return this;
        };

        Node.prototype.collapsed = function() {
            return this.row.hasClass("collapsed");
        };

        // TODO destroy: remove event handlers, expander, indenter, etc.

        Node.prototype.expand = function() {
            if (this.expanded()) {
                return this;
            }

            this.row.removeClass("collapsed").addClass("expanded");

            if (this.initialized && this.settings.onNodeExpand != null) {
                this.settings.onNodeExpand.apply(this);
            }

            if ($(this.row).is(":visible")) {
                this._showChildren();
            }

            this.expander.attr("title", this.settings.stringCollapse);

            return this;
        };

        Node.prototype.expanded = function() {
            return this.row.hasClass("expanded");
        };

        Node.prototype.hide = function() {
            this._hideChildren();
            this.row.hide();
            return this;
        };

        Node.prototype.isBranchNode = function() {
            if (this.children.length > 0 || this.row.data(this.settings.branchAttr) === true) {
                return true;
            } else {
                return false;
            }
        };

        Node.prototype.updateBranchLeafClass = function() {
            this.row.removeClass('branch');
            this.row.removeClass('leaf');
            this.row.addClass(this.isBranchNode() ? 'branch' : 'leaf');
        };

        Node.prototype.level = function() {
            return this.ancestors().length;
        };

        Node.prototype.parentNode = function() {
            if (this.parentId != null) {
                return this.tree[this.parentId];
            } else {
                return null;
            }
        };

        Node.prototype.removeChild = function(child) {
            var i = $.inArray(child, this.children);
            return this.children.splice(i, 1)
        };

        Node.prototype.render = function() {
            var handler,
                settings = this.settings,
                target;

            if (settings.expandable === true && this.isBranchNode()) {
                handler = function(e) {
                    $(this).parents("table").treetable("node", $(this).parents("tr").data(settings.nodeIdAttr)).toggle();
                    return e.preventDefault();
                };

                this.indenter.html(this.expander);
                target = settings.clickableNodeNames === true ? this.treeCell : this.expander;

                target.off("click.treetable").on("click.treetable", handler);
                target.off("keydown.treetable").on("keydown.treetable", function(e) {
                    if (e.keyCode == 13) {
                        handler.apply(this, [e]);
                    }
                });
            }

            this.indenter[0].style.paddingLeft = "" + (this.level() * settings.indent) + "px";

            return this;
        };

        Node.prototype.reveal = function() {
            if (this.parentId != null) {
                this.parentNode().reveal();
            }
            return this.expand();
        };

        Node.prototype.setParent = function(node) {
            if (this.parentId != null) {
                this.tree[this.parentId].removeChild(this);
            }
            this.parentId = node.id;
            this.row.data(this.settings.parentIdAttr, node.id);
            return node.addChild(this);
        };

        Node.prototype.show = function() {
            if (!this.initialized) {
                this._initialize();
            }
            this.row.show();
            if (this.expanded()) {
                this._showChildren();
            }
            return this;
        };

        Node.prototype.toggle = function() {
            if (this.expanded()) {
                this.collapse();
            } else {
                this.expand();
            }
            return this;
        };

        Node.prototype._hideChildren = function() {
            var child, _i, _len, _ref, _results;
            _ref = this.children;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                child = _ref[_i];
                _results.push(child.hide());
            }
            return _results;
        };

        Node.prototype._initialize = function() {
            var settings = this.settings;

            this.render();

            if (settings.expandable === true && settings.initialState === "collapsed") {
                this.collapse();
            } else {
                this.expand();
            }

            if (settings.onNodeInitialized != null) {
                settings.onNodeInitialized.apply(this);
            }

            return this.initialized = true;
        };

        Node.prototype._showChildren = function() {
            var child, _i, _len, _ref, _results;
            _ref = this.children;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                child = _ref[_i];
                _results.push(child.show());
            }
            return _results;
        };

        return Node;
    })();

    Tree = (function() {
        function Tree(table, settings) {
            this.table = table;
            this.settings = settings;
            this.tree = {};

            // Cache the nodes and roots in simple arrays for quick access/iteration
            this.nodes = [];
            this.roots = [];
        }

        Tree.prototype.collapseAll = function() {
            var node, _i, _len, _ref, _results;
            _ref = this.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                if(node!==undefined){
                    _results.push(node.collapse());
                }
            }
            return _results;
        };

        Tree.prototype.expandAll = function() {

            var node, _i, _len, _ref, _results;

            _ref = this.nodes;
            console.log(_ref);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                _results.push(node.expand());
            }

            return _results;

        };
        Tree.prototype.draggable = function() {
            console.log("here again");


        };

        Tree.prototype.findLastNode = function(node) {
            if (node.children.length > 0) {
                return this.findLastNode(node.children[node.children.length - 1]);
            } else {
                return node;
            }
        };

        Tree.prototype.loadRows = function(rows) {
            var node, row, i;

            if (rows != null) {
                for (i = 0; i < rows.length; i++) {
                    row = $(rows[i]);

                    if (row.data(this.settings.nodeIdAttr) != null) {
                        node = new Node(row, this.tree, this.settings);
                        this.nodes.push(node);
                        this.tree[node.id] = node;

                        if (node.parentId != null) {
                            this.tree[node.parentId].addChild(node);
                        } else {
                            this.roots.push(node);
                        }
                    }
                }
            }

            for (i = 0; i < this.nodes.length; i++) {
                node = this.nodes[i].updateBranchLeafClass();
            }

            return this;
        };

        Tree.prototype.move = function(node, destination) {
            // Conditions:
            // 1: +node+ should not be inserted as a child of +node+ itself.
            // 2: +destination+ should not be the same as +node+'s current parent (this
            //    prevents +node+ from being moved to the same location where it already
            //    is).
            // 3: +node+ should not be inserted in a location in a branch if this would
            //    result in +node+ being an ancestor of itself.
            var nodeParent = node.parentNode();
            if (node !== destination && destination.id !== node.parentId && $.inArray(node, destination.ancestors()) === -1) {
                node.setParent(destination);
                this._moveRows(node, destination);

                // Re-render parentNode if this is its first child node, and therefore
                // doesn't have the expander yet.
                if (node.parentNode().children.length === 1) {
                    node.parentNode().render();
                }
            }

            if (nodeParent) {
                nodeParent.updateBranchLeafClass();
            }
            if (node.parentNode()) {
                node.parentNode().updateBranchLeafClass();
            }
            node.updateBranchLeafClass();
            return this;
        };

        Tree.prototype.removeNode = function(node) {
            // Recursively remove all descendants of +node+
            this.unloadBranch(node);

            // Remove node from DOM (<tr>)
            node.row.remove();

            // Clean up Tree object (so Node objects are GC-ed)
            delete this.tree[node.id];
            this.nodes.splice($.inArray(node, this.nodes), 1);
        }

        Tree.prototype.render = function() {
            var root, _i, _len, _ref;
            _ref = this.roots;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                root = _ref[_i];

                // Naming is confusing (show/render). I do not call render on node from
                // here.
                root.show();
            }
            return this;
        };

        Tree.prototype.sortBranch = function(node, sortFun) {
            // First sort internal array of children
            node.children.sort(sortFun);

            // Next render rows in correct order on page
            this._sortChildRows(node);

            return this;
        };

        Tree.prototype.unloadBranch = function(node) {
            var children, i;

            for (i = 0; i < node.children.length; i++) {
                this.removeNode(node.children[i]);
            }

            // Reset node's collection of children
            node.children = [];

            node.updateBranchLeafClass();

            return this;
        };

        Tree.prototype._moveRows = function(node, destination) {
            var children = node.children,
                i;

            node.row.insertAfter(destination.row);
            node.render();

            // Loop backwards through children to have them end up on UI in correct
            // order (see #112)
            for (i = children.length - 1; i >= 0; i--) {
                this._moveRows(children[i], node);
            }
        };

        // Special _moveRows case, move children to itself to force sorting
        Tree.prototype._sortChildRows = function(parentNode) {
            return this._moveRows(parentNode, parentNode);
        };

        return Tree;
    })();

    // jQuery Plugin
    methods = {
        init: function(options, force) {
            var settings;

            settings = $.extend({
                branchAttr: "ttBranch",
                clickableNodeNames: false,
                column: 0,
                columnElType: "td", // i.e. 'td', 'th' or 'td,th'
                expandable: false,
                expanderTemplate: "<a href='#'>&nbsp;</a>",
                indent: 19,
                indenterTemplate: "<span class='indenter'></span>",
                initialState: "collapsed",
                nodeIdAttr: "ttId", // maps to data-tt-id
                parentIdAttr: "ttParentId", // maps to data-tt-parent-id
                stringExpand: "Expand",
                stringCollapse: "Collapse",

                // Events
                onInitialized: null,
                onNodeCollapse: null,
                onNodeExpand: null,
                onNodeInitialized: null
            }, options);

            return this.each(function() {
                var el = $(this),
                    tree;

                if (force || el.data("treetable") === undefined) {
                    tree = new Tree(this, settings);
                    tree.loadRows(this.rows).render();

                    el.addClass("treetable").data("treetable", tree);

                    if (settings.onInitialized != null) {
                        settings.onInitialized.apply(tree);
                    }
                }

                return el;
            });
        },

        destroy: function() {
            return this.each(function() {
                return $(this).removeData("treetable").removeClass("treetable");
            });
        },

        collapseAll: function() {
            this.data("treetable").collapseAll();
            return this;
        },

        collapseNode: function(id) {
            var node = this.data("treetable").tree[id];

            if (node) {
                node.collapse();
            } else {
                throw new Error("Unknown node '" + id + "'");
            }

            return this;
        },

        expandAll: function() {
            console.log(this.data("treetable"));
            this.data("treetable").expandAll();
            return this;
        },
        draggable: function() {
            console.log("hereeerre");
            console.log(this.data("treetable"));

            this.data("treetable").draggable();
            return this;
        },

        expandNode: function(id) {
            var node = this.data("treetable").tree[id];

            if (node) {
                if (!node.initialized) {
                    node._initialize();
                }

                node.expand();
            } else {
                throw new Error("Unknown node '" + id + "'");
            }

            return this;
        },

        loadBranch: function(node, rows) {
            var settings = this.data("treetable").settings,
                tree = this.data("treetable").tree;

            // TODO Switch to $.parseHTML
            rows = $(rows);

            if (node == null) { // Inserting new root nodes
                this.append(rows);
            } else {
                var lastNode = this.data("treetable").findLastNode(node);
                rows.insertAfter(lastNode.row);
            }

            this.data("treetable").loadRows(rows);

            // Make sure nodes are properly initialized
            rows.filter("tr").each(function() {
                tree[$(this).data(settings.nodeIdAttr)].show();
            });

            if (node != null) {
                // Re-render parent to ensure expander icon is shown (#79)
                node.render().expand();
            }

            return this;
        },

        move: function(nodeId, destinationId) {
            var destination, node;

            node = this.data("treetable").tree[nodeId];
            destination = this.data("treetable").tree[destinationId];
            this.data("treetable").move(node, destination);

            return this;
        },

        node: function(id) {
            return this.data("treetable").tree[id];
        },

        removeNode: function(id) {
            var node = this.data("treetable").tree[id];

            if (node) {
                this.data("treetable").removeNode(node);
            } else {
                throw new Error("Unknown node '" + id + "'");
            }

            return this;
        },

        reveal: function(id) {
            var node = this.data("treetable").tree[id];

            if (node) {
                node.reveal();
            } else {
                throw new Error("Unknown node '" + id + "'");
            }

            return this;
        },

        sortBranch: function(node, columnOrFunction) {
            var settings = this.data("treetable").settings,
                prepValue,
                sortFun;

            columnOrFunction = columnOrFunction || settings.column;
            sortFun = columnOrFunction;

            if ($.isNumeric(columnOrFunction)) {
                sortFun = function(a, b) {
                    var extractValue, valA, valB;

                    extractValue = function(node) {
                        var val = node.row.find("td:eq(" + columnOrFunction + ")").text();
                        // Ignore trailing/leading whitespace and use uppercase values for
                        // case insensitive ordering
                        return $.trim(val).toUpperCase();
                    }

                    valA = extractValue(a);
                    valB = extractValue(b);

                    if (valA < valB) return -1;
                    if (valA > valB) return 1;
                    return 0;
                };
            }

            this.data("treetable").sortBranch(node, sortFun);
            return this;
        },

        unloadBranch: function(node) {
            this.data("treetable").unloadBranch(node);
            return this;
        }
    };

    $.fn.treetable = function(method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return methods.init.apply(this, arguments);
        } else {
            return $.error("Method " + method + " does not exist on jQuery.treetable");
        }
    };

    // Expose classes to world
    this.TreeTable || (this.TreeTable = {});
    this.TreeTable.Node = Node;
    this.TreeTable.Tree = Tree;
}).call(this);

/*
 * jQuery File Download Plugin v1.4.3
 *
 * http://www.johnculviner.com
 *
 * Copyright (c) 2013 - John Culviner
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * !!!!NOTE!!!!
 * You must also write a cookie in conjunction with using this plugin as mentioned in the orignal post:
 * http://johnculviner.com/jquery-file-download-plugin-for-ajax-like-feature-rich-file-downloads/
 * !!!!NOTE!!!!
 */

(function($, window){
    // i'll just put them here to get evaluated on script load
    var htmlSpecialCharsRegEx = /[<>&\r\n"']/gm;
    var htmlSpecialCharsPlaceHolders = {
        '<': 'lt;',
        '>': 'gt;',
        '&': 'amp;',
        '\r': "#13;",
        '\n': "#10;",
        '"': 'quot;',
        "'": '#39;' /*single quotes just to be safe, IE8 doesn't support &apos;, so use &#39; instead */
    };

    $.extend({
        //
        //$.fileDownload('/path/to/url/', options)
        //  see directly below for possible 'options'
        fileDownload: function (fileUrl, options) {

            //provide some reasonable defaults to any unspecified options below
            var settings = $.extend({

                //
                //Requires jQuery UI: provide a message to display to the user when the file download is being prepared before the browser's dialog appears
                //
                preparingMessageHtml: null,

                //
                //Requires jQuery UI: provide a message to display to the user when a file download fails
                //
                failMessageHtml: null,

                //
                //the stock android browser straight up doesn't support file downloads initiated by a non GET: http://code.google.com/p/android/issues/detail?id=1780
                //specify a message here to display if a user tries with an android browser
                //if jQuery UI is installed this will be a dialog, otherwise it will be an alert
                //Set to null to disable the message and attempt to download anyway
                //
                androidPostUnsupportedMessageHtml: "Unfortunately your Android browser doesn't support this type of file download. Please try again with a different browser.",

                //
                //Requires jQuery UI: options to pass into jQuery UI Dialog
                //
                dialogOptions: { modal: true },

                //
                //a function to call while the dowload is being prepared before the browser's dialog appears
                //Args:
                //  url - the original url attempted
                //
                prepareCallback: function (url) { },

                //
                //a function to call after a file download dialog/ribbon has appeared
                //Args:
                //  url - the original url attempted
                //
                successCallback: function (url) { },

                //
                //a function to call after a file download dialog/ribbon has appeared
                //Args:
                //  responseHtml    - the html that came back in response to the file download. this won't necessarily come back depending on the browser.
                //                      in less than IE9 a cross domain error occurs because 500+ errors cause a cross domain issue due to IE subbing out the
                //                      server's error message with a "helpful" IE built in message
                //  url             - the original url attempted
                //
                failCallback: function (responseHtml, url) { },

                //
                // the HTTP method to use. Defaults to "GET".
                //
                httpMethod: "GET",

                //
                // if specified will perform a "httpMethod" request to the specified 'fileUrl' using the specified data.
                // data must be an object (which will be $.param serialized) or already a key=value param string
                //
                data: null,

                //
                //a period in milliseconds to poll to determine if a successful file download has occured or not
                //
                checkInterval: 100,

                //
                //the cookie name to indicate if a file download has occured
                //
                cookieName: "fileDownload",

                //
                //the cookie value for the above name to indicate that a file download has occured
                //
                cookieValue: "true",

                //
                //the cookie path for above name value pair
                //
                cookiePath: "/",

                //
                //if specified it will be used when attempting to clear the above name value pair
                //useful for when downloads are being served on a subdomain (e.g. downloads.example.com)
                //
                cookieDomain: null,

                //
                //the title for the popup second window as a download is processing in the case of a mobile browser
                //
                popupWindowTitle: "Initiating file download...",

                //
                //Functionality to encode HTML entities for a POST, need this if data is an object with properties whose values contains strings with quotation marks.
                //HTML entity encoding is done by replacing all &,<,>,',",\r,\n characters.
                //Note that some browsers will POST the string htmlentity-encoded whilst others will decode it before POSTing.
                //It is recommended that on the server, htmlentity decoding is done irrespective.
                //
                encodeHTMLEntities: true

            }, options);

            var deferred = new $.Deferred();

            //Setup mobile browser detection: Partial credit: http://detectmobilebrowser.com/
            var userAgent = (navigator.userAgent || navigator.vendor || window.opera).toLowerCase();

            var isIos;                  //has full support of features in iOS 4.0+, uses a new window to accomplish this.
            var isAndroid;              //has full support of GET features in 4.0+ by using a new window. Non-GET is completely unsupported by the browser. See above for specifying a message.
            var isOtherMobileBrowser;   //there is no way to reliably guess here so all other mobile devices will GET and POST to the current window.

            if (/ip(ad|hone|od)/.test(userAgent)) {

                isIos = true;

            } else if (userAgent.indexOf('android') !== -1) {

                isAndroid = true;

            } else {

                isOtherMobileBrowser = /avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|playbook|silk|iemobile|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|e\-|e\/|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(di|rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|xda(\-|2|g)|yas\-|your|zeto|zte\-/i.test(userAgent.substr(0, 4));

            }

            var httpMethodUpper = settings.httpMethod.toUpperCase();

            if (isAndroid && httpMethodUpper !== "GET" && settings.androidPostUnsupportedMessageHtml) {
                //the stock android browser straight up doesn't support file downloads initiated by non GET requests: http://code.google.com/p/android/issues/detail?id=1780

                if ($().dialog) {
                    $("<div>").html(settings.androidPostUnsupportedMessageHtml).dialog(settings.dialogOptions);
                } else {
                    alert(settings.androidPostUnsupportedMessageHtml);
                }

                return deferred.reject();
            }

            var $preparingDialog = null;

            var internalCallbacks = {

                onPrepare: function (url) {

                    //wire up a jquery dialog to display the preparing message if specified
                    if (settings.preparingMessageHtml) {

                        $preparingDialog = $("<div>").html(settings.preparingMessageHtml).dialog(settings.dialogOptions);

                    } else if (settings.prepareCallback) {

                        settings.prepareCallback(url);

                    }

                },

                onSuccess: function (url) {

                    //remove the perparing message if it was specified
                    if ($preparingDialog) {
                        $preparingDialog.dialog('close');
                    }

                    settings.successCallback(url);

                    deferred.resolve(url);
                },

                onFail: function (responseHtml, url) {

                    //remove the perparing message if it was specified
                    if ($preparingDialog) {
                        $preparingDialog.dialog('close');
                    }

                    //wire up a jquery dialog to display the fail message if specified
                    if (settings.failMessageHtml) {
                        $("<div>").html(settings.failMessageHtml).dialog(settings.dialogOptions);
                    }

                    settings.failCallback(responseHtml, url);

                    deferred.reject(responseHtml, url);
                }
            };

            internalCallbacks.onPrepare(fileUrl);

            //make settings.data a param string if it exists and isn't already
            if (settings.data !== null && typeof settings.data !== "string") {
                settings.data = $.param(settings.data);
            }


            var $iframe,
                downloadWindow,
                formDoc,
                $form;

            if (httpMethodUpper === "GET") {

                if (settings.data !== null) {
                    //need to merge any fileUrl params with the data object

                    var qsStart = fileUrl.indexOf('?');

                    if (qsStart !== -1) {
                        //we have a querystring in the url

                        if (fileUrl.substring(fileUrl.length - 1) !== "&") {
                            fileUrl = fileUrl + "&";
                        }
                    } else {

                        fileUrl = fileUrl + "?";
                    }

                    fileUrl = fileUrl + settings.data;
                }

                if (isIos || isAndroid) {

                    downloadWindow = window.open(fileUrl);
                    downloadWindow.document.title = settings.popupWindowTitle;
                    window.focus();

                } else if (isOtherMobileBrowser) {

                    window.location(fileUrl);

                } else {

                    //create a temporary iframe that is used to request the fileUrl as a GET request
                    $iframe = $("<iframe>")
                        .hide()
                        .prop("src", fileUrl)
                        .appendTo("body");
                }

            } else {

                var formInnerHtml = "";

                if (settings.data !== null) {

                    $.each(settings.data.replace(/\+/g, ' ').split("&"), function () {

                        var kvp = this.split("=");

                        var key = settings.encodeHTMLEntities ? htmlSpecialCharsEntityEncode(decodeURIComponent(kvp[0])) : decodeURIComponent(kvp[0]);
                        if (key) {
                            var value = settings.encodeHTMLEntities ? htmlSpecialCharsEntityEncode(decodeURIComponent(kvp[1])) : decodeURIComponent(kvp[1]);
                            formInnerHtml += '<input type="hidden" name="' + key + '" value="' + value + '" />';
                        }
                    });
                }

                if (isOtherMobileBrowser) {

                    $form = $("<form>").appendTo("body");
                    $form.hide()
                        .prop('method', settings.httpMethod)
                        .prop('action', fileUrl)
                        .html(formInnerHtml);

                } else {

                    if (isIos) {

                        downloadWindow = window.open("about:blank");
                        downloadWindow.document.title = settings.popupWindowTitle;
                        formDoc = downloadWindow.document;
                        window.focus();

                    } else {

                        $iframe = $("<iframe style='display: none' src='about:blank'></iframe>").appendTo("body");
                        formDoc = getiframeDocument($iframe);
                    }

                    formDoc.write("<html><head></head><body><form method='" + settings.httpMethod + "' action='" + fileUrl + "'>" + formInnerHtml + "</form>" + settings.popupWindowTitle + "</body></html>");
                    $form = $(formDoc).find('form');
                }

                $form.submit();
            }


            //check if the file download has completed every checkInterval ms
            setTimeout(checkFileDownloadComplete, settings.checkInterval);


            function checkFileDownloadComplete() {
                //has the cookie been written due to a file download occuring?

                var cookieValue = settings.cookieValue;
                if(typeof cookieValue == 'string') {
                    cookieValue = cookieValue.toLowerCase();
                }

                var lowerCaseCookie = settings.cookieName.toLowerCase() + "=" + cookieValue;

                if (document.cookie.toLowerCase().indexOf(lowerCaseCookie) > -1) {

                    //execute specified callback
                    internalCallbacks.onSuccess(fileUrl);

                    //remove cookie
                    var cookieData = settings.cookieName + "=; path=" + settings.cookiePath + "; expires=" + new Date(0).toUTCString() + ";";
                    if (settings.cookieDomain) cookieData += " domain=" + settings.cookieDomain + ";";
                    document.cookie = cookieData;

                    //remove iframe
                    cleanUp(false);

                    return;
                }

                //has an error occured?
                //if neither containers exist below then the file download is occuring on the current window
                if (downloadWindow || $iframe) {

                    //has an error occured?
                    try {

                        var formDoc = downloadWindow ? downloadWindow.document : getiframeDocument($iframe);

                        if (formDoc && formDoc.body !== null && formDoc.body.innerHTML.length) {

                            var isFailure = true;

                            if ($form && $form.length) {
                                var $contents = $(formDoc.body).contents().first();

                                try {
                                    if ($contents.length && $contents[0] === $form[0]) {
                                        isFailure = false;
                                    }
                                } catch (e) {
                                    if (e && e.number == -2146828218) {
                                        // IE 8-10 throw a permission denied after the form reloads on the "$contents[0] === $form[0]" comparison
                                        isFailure = true;
                                    } else {
                                        throw e;
                                    }
                                }
                            }

                            if (isFailure) {
                                // IE 8-10 don't always have the full content available right away, they need a litle bit to finish
                                setTimeout(function () {
                                    internalCallbacks.onFail(formDoc.body.innerHTML, fileUrl);
                                    cleanUp(true);
                                }, 100);

                                return;
                            }
                        }
                    }
                    catch (err) {

                        //500 error less than IE9
                        internalCallbacks.onFail('', fileUrl);

                        cleanUp(true);

                        return;
                    }
                }


                //keep checking...
                setTimeout(checkFileDownloadComplete, settings.checkInterval);
            }

            //gets an iframes document in a cross browser compatible manner
            function getiframeDocument($iframe) {
                var iframeDoc = $iframe[0].contentWindow || $iframe[0].contentDocument;
                if (iframeDoc.document) {
                    iframeDoc = iframeDoc.document;
                }
                return iframeDoc;
            }

            function cleanUp(isFailure) {

                setTimeout(function() {

                    if (downloadWindow) {

                        if (isAndroid) {
                            downloadWindow.close();
                        }

                        if (isIos) {
                            if (downloadWindow.focus) {
                                downloadWindow.focus(); //ios safari bug doesn't allow a window to be closed unless it is focused
                                if (isFailure) {
                                    downloadWindow.close();
                                }
                            }
                        }
                    }

                    //iframe cleanup appears to randomly cause the download to fail
                    //not doing it seems better than failure...
                    //if ($iframe) {
                    //    $iframe.remove();
                    //}

                }, 0);
            }


            function htmlSpecialCharsEntityEncode(str) {
                return str.replace(htmlSpecialCharsRegEx, function(match) {
                    return '&' + htmlSpecialCharsPlaceHolders[match];
                });
            }
            var promise = deferred.promise();
            promise.abort = function() {
                cleanUp();
                $iframe.remove();
            };
            return promise;
        }
    });

})(jQuery, this);

/******************************************************************************
 * jquery.i18n.properties
 * 
 * Dual licensed under the GPL (http://dev.jquery.com/browser/trunk/jquery/GPL-LICENSE.txt) and 
 * MIT (http://dev.jquery.com/browser/trunk/jquery/MIT-LICENSE.txt) licenses.
 * 
 * @version     1.0.x
 * @author      Nuno Fernandes
 * @url         www.codingwithcoffee.com
 * @inspiration Localisation assistance for jQuery (http://keith-wood.name/localisation.html)
 *              by Keith Wood (kbwood{at}iinet.com.au) June 2007
 * 
 *****************************************************************************/

(function($) {
$.i18n = {};

/** Map holding bundle keys (if mode: 'map') */
$.i18n.map = {};
    
/**
 * Load and parse message bundle files (.properties),
 * making bundles keys available as javascript variables.
 * 
 * i18n files are named <name>.js, or <name>_<language>.js or <name>_<language>_<country>.js
 * Where:
 *      The <language> argument is a valid ISO Language Code. These codes are the lower-case, 
 *      two-letter codes as defined by ISO-639. You can find a full list of these codes at a 
 *      number of sites, such as: http://www.loc.gov/standards/iso639-2/englangn.html
 *      The <country> argument is a valid ISO Country Code. These codes are the upper-case,
 *      two-letter codes as defined by ISO-3166. You can find a full list of these codes at a
 *      number of sites, such as: http://www.iso.ch/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html
 * 
 * Sample usage for a bundles/Messages.properties bundle:
 * $.i18n.properties({
 *      name:      'Messages', 
 *      language:  'en_US',
 *      path:      'bundles'
 * });
 * @param  name			(string/string[], optional) names of file to load (eg, 'Messages' or ['Msg1','Msg2']). Defaults to "Messages"
 * @param  language		(string, optional) language/country code (eg, 'en', 'en_US', 'pt_PT'). if not specified, language reported by the browser will be used instead.
 * @param  path			(string, optional) path of directory that contains file to load
 * @param  mode			(string, optional) whether bundles keys are available as JavaScript variables/functions or as a map (eg, 'vars' or 'map')
 * @param  cache        (boolean, optional) whether bundles should be cached by the browser, or forcibly reloaded on each page load. Defaults to false (i.e. forcibly reloaded)
 * @param  encoding 	(string, optional) the encoding to request for bundles. Property file resource bundles are specified to be in ISO-8859-1 format. Defaults to UTF-8 for backward compatibility.
 * @param  callback     (function, optional) callback function to be called after script is terminated
 */
$.i18n.properties = function(settings) {
	// set up settings
    var defaults = {
        name:           'Messages',
        language:       '',
        path:           '',  
        mode:           'vars',
        cache:			false,
        encoding:       'UTF-8',
        callback:       null
    };
    settings = $.extend(defaults, settings);    
    if(settings.language === null || settings.language == '') {
	   settings.language = $.i18n.browserLang();
	}
	if(settings.language === null) {settings.language='';}
	
	// load and parse bundle files
	var files = getFiles(settings.name);
	for(i=0; i<files.length; i++) {
		// 1. load base (eg, Messages.properties)
		loadAndParseFile(settings.path + files[i] + '.properties', settings);
        // 2. with language code (eg, Messages_pt.properties)
		if(settings.language.length >= 2) {
            loadAndParseFile(settings.path + files[i] + '_' + settings.language.substring(0, 2) +'.properties', settings);
		}
		// 3. with language code and country code (eg, Messages_pt_PT.properties)
        if(settings.language.length >= 5) {
            loadAndParseFile(settings.path + files[i] + '_' + settings.language.substring(0, 5) +'.properties', settings);
        }
	}
	
	// call callback
	if(settings.callback){ settings.callback(); }
};


/**
 * When configured with mode: 'map', allows access to bundle values by specifying its key.
 * Eg, jQuery.i18n.prop('com.company.bundles.menu_add')
 */
$.i18n.prop = function(key /* Add parameters as function arguments as necessary  */) {
	var value = $.i18n.map[key];
	if (value == null)
		return '[' + key + ']';
	
//	if(arguments.length < 2) // No arguments.
//    //if(key == 'spv.lbl.modified') {alert(value);}
//		return value;
	
//	if (!$.isArray(placeHolderValues)) {
//		// If placeHolderValues is not an array, make it into one.
//		placeHolderValues = [placeHolderValues];
//		for (var i=2; i<arguments.length; i++)
//			placeHolderValues.push(arguments[i]);
//	}

	// Place holder replacement
	/**
	 * Tested with:
	 *   test.t1=asdf ''{0}''
	 *   test.t2=asdf '{0}' '{1}'{1}'zxcv
	 *   test.t3=This is \"a quote" 'a''{0}''s'd{fgh{ij'
	 *   test.t4="'''{'0}''" {0}{a}
	 *   test.t5="'''{0}'''" {1}
	 *   test.t6=a {1} b {0} c
	 *   test.t7=a 'quoted \\ s\ttringy' \t\t x
	 *
	 * Produces:
	 *   test.t1, p1 ==> asdf 'p1'
	 *   test.t2, p1 ==> asdf {0} {1}{1}zxcv
	 *   test.t3, p1 ==> This is "a quote" a'{0}'sd{fgh{ij
	 *   test.t4, p1 ==> "'{0}'" p1{a}
	 *   test.t5, p1 ==> "'{0}'" {1}
	 *   test.t6, p1 ==> a {1} b p1 c
	 *   test.t6, p1, p2 ==> a p2 b p1 c
	 *   test.t6, p1, p2, p3 ==> a p2 b p1 c
	 *   test.t7 ==> a quoted \ s	tringy 		 x
	 */
	
	var i;
	if (typeof(value) == 'string') {
        // Handle escape characters. Done separately from the tokenizing loop below because escape characters are 
		// active in quoted strings.
        i = 0;
        while ((i = value.indexOf('\\', i)) != -1) {
 		   if (value[i+1] == 't')
 			   value = value.substring(0, i) + '\t' + value.substring((i++) + 2); // tab
 		   else if (value[i+1] == 'r')
 			   value = value.substring(0, i) + '\r' + value.substring((i++) + 2); // return
 		   else if (value[i+1] == 'n')
 			   value = value.substring(0, i) + '\n' + value.substring((i++) + 2); // line feed
 		   else if (value[i+1] == 'f')
 			   value = value.substring(0, i) + '\f' + value.substring((i++) + 2); // form feed
 		   else if (value[i+1] == '\\')
 			   value = value.substring(0, i) + '\\' + value.substring((i++) + 2); // \
 		   else
 			   value = value.substring(0, i) + value.substring(i+1); // Quietly drop the character
        }
		
		// Lazily convert the string to a list of tokens.
		var arr = [], j, index;
		i = 0;
		while (i < value.length) {
			if (value[i] == '\'') {
				// Handle quotes
				if (i == value.length-1)
					value = value.substring(0, i); // Silently drop the trailing quote
				else if (value[i+1] == '\'')
					value = value.substring(0, i) + value.substring(++i); // Escaped quote
				else {
					// Quoted string
					j = i + 2;
					while ((j = value.indexOf('\'', j)) != -1) {
						if (j == value.length-1 || value[j+1] != '\'') {
							// Found start and end quotes. Remove them
							value = value.substring(0,i) + value.substring(i+1, j) + value.substring(j+1);
							i = j - 1;
							break;
						}
						else {
							// Found a double quote, reduce to a single quote.
							value = value.substring(0,j) + value.substring(++j);
						}
					}
					
					if (j == -1) {
						// There is no end quote. Drop the start quote
						value = value.substring(0,i) + value.substring(i+1);
					}
				}
			}
			else if (value[i] == '{') {
				// Beginning of an unquoted place holder.
				j = value.indexOf('}', i+1);
				if (j == -1)
					i++; // No end. Process the rest of the line. Java would throw an exception
				else {
					// Add 1 to the index so that it aligns with the function arguments.
					index = parseInt(value.substring(i+1, j));
					if (!isNaN(index) && index >= 0) {
						// Put the line thus far (if it isn't empty) into the array
						var s = value.substring(0, i);
						if (s != "")
							arr.push(s);
						// Put the parameter reference into the array
						arr.push(index);
						// Start the processing over again starting from the rest of the line.
						i = 0;
						value = value.substring(j+1);
					}
					else
						i = j + 1; // Invalid parameter. Leave as is.
				}
			}
			else
				i++;
		}
		
		// Put the remainder of the no-empty line into the array.
		if (value != "")
			arr.push(value);
		value = arr;
		
		// Make the array the value for the entry.
		$.i18n.map[key] = arr;
	}
	
	if (value.length == 0)
		return "";
	if (value.lengh == 1 && typeof(value[0]) == "string")
		return value[0];
	
	var s = "";
	for (i=0; i<value.length; i++) {
		if (typeof(value[i]) == "string")
			s += value[i];
		// Must be a number
		else if (value[i] + 1 < arguments.length)
			s += arguments[value[i] + 1];
		else
			s += "{"+ value[i] +"}";
	}
	
	return s;
};

/** Language reported by browser, normalized code */
$.i18n.browserLang = function() {
	return normaliseLanguageCode(navigator.language /* Mozilla */ || navigator.userLanguage /* IE */);
}


/** Load and parse .properties files */
function loadAndParseFile(filename, settings) {
	$.ajax({
        url:        filename,
        async:      false,
        cache:		settings.cache,
        contentType:'text/plain;charset='+ settings.encoding,
        dataType:   'text',
        success:    function(data, status) {
        				parseData(data, settings.mode); 
					}
    });
}

/** Parse .properties files */
function parseData(data, mode) {
   var parsed = '';
   var parameters = data.split( /\n/ );
   var regPlaceHolder = /(\{\d+\})/g;
   var regRepPlaceHolder = /\{(\d+)\}/g;
   var unicodeRE = /(\\u.{4})/ig;
   for(var i=0; i<parameters.length; i++ ) {
       parameters[i] = parameters[i].replace( /^\s\s*/, '' ).replace( /\s\s*$/, '' ); // trim
       if(parameters[i].length > 0 && parameters[i].match("^#")!="#") { // skip comments
           var pair = parameters[i].split('=');
           if(pair.length > 0) {
               /** Process key & value */
               var name = unescape(pair[0]).replace( /^\s\s*/, '' ).replace( /\s\s*$/, '' ); // trim
               var value = pair.length == 1 ? "" : pair[1];
               // process multi-line values
               while(value.match(/\\$/)=="\\") {
               		value = value.substring(0, value.length - 1);
               		value += parameters[++i].replace( /\s\s*$/, '' ); // right trim
               }               
               // Put values with embedded '='s back together
               for(var s=2;s<pair.length;s++){ value +='=' + pair[s]; }
               value = value.replace( /^\s\s*/, '' ).replace( /\s\s*$/, '' ); // trim
               
               /** Mode: bundle keys in a map */
               if(mode == 'map' || mode == 'both') {
                   // handle unicode chars possibly left out
                   var unicodeMatches = value.match(unicodeRE);
                   if(unicodeMatches) {
                     for(var u=0; u<unicodeMatches.length; u++) {
                        value = value.replace( unicodeMatches[u], unescapeUnicode(unicodeMatches[u]));
                     }
                   }
                   // add to map
                   $.i18n.map[name] = value;
               }
               
               /** Mode: bundle keys as vars/functions */
               if(mode == 'vars' || mode == 'both') {
                   value = value.replace( /"/g, '\\"' ); // escape quotation mark (")
                   
                   // make sure namespaced key exists (eg, 'some.key') 
                   checkKeyNamespace(name);
                   
                   // value with variable substitutions
                   if(regPlaceHolder.test(value)) {
                       var parts = value.split(regPlaceHolder);
                       // process function args
                       var first = true;
                       var fnArgs = '';
                       var usedArgs = [];
                       for(var p=0; p<parts.length; p++) {
                           if(regPlaceHolder.test(parts[p]) && (usedArgs.length == 0 || usedArgs.indexOf(parts[p]) == -1)) {
                               if(!first) {fnArgs += ',';}
                               fnArgs += parts[p].replace(regRepPlaceHolder, 'v$1');
                               usedArgs.push(parts[p]);
                               first = false;
                           }
                       }
                       parsed += name + '=function(' + fnArgs + '){';
                       // process function body
                       var fnExpr = '"' + value.replace(regRepPlaceHolder, '"+v$1+"') + '"';
                       parsed += 'return ' + fnExpr + ';' + '};';
                       
                   // simple value
                   }else{
                       parsed += name+'="'+value+'";';
                   }
               } // END: Mode: bundle keys as vars/functions
           } // END: if(pair.length > 0)
       } // END: skip comments
   }
   eval(parsed);
}

/** Make sure namespace exists (for keys with dots in name) */
// TODO key parts that start with numbers quietly fail. i.e. month.short.1=Jan
function checkKeyNamespace(key) {
	var regDot = /\./;
	if(regDot.test(key)) {
		var fullname = '';
		var names = key.split( /\./ );
		for(var i=0; i<names.length; i++) {
			if(i>0) {fullname += '.';}
			fullname += names[i];
			if(eval('typeof '+fullname+' == "undefined"')) {
				eval(fullname + '={};');
			}
		}
	}
}

/** Make sure filename is an array */
function getFiles(names) {
	return (names && names.constructor == Array) ? names : [names];
}

/** Ensure language code is in the format aa_AA. */
function normaliseLanguageCode(lang) {
    lang = lang.toLowerCase();
    if(lang.length > 3) {
        lang = lang.substring(0, 3) + lang.substring(3).toUpperCase();
    }
    return lang;
}

/** Unescape unicode chars ('\u00e3') */
function unescapeUnicode(str) {
  // unescape unicode codes
  var codes = [];
  var code = parseInt(str.substr(2), 16);
  if (code >= 0 && code < Math.pow(2, 16)) {
     codes.push(code);
  }
  // convert codes to text
  var unescaped = '';
  for (var i = 0; i < codes.length; ++i) {
    unescaped += String.fromCharCode(codes[i]);
  }
  return unescaped;
}

/* Cross-Browser Split 1.0.1
(c) Steven Levithan <stevenlevithan.com>; MIT License
An ECMA-compliant, uniform cross-browser split method */
var cbSplit;
// avoid running twice, which would break `cbSplit._nativeSplit`'s reference to the native `split`
if (!cbSplit) {    
  cbSplit = function(str, separator, limit) {
      // if `separator` is not a regex, use the native `split`
      if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
        if(typeof cbSplit._nativeSplit == "undefined")
          return str.split(separator, limit);
        else
          return cbSplit._nativeSplit.call(str, separator, limit);
      }
  
      var output = [],
          lastLastIndex = 0,
          flags = (separator.ignoreCase ? "i" : "") +
                  (separator.multiline  ? "m" : "") +
                  (separator.sticky     ? "y" : ""),
          separator = RegExp(separator.source, flags + "g"), // make `global` and avoid `lastIndex` issues by working with a copy
          separator2, match, lastIndex, lastLength;
  
      str = str + ""; // type conversion
      if (!cbSplit._compliantExecNpcg) {
          separator2 = RegExp("^" + separator.source + "$(?!\\s)", flags); // doesn't need /g or /y, but they don't hurt
      }
  
      /* behavior for `limit`: if it's...
      - `undefined`: no limit.
      - `NaN` or zero: return an empty array.
      - a positive number: use `Math.floor(limit)`.
      - a negative number: no limit.
      - other: type-convert, then use the above rules. */
      if (limit === undefined || +limit < 0) {
          limit = Infinity;
      } else {
          limit = Math.floor(+limit);
          if (!limit) {
              return [];
          }
      }
  
      while (match = separator.exec(str)) {
          lastIndex = match.index + match[0].length; // `separator.lastIndex` is not reliable cross-browser
  
          if (lastIndex > lastLastIndex) {
              output.push(str.slice(lastLastIndex, match.index));
  
              // fix browsers whose `exec` methods don't consistently return `undefined` for nonparticipating capturing groups
              if (!cbSplit._compliantExecNpcg && match.length > 1) {
                  match[0].replace(separator2, function () {
                      for (var i = 1; i < arguments.length - 2; i++) {
                          if (arguments[i] === undefined) {
                              match[i] = undefined;
                          }
                      }
                  });
              }
  
              if (match.length > 1 && match.index < str.length) {
                  Array.prototype.push.apply(output, match.slice(1));
              }
  
              lastLength = match[0].length;
              lastLastIndex = lastIndex;
  
              if (output.length >= limit) {
                  break;
              }
          }
  
          if (separator.lastIndex === match.index) {
              separator.lastIndex++; // avoid an infinite loop
          }
      }
  
      if (lastLastIndex === str.length) {
          if (lastLength || !separator.test("")) {
              output.push("");
          }
      } else {
          output.push(str.slice(lastLastIndex));
      }
  
      return output.length > limit ? output.slice(0, limit) : output;
  };
  
  cbSplit._compliantExecNpcg = /()??/.exec("")[1] === undefined; // NPCG: nonparticipating capturing group
  cbSplit._nativeSplit = String.prototype.split;

} // end `if (!cbSplit)`
String.prototype.split = function (separator, limit) {
    return cbSplit(this, separator, limit);
};

})(jQuery);
                
(function (ng) {
    'use strict';
    var module = ng.module('lrDragNDrop', []);

    module.service('lrDragStore', ['$document', function (document) {

        var store = {};

        this.hold = function hold(key, item, collectionFrom, safe) {
            store[key] = {
                item: item,
                collection: collectionFrom,
                safe: safe === true
            }
        };

        this.get = function (namespace) {
            var
                modelItem = store[namespace], itemIndex;
            if (modelItem) {
                itemIndex = modelItem.collection.indexOf(modelItem.item);
                return modelItem.safe === true ? modelItem.item : modelItem.collection.splice(itemIndex, 1)[0];
            } else {
                return null;
            }
        };

        this.clean = function clean() {
            store = {};
        };

        this.isHolding = function (namespace) {
            return store[namespace] !== undefined;
        };

        document.bind('dragend', this.clean);
    }]);

    function parseRepeater(scope, attr) {
        var
            repeatExpression = attr.ngRepeat,
            match;

        if (!repeatExpression) {
            throw Error('this directive must be used with ngRepeat directive');
        }
        match = repeatExpression.match(/^(.*\sin).(\S*)/);
        if (!match) {
            throw Error("Expected ngRepeat in form of '_item_ in _collection_' but got '" +
                repeatExpression + "'.");
        }

        return scope.$eval(match[2]);
    }

    function lrDragSrcDirective(store, safe) {
        return function compileFunc(el, iattr) {
            iattr.$set('draggable', true);
            return function linkFunc(scope, element, attr) {
                var
                    collection,
                    key = (safe === true ? attr.lrDragSrcSafe : attr.lrDragSrc ) || 'temp';

                collection = parseRepeater(scope, attr);

                element.bind('dragstart', function (evt) {
                    store.hold(key, collection[scope.$index], collection, safe);
                });
            }
        }
    }

    module.directive('lrDragSrc', ['lrDragStore', function (store) {
        return{
            compile: lrDragSrcDirective(store)
        };
    }]);

    module.directive('lrDragSrcSafe', ['lrDragStore', function (store) {
        return{
            compile: lrDragSrcDirective(store, true)
        };
    }]);

    module.directive('lrDropTarget', ['lrDragStore', function (store) {
        return {
            link: function (scope, element, attr) {

                var
                    collection,
                    key = attr.lrDropTarget || 'temp',
                    classCache = null;

                function isAfter(x, y) {
                    //check if below or over the diagonal of the box element
                    return (element[0].offsetHeight - x * element[0].offsetHeight / element[0].offsetWidth) < y;
                }

                function resetStyle() {
                    if (classCache !== null) {
                        element.removeClass(classCache);
                        classCache = null;
                    }
                }

                collection = parseRepeater(scope, attr);

                element.bind('drop', function (evt) {
                    var
                        collectionCopy = ng.copy(collection),
                        item = store.get(key),
                        dropIndex, i, l;

                    if (item !== null) {
                        dropIndex = scope.$index;
                        dropIndex = isAfter(evt.offsetX, evt.offsetY) ? dropIndex + 1 : dropIndex;
                        //srcCollection=targetCollection => we may need to apply a correction
                        if (collectionCopy.length > collection.length) {
                            for (i = 0, l = Math.min(dropIndex, collection.length - 1); i <= l; i++) {
                                if (!ng.equals(collectionCopy[i], collection[i])) {
                                    dropIndex = dropIndex - 1;
                                    break;
                                }
                            }
                        }
                        scope.$apply(function () {
                            collection.splice(dropIndex, 0, item);
                        });
                        evt.preventDefault();
                        resetStyle();
                        store.clean();
                    }
                });

                element.bind('dragleave', resetStyle);

                element.bind('dragover', function (evt) {
                    var className;
                    if (store.isHolding(key)) {
                        className = isAfter(evt.offsetX, evt.offsetY) ? 'lr-drop-target-after' : 'lr-drop-target-before';
                        if (classCache !== className && classCache !== null) {
                            element.removeClass(classCache);
                        }
                        if (classCache !== className) {
                            element.addClass(className);
                        }
                        classCache = className;
                    }
                    evt.preventDefault();
                });
            }
        };
    }]);
})(angular);
// Todo:
// 1) Make the button prettier
// 2) add a config option for IE users which takes a URL.  That URL should accept a POST request with a
//    JSON encoded object in the payload and return a CSV.  This is necessary because IE doesn't let you
//    download from a data-uri link
//
// Notes:  This has not been adequately tested and is very much a proof of concept at this point
function ngGridCsvExportPlugin (opts) {
    var self = this;
    self.grid = null;
    self.scope = null;
    self.services = null;
    self.init = function(scope, grid, services) {
        self.grid = grid;
        self.scope = scope;
        self.services = services;
        function showDs() {
            var keys = [];
            for (var f in grid.config.columnDefs) { keys.push(grid.config.columnDefs[f].field);}
            var csvData = '';
            function csvStringify(str) {
                if (str == null) { // we want to catch anything null-ish, hence just == not ===
                    return '';
                }
                if (typeof(str) === 'number') {
                    return '' + str;
                }
                if (typeof(str) === 'boolean') {
                    return (str ? 'TRUE' : 'FALSE') ;
                }
                if (typeof(str) === 'string') {
                    return str.replace(/"/g,'""');
                }

                return JSON.stringify(str).replace(/"/g,'""');
            }
            function swapLastCommaForNewline(str) {
                var newStr = str.substr(0,str.length - 1);
                return newStr + "\n";
            }
            // FIX to use display name headers
//            for (var k in keys) {
//                csvData += '"' + csvStringify(keys[k]) + '",';
//            }
            for (var f in grid.config.columnDefs) {
                csvData += '"' + csvStringify(grid.config.columnDefs[f].displayName) + '",';
            }
            csvData = swapLastCommaForNewline(csvData);
            var gridData = grid.data;
            for (var gridRow in gridData) {
                for ( k in keys) {
                    var curCellRaw;
                    if (opts != null && opts.columnOverrides != null && opts.columnOverrides[keys[k]] != null) {
                        // FIX line below to handle nested properties
//                        curCellRaw = opts.columnOverrides[keys[k]](gridData[gridRow][keys[k]]);
                        curCellRaw = opts.columnOverrides[keys[k]](services.UtilityService.evalProperty(gridData[gridRow],keys[k]));
                    }
                    else {
//                        // FIX line below to handle nested properties
//                        curCellRaw = gridData[gridRow][keys[k]];
                        curCellRaw = services.UtilityService.evalProperty(gridData[gridRow],keys[k]);
                    }
                    csvData += '"' + csvStringify(curCellRaw) + '",';
                }
                csvData = swapLastCommaForNewline(csvData);
            }
            var fp = grid.$root.find(".ngFooterPanel");
            var csvDataLinkPrevious = grid.$root.find('.ngFooterPanel .csv-data-link-span');
            if (csvDataLinkPrevious != null) {csvDataLinkPrevious.remove() ; }
            var csvDataLinkHtml = "<div class=\"csv-data-link-span\">";
            csvDataLinkHtml += "<br><a href=\"data:text/csv;charset=UTF-8,";
            csvDataLinkHtml += encodeURIComponent(csvData);
            csvDataLinkHtml += "\" download=\"Export.csv\">CSV Export</a></br></div>" ;
            fp.append(csvDataLinkHtml);
        }
        setTimeout(showDs, 0);
        scope.catHashKeys = function() {
            var hash = '';
            for (var idx in scope.renderedRows) {
                hash += scope.renderedRows[idx].$$hashKey;
            }
            return hash;
        };
        if (opts.customDataWatcher) {
            scope.$watch(opts.customDataWatcher, showDs);
        } else {
            scope.$watch(scope.catHashKeys, showDs);
        }
    };
}

/**
 * Created by haffo on 6/9/14.
 */


if (typeof String.prototype.startsWith != 'function') {
    String.prototype.startsWith = function (str) {
        return this.slice(0, str.length) == str;
    };
}


if (typeof String.prototype.endsWith != 'function') {
    String.prototype.endsWith = function (str) {
        return this.slice(-str.length) == str;
    };
}


var waitingDialog = (function ($) {
    // Creating modal dialog's DOM
    var $dialog = $(
            '<div class="modal fade" data-backdrop="static" data-keyboard="false" tabindex="-1" role="dialog" aria-hidden="true" style="padding-top:15%; overflow-y:visible;">' +
            '<div class="modal-dialog modal-m">' +
            '<div class="modal-content">' +
            '<div class="modal-header"><h3 style="margin:0;"></h3></div>' +
            '<div class="modal-body">' +
            '<div class="progress progress-striped active" style="margin-bottom:0;"><div class="progress-bar" style="width: 100%"></div></div>' +
            '</div>' +
            '</div></div></div>');

    return {
        /**
         * Opens our dialog
         * @param message Custom message
         * @param options Custom options:
         * 				  options.dialogSize - bootstrap postfix for dialog size, e.g. "sm", "m";
         * 				  options.progressType - bootstrap postfix for progress bar type, e.g. "success", "warning".
         */
        show: function (message, options) {
            // Assigning defaults
            var settings = $.extend({
                dialogSize: 'xs',
                progressType: ''
            }, options);
            if (typeof message === 'undefined') {
                message = 'Loading';
            }
            if (typeof options === 'undefined') {
                options = {};
            }
            // Configuring dialog
            $dialog.find('.modal-dialog').attr('class', 'modal-dialog').addClass('modal-' + settings.dialogSize);
            $dialog.find('.progress-bar').attr('class', 'progress-bar');
            if (settings.progressType) {
                $dialog.find('.progress-bar').addClass('progress-bar-' + settings.progressType);
            }
            $dialog.find('h3').text(message);
            // Opening dialog
            $dialog.modal();
        },
        /**
         * Closes dialog
         */
        hide: function () {
            $dialog.modal('hide');
        }
    }

})(jQuery);

'use strict';

/**
 * @ngdoc overview
 * @name clientApp
 * @description
 * # clientApp
 *
 * Main module oÆf the application.
 */
var app = angular
    .module('igl', [
        'ngAnimate',
        'LocalStorageModule',
        'ngCookies',
        'ngMessages',
        'ngResource',
        'ngRoute',
        'ngSanitize',
        'ngTouch',
        'ngIdle',
        'ui.bootstrap',
        'smart-table',
        'lrDragNDrop',
        'ngTreetable',
        'restangular',
        'ui.bootstrap.contextMenu',
        'angularjs-dropdown-multiselect',
        'dndLists',
        'froala',
        'ui-notification',
        'ngDragDrop',
        'ui.tree',
        'blockUI',
        'ds.objectDiff',
        'ngTagsInput',
        'nsPopover',
//        'ngMaterial',
        'pageslide-directive',
        'rzModule',
    		'ui.select',
        'flow'
      ]);

var
//the HTTP headers to be used by all requests
    httpHeaders,

//the message to show on the login popup page
    loginMessage,

//the spinner used to show when we are still waiting for a server answer
    spinner,

//The list of messages we don't want to displat
    mToHide = ['usernameNotFound', 'emailNotFound', 'usernameFound', 'emailFound', 'loginSuccess', 'userAdded', 'igDocumentNotSaved', 'igDocumentSaved', 'uploadImageFailed','fullNameNotFound','fullNameFound'];

//the message to be shown to the user
var msg = {};

app.config(function ($routeProvider, RestangularProvider, $httpProvider, KeepaliveProvider, IdleProvider, NotificationProvider,blockUIConfig, flowFactoryProvider) {

    $routeProvider
        .when('/', {
            templateUrl: 'views/home.html'
        })
        .when('/home', {
            templateUrl: 'views/home.html'
        })
        .when('/ig', {
            templateUrl: 'views/ig.html'
        })
        .when('/profileComponent', {
            templateUrl: 'views/profileComponent.html'
        })
        .when('/compare', {
            templateUrl: 'views/compare.html'
        })
        .when('/datatypeLibrary', {
            templateUrl: 'views/datatypeLibrary.html',
            controller: 'DatatypeLibraryCtl'
        })
        .when('/shared', {
             templateUrl: 'views/shared.html',
             controller: 'shared'
         })
        .when('/doc', {
            templateUrl: 'views/doc.html'
        })
        .when('/setting', {
            templateUrl: 'views/setting.html'
        })
        .when('/about', {
            templateUrl: 'views/about.html'
        })
        .when('/contact', {
            templateUrl: 'views/contact.html'
        })
        .when('/forgotten', {
            templateUrl: 'views/account/forgotten.html',
            controller: 'ForgottenCtrl'
        })
        .when('/issue', {
            templateUrl: 'views/issue.html',
            controller: 'IssueCtrl'
        })
        .when('/registration', {
            templateUrl: 'views/account/registration.html',
            controller: 'RegistrationCtrl'
        }).when('/useraccount', {
            templateUrl: 'views/account/userAccount.html'
        }) .when('/glossary', {
            templateUrl: 'views/glossary.html'
        })
//        .when('/account', {
//            templateUrl: 'views/account/account.html',
//            controller: 'AccountCtrl',
//            resolve: {
//                login: ['LoginService', function(LoginService){
//                    return LoginService();
//                }]
//            }
//        })
        .when('/registerResetPassword', {
            templateUrl: 'views/account/registerResetPassword.html',
            controller: 'RegisterResetPasswordCtrl',
            resolve: {
                isFirstSetup: function () {
                    return true;
                }
            }
        })
        .when('/resetPassword', {
            templateUrl: 'views/account/registerResetPassword.html',
            controller: 'RegisterResetPasswordCtrl',
            resolve: {
                isFirstSetup: function () {
                    return false;
                }
            }
        })
        .when('/registrationSubmitted', {
            templateUrl: 'views/account/registrationSubmitted.html'
        })
        .otherwise({
            redirectTo: '/'
        });


//    $http.defaults.headers.post['X-CSRFToken'] = $cookies['csrftoken'];

    $httpProvider.interceptors.push(function ($q) {
        return {
            request: function (config) {
//            	console.log(config.url);
//                return "http://localhost:8080/igamt"+ value;
//                if(config.url.startsWith("api")){
//                   config.url = "http://localhost:8080/igamt/"+  config.url;
//                   console.log("config.url=" + config.url);
//                }
                return config || $q.when(config);
            }
        }
    });


    $httpProvider.interceptors.push(function ($rootScope, $q) {
        var setMessage = function (response) {
            //if the response has a text and a type property, it is a message to be shown
            if (response.data && response.data.text && response.data.type) {
                if (response.status === 401) {
//                        console.log("setting login message");
                    loginMessage = {
                        text: response.data.text,
                        type: response.data.type,
                        skip: response.data.skip,
                        show: true,
                        manualHandle: response.data.manualHandle
                    };

                } else if (response.status === 503) {
                    msg = {
                        text: "server.down",
                        type: "danger",
                        show: true,
                        manualHandle: true
                    };
                } else {
                    msg = {
                        text: response.data.text,
                        type: response.data.type,
                        skip: response.data.skip,
                        show: true,
                        manualHandle: response.data.manualHandle
                    };
                    var found = false;
                    var i = 0;
                    while (i < mToHide.length && !found) {
                        if (msg.text === mToHide[i]) {
                            found = true;
                        }
                        i++;
                    }
                    if (found === true) {
                        msg.show = false;
                    } else {
//                        //hide the msg in 5 seconds
//                                                setTimeout(
//                                                    function() {
//                                                        msg.show = false;
//                                                        //tell angular to refresh
//                                                        $rootScope.$apply();
//                                                    },
//                                                    10000
//                                                );
                    }
                 }
            }
        };

        return {
            response: function (response) {
                setMessage(response);
                return response || $q.when(response);
            },

            responseError: function (response) {
                setMessage(response);
                return $q.reject(response);
            }
        };

    });

    //configure $http to show a login dialog whenever a 401 unauthorized response arrives
    $httpProvider.interceptors.push(function ($rootScope, $q) {
        return {
            response: function (response) {
                return response || $q.when(response);
            },
            responseError: function (response) {
                if (response.status === 401) {
                    //We catch everything but this one. So public users are not bothered
                    //with a login windows when browsing home.
                    if (response.config.url !== 'api/accounts/cuser') {
                        //We don't intercept this request
                        if (response.config.url !== 'api/accounts/login') {
                            var deferred = $q.defer(),
                                req = {
                                    config: response.config,
                                    deferred: deferred
                                };
                            $rootScope.requests401.push(req);
                        }
                        $rootScope.$broadcast('event:loginRequired');
//                        return deferred.promise;

                        return  $q.when(response);
                    }
                }
                return $q.reject(response);
            }
        };
    });

    //intercepts ALL angular ajax http calls
    $httpProvider.interceptors.push(function ($q) {
        return {
            response: function (response) {
                //hide the spinner
                spinner = false;
                return response || $q.when(response);
            },
            responseError: function (response) {
                //hide the spinner
                spinner = false;
                return $q.reject(response);
            }
        };


    });


    IdleProvider.idle(7200);
    IdleProvider.timeout(30);
    KeepaliveProvider.interval(60);


    NotificationProvider.setOptions({
        delay: 30000,
        maxCount:1
    });



    var spinnerStarter = function (data, headersGetter) {
        spinner = true;
        return data;
    };

    blockUIConfig.message = 'Please wait...';
    blockUIConfig.blockBrowserNavigation = true;


    $httpProvider.defaults.transformRequest.push(spinnerStarter);

    httpHeaders = $httpProvider.defaults.headers;

    flowFactoryProvider.defaults = {
      target: 'api/uploaded_files/upload',
      permanentErrors: [404, 500, 501],
      maxChunkRetries: 1,
      chunkRetryInterval: 5000,
      simultaneousUploads: 4,
      singleFile: true,
      testChunks:false
    };


});


app.run(function ($rootScope, $location, Restangular, $modal, $filter, base64, userInfoService, $http, AppInfo, StorageService, $templateCache, $window, Notification) {
    $rootScope.appInfo = {};
    //Check if the login dialog is already displayed.
    $rootScope.loginDialogShown = false;
    $rootScope.subActivePath = null;

    // load app info
    AppInfo.get().then(function (appInfo) {
        $rootScope.appInfo = appInfo;
        $rootScope.froalaEditorOptions = {
            placeholderText: '',
//            toolbarButtons: ['fullscreen', 'bold', 'italic', 'underline', 'strikeThrough', 'subscript', 'superscript', 'fontFamily', 'fontSize', '|', 'color', 'emoticons', 'inlineStyle', 'paragraphStyle', '|', 'paragraphFormat', 'align', 'formatOL', 'formatUL', 'outdent', 'indent', 'quote', 'insertHR', '-', 'undo', 'redo', 'clearFormatting', 'selectAll', 'insertTable', 'insertLink', 'insertImage', 'insertFile'],
            imageUploadURL: $rootScope.appInfo.uploadedImagesUrl + "/upload",
            imageAllowedTypes: ['jpeg', 'jpg', 'png', 'gif'],
            fileUploadURL: $rootScope.appInfo.uploadedImagesUrl + "/upload",
            fileAllowedTypes: ['application/pdf', 'application/msword', 'application/x-pdf', 'text/plain', 'application/xml','text/xml'],
            charCounterCount: false,
            quickInsertTags: 8,
            heightMin:250,
            immediateAngularModelUpdate:true,
            events: {
                'froalaEditor.initialized': function () {

                },
                'froalaEditor.file.error': function(e, editor, error){
                    $rootScope.msg().text= error.text;
                    $rootScope.msg().type= error.type;
                    $rootScope.msg().show= true;
                 },
                'froalaEditor.image.error ':function(e, editor, error){
                    $rootScope.msg().text= error.text;
                    $rootScope.msg().type= error.type;
                    $rootScope.msg().show= true;
                }
            },
            key: 'Rg1Wb2KYd1Td1WIh1CVc2F==',
            imageResize: true,
            imageEditButtons: ['imageReplace', 'imageAlign', 'imageRemove', '|', 'imageLink', 'linkOpen', 'linkEdit', 'linkRemove', '-', 'imageAlt'],
            pastePlain: true
        };
        httpHeaders.common['appVersion'] = appInfo.version;
        var prevVersion = StorageService.getAppVersion(StorageService.APP_VERSION);
        StorageService.setAppVersion(appInfo.version);

        if (prevVersion == null || prevVersion !== appInfo.version) {
            $rootScope.clearAndReloadApp();
        }
    }, function (error) {
        $rootScope.appInfo = {};
        $rootScope.openErrorDlg("Sorry we could not communicate with the server. Please try again");
    });


    //make current message accessible to root scope and therefore all scopes
    $rootScope.msg = function () {
        return msg;
    };

    //make current loginMessage accessible to root scope and therefore all scopes
    $rootScope.loginMessage = function () {
//            console.log("calling loginMessage()");
        return loginMessage;
    };

    //showSpinner can be referenced from the view
    $rootScope.showSpinner = function () {
        return spinner;
    };

    /**
     * Holds all the requests which failed due to 401 response.
     */
    $rootScope.requests401 = [];

    $rootScope.$on('event:loginRequired', function () {
//            console.log("in loginRequired event");
        $rootScope.showLoginDialog();
    });

    /**
     * On 'event:loginConfirmed', resend all the 401 requests.
     */
    $rootScope.$on('event:loginConfirmed', function () {
//    	console.log("event:loginConfirmed 0");
        var i,
            requests = $rootScope.requests401,
            retry = function (req) {
                $http(req.config).then(function (response) {
                    req.deferred.resolve(response);
                });
            };

        for (i = 0; i < requests.length; i += 1) {
            retry(requests[i]);
        }
        $rootScope.requests401 = [];
//console.log("event:loginConfirmed 1");
        if($location.path() === '/compare'){
            $location.url('/compare');
        }else if($location.path() === '/datatypeLibrary'){
            $location.url('/datatypeLibrary');
        }else {
            $location.url('/ig');
        }
    });

    /*jshint sub: true */
    /**
     * On 'event:loginRequest' send credentials to the server.
     */
    $rootScope.$on('event:loginRequest', function (event, username, password) {
//       	console.log("event:loginRequest 0");
       httpHeaders.common['Accept'] = 'application/json';
        httpHeaders.common['Authorization'] = 'Basic ' + base64.encode(username + ':' + password);
//        httpHeaders.common['withCredentials']=true;
//        httpHeaders.common['Origin']="http://localhost:9000";
        $http.get('api/accounts/login').success(function () {
            //If we are here in this callback, login was successfull
            //Let's get user info now
            httpHeaders.common['Authorization'] = null;
            $http.get('api/accounts/cuser').then(function (result) {
                if (result.data && result.data != null) {
                    var rs = angular.fromJson(result.data);
                    userInfoService.setCurrentUser(rs);
                    $rootScope.$broadcast('event:loginConfirmed');
                } else {
                    userInfoService.setCurrentUser(null);
                }
            }, function () {
                userInfoService.setCurrentUser(null);
            });
        });
//       	console.log("event:loginRequest 1");
    });

    /**
     * On 'logoutRequest' invoke logout on the server.
     */
    $rootScope.$on('event:logoutRequest', function () {
        httpHeaders.common['Authorization'] = null;
        userInfoService.setCurrentUser(null);
        $http.get('j_spring_security_logout');
    });

    /**
     * On 'loginCancel' clears the Authentication header
     */
    $rootScope.$on('event:loginCancel', function () {
        httpHeaders.common['Authorization'] = null;
    });

    $rootScope.$on('$routeChangeStart', function (next, current) {
//            console.log('route changing');
        // If there is a message while change Route the stop showing the message
        if (msg && msg.manualHandle === 'false') {
//                console.log('detected msg with text: ' + msg.text);
            msg.show = false;
        }
    });

    $rootScope.$watch(function(){
        return $rootScope.msg().text;
    }, function (value) {
        $rootScope.showNotification($rootScope.msg());
    });

    $rootScope.$watch('language()', function (value) {
        $rootScope.showNotification($rootScope.msg());
    });

    $rootScope.loadUserFromCookie = function () {
        if (userInfoService.hasCookieInfo() === true) {
            //console.log("found cookie!")
            userInfoService.loadFromCookie();
            httpHeaders.common['Authorization'] = userInfoService.getHthd();
        }
        else {
            //console.log("cookie not found");
        }
    };


    $rootScope.isSubActive = function (path) {
        return path === $rootScope.subActivePath;
    };

    $rootScope.setSubActive = function (path) {
        $rootScope.subActivePath = path;
    };

    $rootScope.getFullName = function () {
        if (userInfoService.isAuthenticated() === true) {
            return userInfoService.getFullName();
        }
        return '';
    };
    $rootScope.clearAndReloadApp = function () {
        $rootScope.clearTemplate();
        $rootScope.reloadPage();
    };

    $rootScope.openErrorDlg = function (errorMessage) {
        StorageService.clearAll();
        if (!$rootScope.errorModalInstance || $rootScope.errorModalInstance === null || !$rootScope.errorModalInstance.opened) {
            $rootScope.errorModalInstance = $modal.open({
                templateUrl: 'CriticalError.html',
                size: 'lg',
                backdrop: true,
                keyboard: 'true',
                'controller': 'FailureCtrl',
                resolve: {
                    error: function () {
                        return errorMessage;
                    }
                }
            });
            $rootScope.errorModalInstance.result.then(function () {
                $rootScope.clearAndReloadApp();
            }, function () {
                $rootScope.clearAndReloadApp();
            });
        }
    };

    $rootScope.openSessionExpiredDlg = function () {
        if (!$rootScope.sessionExpiredModalInstance || $rootScope.sessionExpiredModalInstance === null || !$rootScope.sessionExpiredModalInstance.opened) {
            $rootScope.sessionExpiredModalInstance = $modal.open({
                templateUrl: 'timedout-dialog.html',
                size: 'lg',
                backdrop: true,
                keyboard: 'true',
                'controller': 'FailureCtrl',
                resolve: {
                    error: function () {
                        return "";
                    }
                }
            });
            $rootScope.sessionExpiredModalInstance.result.then(function () {
                $rootScope.clearAndReloadApp();
            }, function () {
                $rootScope.clearAndReloadApp();
            });
        }
    };

    $rootScope.clearTemplate = function () {
        $templateCache.removeAll();
    };

    $rootScope.reloadPage = function () {
        $window.location.reload();
    };

    $rootScope.showNotification = function (m) {
        if(m != undefined && m.show && m.text != null) {
            var msg = angular.copy(m);
            var message = $.i18n.prop(msg.text);
            var type = msg.type;
            if (type === "danger") {
                Notification.error({message: message, templateUrl: "NotificationErrorTemplate.html", scope: $rootScope, delay:10000});
            } else if (type === 'warning') {
                Notification.warning({message: message, templateUrl: "NotificationWarningTemplate.html", scope: $rootScope, delay:5000});
            } else if (type === 'success') {
                Notification.success({message: message, templateUrl: "NotificationSuccessTemplate.html", scope: $rootScope, delay:5000});
            }
            //reset
            m.text = null;
            m.type = null;
            m.show = false;
        }
    };

    $rootScope.scrollbarWidth = 0;

    $rootScope.getScrollbarWidth = function () {
        if ($rootScope.scrollbarWidth == 0) {
            var outer = document.createElement("div");
            outer.style.visibility = "hidden";
            outer.style.width = "100px";
            outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

            document.body.appendChild(outer);

            var widthNoScroll = outer.offsetWidth;
            // force scrollbars
            outer.style.overflow = "scroll";

            // add innerdiv
            var inner = document.createElement("div");
            inner.style.width = "100%";
            outer.appendChild(inner);

            var widthWithScroll = inner.offsetWidth;

            // remove divs
            outer.parentNode.removeChild(outer);

            $rootScope.scrollbarWidth = widthNoScroll - widthWithScroll;
        }

        return $rootScope.scrollbarWidth;
    };





});

'use strict';

angular.module('igl').factory('userInfo', ['$resource',
    function ($resource) {
        return $resource('api/accounts/cuser');
    }
]);

angular.module('igl').factory('userLoaderService', ['userInfo', '$q',
    function (userInfo, $q) {
        var load = function() {
            var delay = $q.defer();
            userInfo.get({},
                function(theUserInfo) {
                    delay.resolve(theUserInfo);
                },
                function() {
                    delay.reject('Unable to fetch user info');
                }
            );
            return delay.promise;
        };
        return {
            load: load
        };
    }
]);

angular.module('igl').factory('userInfoService', ['StorageService', 'userLoaderService',
    function(StorageService,userLoaderService) {
        var currentUser = null;
        var supervisor = false,
        author = false,
        admin = false,
        id = null,
        username = '',
        fullName= '';

        //console.log("USER ID=", StorageService.get('userID'));
       
        var loadFromCookie = function() {
            //console.log("UserID=", StorageService.get('userID'));

            id = StorageService.get('userID');
            username = StorageService.get('username');
            author = StorageService.get('author');
            supervisor = StorageService.get('supervisor');
            admin = StorageService.get('admin');
        };

        var saveToCookie = function() {
            StorageService.set('accountID', id);
            StorageService.set('username', username);
            StorageService.set('author', author);
            StorageService.set('supervisor', supervisor);
            StorageService.set('admin', admin);
            StorageService.set('fullName', fullName);
        };

        var clearCookie = function() {
            StorageService.remove('accountID');
            StorageService.remove('username');
            StorageService.remove('author');
            StorageService.remove('supervisor');
            StorageService.remove('admin');
            StorageService.remove('hthd');
            StorageService.remove('fullName');

        };

        var saveHthd = function(header) {
            StorageService.set('hthd', header);
        };

        var getHthd = function(header) {
            return StorageService.get('hthd');
        };

        var hasCookieInfo =  function() {
            if ( StorageService.get('username') === '' ) {
                return false;
            }
            else {
                return true;
            }
        };

        var getAccountID = function() {
            if ( isAuthenticated() ) {
                return currentUser.accountId.toString();
            }
            return '0';
        };

        var isAdmin = function() {
            return admin;
        };

        var isAuthor = function() {
            return author;
        };

//        var isAuthorizedVendor = function() {
//            return authorizedVendor;
//        };
//
//        var isCustomer = function() {
//            return (author || authorizedVendor);
//        };

        var isSupervisor = function() {
            return supervisor;
        };

        var isPending = function() {
            return isAuthenticated() && currentUser != null ? currentUser.pending: false;
        };

        var isAuthenticated = function() {
        	var res =  currentUser !== undefined && currentUser != null && currentUser.authenticated === true;
             return res;
        };

        var loadFromServer = function() {
            if ( !isAuthenticated() ) {
                userLoaderService.load().then(setCurrentUser);
            }
        };

        var setCurrentUser = function(newUser) {
            currentUser = newUser;
            if ( currentUser !== null && currentUser !== undefined ) {
                username = currentUser.username;
                id = currentUser.accountId;
                fullName = currentUser.fullName;
                if ( angular.isArray(currentUser.authorities)) {
                    angular.forEach(currentUser.authorities, function(value, key){
                        switch(value.authority)
                        {
                        case 'user':
                             break;
                        case 'admin':
                            admin = true;
                             break;
                        case 'author':
                            author = true;
                             break;
                        case 'supervisor':
                            supervisor = true;
                             break;
                        default:
                         }
                    });
                }
                //saveToCookie();
            }
            else {
                supervisor = false;
                author = false;
                admin = false;
                username = '';
                id = null;
                fullName = '';
                //clearCookie();
            }
        };

        var getUsername = function() {
            return username;
        };

        var getFullName = function() {
            return fullName;
        };

        return {
            saveHthd: saveHthd,
            getHthd: getHthd,
            hasCookieInfo: hasCookieInfo,
            loadFromCookie: loadFromCookie,
            getAccountID: getAccountID,
            isAdmin: isAdmin,
            isAuthor: isAuthor,
            isAuthenticated: isAuthenticated,
            isPending: isPending,
            isSupervisor: isSupervisor,
            setCurrentUser: setCurrentUser,
            loadFromServer: loadFromServer,
            getUsername: getUsername,
            getFullName: getFullName

        };
    }
]);

'use strict';

angular.module('igl').factory('Account', ['$resource',
    function ($resource) {
        return $resource('api/accounts/:id', {id: '@id'});
    }
]);

angular.module('igl').factory('LoginService', ['$resource', '$q',
    function ($resource, $q) {
        return function() {
            var myRes = $resource('api/accounts/login');
            var delay = $q.defer();
            myRes.get({},
                function(res) {
                    delay.resolve(res);
                }
            );
            return delay.promise;
        };
    }
]);

angular.module('igl').factory('AccountLoader', ['Account', '$q',
    function (Account, $q) {
        return function(acctID) {
            var delay = $q.defer();
            Account.get({id: acctID},
                function(account) {
                    delay.resolve(account);
                },
                function() {
                    delay.reject('Unable to fetch account');
                }
            );
            return delay.promise;
        };
    }
]);

/**
 * Created by haffo on 3/3/16.
 */

angular.module('igl').factory('AppInfo', ['$http', '$q', function ($http, $q) {
    return {
        get: function () {
            var delay = $q.defer();
            $http.get('api/appInfo').then(
                function (object) {
                    delay.resolve(angular.fromJson(object.data));
                },
                function (response) {
                    delay.reject(response.data);
                }
            );
            return delay.promise;
        }
    };
}]);
/**
 * Created by haffo on 3/18/16.
 */
angular.module('igl').factory('AutoSaveService',
    function ($interval, IgDocumentService,$rootScope,StorageService) {
        var AutoSaveService = {
            value: undefined,
            interval: "60000", // every 60s
            start: function () {
                if (angular.isDefined(this.value)) {
                    this.stop();
                }
                this.value = $interval(this.saveDoc, this.interval);
            },
            stop: function () {
                if (angular.isDefined(this.value)) {
                    $interval.cancel(this.value);
                    this.value = undefined;
                }
            },
            saveDoc: function () {
                if ($rootScope.igdocument != null && $rootScope.hasChanges()) {
                    $rootScope.autoSaving = true;
                    $rootScope.saved = false;
                    $rootScope.clearChanges();
                    IgDocumentService.save($rootScope.igdocument).then(function(){
                        $rootScope.autoSaving = false;
                        $rootScope.saved = true;
                        StorageService.setIgDocument($rootScope.igdocument);
                        $rootScope.msg().text = null;
                        $rootScope.msg().type =null;
                        $rootScope.msg().show = false;
                    },function(){
                        $rootScope.autoSaving = false;
                        $rootScope.saved = false;
                        $rootScope.msg().text = null;
                        $rootScope.msg().type =null;
                        $rootScope.msg().show = false;
                    });
                }
            }
        };
        return AutoSaveService;
    });


angular.module('igl').factory(
    'CloneDeleteSvc',

    function ($rootScope, $modal, ProfileAccessSvc, $cookies, IgDocumentService, MessageService, SegmentLibrarySvc, SegmentService, DatatypeService, DatatypeLibrarySvc, TableLibrarySvc, TableService, MastermapSvc, SectionSvc, FilteringSvc,VersionAndUseService) {

        var svc = this;
        svc.copySection = function (section) {
            var newSection = angular.copy(section.reference);
            newSection.id = new ObjectId();
            var rand = Math.floor(Math.random() * 100);
            if (!$rootScope.igdocument.profile.metaData.ext) {
                $rootScope.igdocument.profile.metaData.ext = "";
            }
            newSection.sectionTitle = section.reference.sectionTitle + "-"
                + $rootScope.igdocument.profile.metaData.ext + "-"
                + rand;
            newSection.label = newSection.sectionTitle;
            section.parent.childSections.splice(0, 0, newSection);
            section.parent.childSections = positionElements(section.parent.childSections);
            $rootScope.$broadcast('event:openSection', newSection);
        }

        svc.copySegment = function (segment) {
            var newSegment = angular.copy(segment);
            newSegment.shareParticipantIds = [];
            newSegment.scope = 'USER';
            newSegment.id = null;
            newSegment.libIds = [];
            newSegment.libIds.push($rootScope.igdocument.profile.segmentLibrary.id);
            newSegment.ext = $rootScope.createNewExtension(newSegment.ext);

            if (newSegment.fields != undefined && newSegment.fields != null && newSegment.fields.length != 0) {
                for (var i = 0; i < newSegment.fields.length; i++) {
                    newSegment.fields[i].id = new ObjectId().toString();
                }
            }


            var dynamicMappings = newSegment['dynamicMappings'];
            if (dynamicMappings != undefined && dynamicMappings != null && dynamicMappings.length != 0) {
                angular.forEach(dynamicMappings, function (dynamicMapping) {
                    dynamicMapping.id = new ObjectId().toString();
                    angular.forEach(dynamicMapping.mappings, function (mapping) {
                        mapping.id = new ObjectId().toString();
                    });
                });
            }

            SegmentService.save(newSegment).then(function (result) {
                newSegment = result;
                var newLink = angular.copy(SegmentLibrarySvc.findOneChild(segment.id, $rootScope.igdocument.profile.segmentLibrary.children));
                newLink.ext = newSegment.ext;
                newLink.id = newSegment.id;

                SegmentLibrarySvc.addChild($rootScope.igdocument.profile.segmentLibrary.id, newLink).then(function (link) {
                    $rootScope.igdocument.profile.segmentLibrary.children.splice(0, 0, newLink);
                    $rootScope.segments.splice(0, 0, newSegment);
                    $rootScope.segment = newSegment;
                    $rootScope.segmentsMap[newSegment.id] = newSegment;
                    //TODO MasterMap need to add Segment
                    $rootScope.processElement(newSegment);
//                	MastermapSvc.addSegmentObject(newSegment, [[$rootScope.igdocument.id, "ig"], [$rootScope.igdocument.profile.id, "profile"]]);
                    $rootScope.filteredSegmentsList.push(newSegment);
                    $rootScope.filteredSegmentsList = _.uniq($rootScope.filteredSegmentsList);
                    $rootScope.$broadcast('event:openSegment', newSegment);
                }, function (error) {
                    $rootScope.saving = false;
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
            }, function (error) {
                $rootScope.saving = false;
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        };

        svc.copyDatatype = function (datatype) {
            var newDatatype = angular.copy(datatype, {});
            if($rootScope.igdocument){
            	newDatatype.ext = $rootScope.createNewExtension(newDatatype.ext);

            }else{
            	newDatatype.ext = newDatatype.ext+(Math.floor(Math.random() * 100) + 1);
            }
            newDatatype.scope = $rootScope.datatypeLibrary.scope;
            newDatatype.status='UNPUBLISHED';
            if(datatype.publicationVersion){
                newDatatype.publicationVersion=0;
            }
            newDatatype.shareParticipantIds = [];
            newDatatype.id = null;
            newDatatype.libIds = [];
            newDatatype.libIds.push($rootScope.datatypeLibrary.id);
            if(datatype.scope==='MASTER' && $rootScope.igdocument){
            	//newDatatype.hl7versions=[$rootScope.igdocument.profile.metaData.hl7Version];
            	var temp=[];
            	temp.push($rootScope.igdocument.profile.metaData.hl7Version);
            	newDatatype.hl7versions=temp;
            	newDatatype.hl7Version=$rootScope.igdocument.profile.metaData.hl7Version;
            	
            }


            if (newDatatype.components != undefined && newDatatype.components != null && newDatatype.components.length != 0) {
                for (var i = 0; i < newDatatype.components.length; i++) {
                    newDatatype.components[i].id = new ObjectId().toString();
                }
            }

            var predicates = newDatatype['predicates'];
            if (predicates != undefined && predicates != null && predicates.length != 0) {
                angular.forEach(predicates, function (predicate) {
                    predicate.id = new ObjectId().toString();
                });
            }

            var conformanceStatements = newDatatype['conformanceStatements'];
            if (conformanceStatements != undefined && conformanceStatements != null && conformanceStatements.length != 0) {
                angular.forEach(conformanceStatements, function (conformanceStatement) {
                    conformanceStatement.id = new ObjectId().toString();
                });
            }

            DatatypeService.save(newDatatype).then(function (result) {
                newDatatype = result;
                var newLink = {};
                newLink.id = newDatatype.id;
                newLink.ext = newDatatype.ext;
                newLink.name=newDatatype.name;
                DatatypeLibrarySvc.addChild($rootScope.datatypeLibrary.id, newLink).then(function (link) {
                    $rootScope.datatypeLibrary.children.splice(0, 0, newLink);
                    $rootScope.datatypes.splice(0, 0, newDatatype);
                    $rootScope.datatype = newDatatype;
                    $rootScope.datatypesMap[newDatatype.id] = newDatatype;

                    //TODO MasterMap need to add Datatype
                    
                    $rootScope.processElement(newDatatype);
//                    MastermapSvc.addDatatypeObject(newDatatype, [[$rootScope.igdocument.profile.id, "profile"], [$rootScope.igdocument.id, "ig"]]);
                    $rootScope.filteredDatatypesList.push(newDatatype);
                    $rootScope.filteredDatatypesList = _.uniq($rootScope.filteredDatatypesList);
                    $rootScope.Activate(newDatatype.id);
                    if($rootScope.igdocument){
                    	  $rootScope.$broadcast('event:openDatatype',  $rootScope.datatypesMap[newDatatype.id]);
                    }else{
                    	 $rootScope.$broadcast('event:openDatatypeInLib',  $rootScope.datatypesMap[newDatatype.id]);
                    }
                
                  
                    
                }, function (error) {
                    $rootScope.saving = false;
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
            }, function (error) {
                $rootScope.saving = false;
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });

        };
        svc.upgradeDatatype= function(datatype){
        	console.log("NEW VERSION");
            var newDatatype = angular.copy(datatype, {});
            newDatatype.scope = $rootScope.datatypeLibrary.scope;
            newDatatype.status='UNPUBLISHED';
            newDatatype.shareParticipantIds = [];
            newDatatype.id=new ObjectId().toString()
            var datatypeInfo= {};
            datatypeInfo.id=newDatatype.id;
            datatypeInfo.sourceId=datatype.id;
            newDatatype.publicationVersion=0;
            datatypeInfo.derived=[];
            datatypeInfo.ancestors=[];
            
           console.log(datatype.id);
            VersionAndUseService.findById(datatype.id).then(function(inf){
            	console.log("Returning ================================");
            	console.log(inf);
            	var ancestors=inf.ancestors;
            	ancestors.push(datatype.id);
            	datatypeInfo.ancestors=ancestors;
            	console.log(datatypeInfo.ancestors);
            	datatypeInfo.publicationVersion=inf.publicationVersion;
            	
            	 VersionAndUseService.save(datatypeInfo).then(function(result){
                 	$rootScope.versionAndUseMap[result.id]=result;
        
                 	angular.forEach(result.ancestors,function(ancestor){
                 		VersionAndUseService.findById(ancestor).then(function(inf){
                         	var derived = inf.derived;
                         	derived.push(result.id);
                         	inf.derived=derived;
                         	console.log(result);
                         
                         	VersionAndUseService.save(inf).then(function(res2){
                         	 	$rootScope.versionAndUseMap[res2.id]=res2;
                 		});
                 	});

                  	
                  });
                 	
                 });
            	 
          });

            newDatatype.libIds = [];
            newDatatype.libIds.push($rootScope.datatypeLibrary.id);
            if(datatype.scope==='MASTER' && $rootScope.igdocument){
            	//newDatatype.hl7versions=[$rootScope.igdocument.profile.metaData.hl7Version];
            	var temp=[];
            	temp.push($rootScope.igdocument.profile.metaData.hl7Version);
            	newDatatype.hl7versions=temp;
            	newDatatype.hl7Version=$rootScope.igdocument.profile.metaData.hl7Version;
            	
            }


            if (newDatatype.components != undefined && newDatatype.components != null && newDatatype.components.length != 0) {
                for (var i = 0; i < newDatatype.components.length; i++) {
                    newDatatype.components[i].id = new ObjectId().toString();
                }
            }

            var predicates = newDatatype['predicates'];
            if (predicates != undefined && predicates != null && predicates.length != 0) {
                angular.forEach(predicates, function (predicate) {
                    predicate.id = new ObjectId().toString();
                });
            }

            var conformanceStatements = newDatatype['conformanceStatements'];
            if (conformanceStatements != undefined && conformanceStatements != null && conformanceStatements.length != 0) {
                angular.forEach(conformanceStatements, function (conformanceStatement) {
                    conformanceStatement.id = new ObjectId().toString();
                });
            }

            DatatypeService.save(newDatatype).then(function (result) {
                newDatatype = result;
                var newLink = angular.copy(DatatypeLibrarySvc.findOneChild(datatype.id, $rootScope.datatypeLibrary.children));
                newLink.id = newDatatype.id;
                newLink.ext = newDatatype.ext;
                DatatypeLibrarySvc.addChild($rootScope.datatypeLibrary.id, newLink).then(function (link) {
                    $rootScope.datatypeLibrary.children.splice(0, 0, newLink);
                    $rootScope.datatypes.splice(0, 0, newDatatype);
                    $rootScope.datatype = newDatatype;
                    $rootScope.datatypesMap[newDatatype.id] = newDatatype;

                    //TODO MasterMap need to add Datatype

                    $rootScope.processElement(newDatatype);
//                    MastermapSvc.addDatatypeObject(newDatatype, [[$rootScope.igdocument.profile.id, "profile"], [$rootScope.igdocument.id, "ig"]]);
                    $rootScope.filteredDatatypesList.push(newDatatype);
                    $rootScope.filteredDatatypesList = _.uniq($rootScope.filteredDatatypesList);
                    $rootScope.Activate(newDatatype.id);
                    if($rootScope.igdocument){
                  	  $rootScope.$broadcast('event:openDatatype',  $rootScope.datatypesMap[newDatatype.id]);
                  }else{
                  	 $rootScope.$broadcast('event:openDatatypeInLib',  $rootScope.datatypesMap[newDatatype.id]);
                  }
      
                }, function (error) {
                    $rootScope.saving = false;
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
            }, function (error) {
                $rootScope.saving = false;
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });

        };

        svc.createNewTable = function (scope, tableLibrary) {
            var newTable = {};
            newTable.shareParticipantIds = [];
            newTable.scope = tableLibrary.scope;
            newTable.id = null;
            newTable.libIds = [];
            newTable.libIds.push(tableLibrary.id);
            newTable.bindingIdentifier = $rootScope.createNewFlavorName('NewTable');
            newTable.name = "New Table";
            newTable.description = "Description";
            newTable.codes = [];
            newTable.newTable = true;

            TableService.save(newTable).then(function (result) {
                newTable = result;
                console.log(newTable);
                var newLink = {};
                newLink.bindingIdentifier = newTable.bindingIdentifier;
                newLink.id = newTable.id;

                TableLibrarySvc.addChild(tableLibrary.id, newLink).then(function (link) {
                    tableLibrary.children.splice(0, 0, newLink);
                    $rootScope.tables.splice(0, 0, newTable);
                    $rootScope.table = newTable;
                    $rootScope.tablesMap[newTable.id] = newTable;

                    $rootScope.codeSystems = [];

                    if ($rootScope.filteredTablesList && $rootScope.filteredTablesList != null) {
                        $rootScope.filteredTablesList.push(newTable);
                        $rootScope.filteredTablesList = _.uniq($rootScope.filteredTablesList);
                    }
                    $rootScope.$broadcast('event:openTable', newTable);
                }, function (error) {
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });

            }, function (error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        };

        svc.copyTable = function (table) {
            TableService.getOne(table.id).then(function(newTable){
                newTable.shareParticipantIds = [];
                newTable.status="UNPUBLISHED";
                newTable.id = null;
                newTable.libIds = [];
                newTable.libIds.push($rootScope.tableLibrary.id);
                if($rootScope.igdocument){
                    newTable.bindingIdentifier = $rootScope.createNewFlavorName(newTable.bindingIdentifier);
                    newTable.scope = "USER";

                }else{
                    newTable.bindingIdentifier = table.bindingIdentifier+(Math.floor(Math.random() * 1000) + 1);
                    newTable.scope = $rootScope.tableLibrary.scope;
	
                }

                if (newTable.codes != undefined && newTable.codes != null && newTable.codes.length != 0) {
                    for (var i = 0, len1 = newTable.codes.length; i < len1; i++) {
                        newTable.codes[i].id = new ObjectId().toString();
                    }
                }

                TableService.save(newTable).then(function (result) {
                    newTable = result;
                    var newLink = angular.copy(TableLibrarySvc.findOneChild(table.id, $rootScope.tableLibrary.children));
                    newLink.bindingIdentifier = newTable.bindingIdentifier;
                    newLink.id = newTable.id;

                    TableLibrarySvc.addChild($rootScope.tableLibrary.id, newLink).then(function (link) {
                        $rootScope.tableLibrary.children.splice(0, 0, newLink);
                        $rootScope.tables.splice(0, 0, newTable);
                        $rootScope.table = newTable;
                        $rootScope.tablesMap[newTable.id] = newTable;

                        $rootScope.codeSystems = [];

                        for (var i = 0; i < $rootScope.table.codes.length; i++) {
                            if ($rootScope.codeSystems.indexOf($rootScope.table.codes[i].codeSystem) < 0) {
                                if ($rootScope.table.codes[i].codeSystem && $rootScope.table.codes[i].codeSystem !== '') {
                                    $rootScope.codeSystems.push($rootScope.table.codes[i].codeSystem);
                                }
                            }
                        }
                        if ($rootScope.filteredTablesList && $rootScope.filteredTablesList != null) {
                            $rootScope.filteredTablesList.push(newTable);
                            $rootScope.filteredTablesList = _.uniq($rootScope.filteredTablesList);
                        }
                        $rootScope.$broadcast('event:openTable', newTable);

                    }, function (error) {
                        $rootScope.msg().text = error.data.text;
                        $rootScope.msg().type = error.data.type;
                        $rootScope.msg().show = true;
                    });


                }, function (error) {
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });

            }, function(error){
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        };
        
        
        svc.upgradeTable = function (table) {
        		var newTable=angular.copy(table);
                newTable.shareParticipantIds = [];
                newTable.status="UNPUBLISHED";
                newTable.libIds = [];
                newTable.bindingIdentifier = table.bindingIdentifier;
                newTable.id=new ObjectId().toString()
                if (newTable.codes != undefined && newTable.codes != null && newTable.codes.length != 0) {
                    for (var i = 0, len1 = newTable.codes.length; i < len1; i++) {
                        newTable.codes[i].id = new ObjectId().toString();
                    }
                }

                TableService.save(newTable).then(function (result) {
                    newTable = result;
                    var newLink = {};
                    newLink.bindingIdentifier = newTable.bindingIdentifier;
                    newLink.id = newTable.id;

                    TableLibrarySvc.addChild($rootScope.tableLibrary.id, newLink).then(function (link) {
                        $rootScope.tableLibrary.children.splice(0, 0, newLink);
                        $rootScope.tables.splice(0, 0, newTable);
                        $rootScope.table = result;
                        $rootScope.tablesMap[newTable.id] = newTable;
                        var newTableInfo= {};
                        newTableInfo.id=newTable.id;
                        newTableInfo.sourceId=newTable.id;
                        
                        newTableInfo.derived=[];
                        newTableInfo.ancestors=[];
                        
                        VersionAndUseService.findById(table.id).then(function(inf){
                        	console.log("Returning ================================");
                        	console.log(inf);
                        	var ancestors=inf.ancestors;
                        	ancestors.push(table.id);
                        	newTableInfo.ancestors=ancestors;
                        	console.log(newTableInfo.ancestors);
                        	newTableInfo.publicationVersion=inf.publicationVersion;
                        	
                        	 VersionAndUseService.save(newTableInfo).then(function(result){
                             	$rootScope.versionAndUseMap[result.id]=result;
                    
                             	angular.forEach(result.ancestors,function(ancestor){
                             		VersionAndUseService.findById(ancestor).then(function(inf){
                                     	var derived = inf.derived;
                                     	derived.push(result.id);
                                     	inf.derived=derived;
                                     	console.log(result);
                                     
                                     	VersionAndUseService.save(inf).then(function(res2){
                                     	 	$rootScope.versionAndUseMap[res2.id]=res2;
                             		});
                             	});

                              	
                              });
                             	
                             });
                        	 
                      });
                        $rootScope.codeSystems = [];

                        for (var i = 0; i < $rootScope.table.codes.length; i++) {
                            if ($rootScope.codeSystems.indexOf($rootScope.table.codes[i].codeSystem) < 0) {
                                if ($rootScope.table.codes[i].codeSystem && $rootScope.table.codes[i].codeSystem !== '') {
                                    $rootScope.codeSystems.push($rootScope.table.codes[i].codeSystem);
                                }
                            }
                        }
                        if ($rootScope.filteredTablesList && $rootScope.filteredTablesList != null) {
                            $rootScope.filteredTablesList.push(newTable);
                            $rootScope.filteredTablesList = _.uniq($rootScope.filteredTablesList);
                        }
                        $rootScope.$broadcast('event:openTable', newTable);

                    }, function (error) {
                        $rootScope.msg().text = error.data.text;
                        $rootScope.msg().type = error.data.type;
                        $rootScope.msg().show = true;
                    });


                }, function (error) {
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
        };
        
        
        
        

        svc.copyTableINLIB = function (table, tableLibrary) {
        	console.log(tableLibrary);
            var newTable = angular.copy(table);
            newTable.shareParticipantIds = [];
            newTable.scope = tableLibrary.scope;
            newTable.status = "UNPUBLISHED";
            newTable.id = null;
            newTable.libIds = [];
            
            newTable.bindingIdentifier = table.bindingIdentifier+(Math.floor(Math.random() * 100) + 1);

            if (newTable.codes != undefined && newTable.codes != null && newTable.codes.length != 0) {
                for (var i = 0, len1 = newTable.codes.length; i < len1; i++) {
                    newTable.codes[i].id = new ObjectId().toString();
                }
            }

            TableService.save(newTable).then(function (result) {
                newTable = result;
                var newLink = angular.copy(TableLibrarySvc.findOneChild(table.id,tableLibrary.children));
                newLink.bindingIdentifier = newTable.bindingIdentifier;
                newLink.id = newTable.id;

                TableLibrarySvc.addChild(tableLibrary.id, newLink).then(function (link) {
                    tableLibrary.children.splice(0, 0, newLink);
                    $rootScope.tables.splice(0, 0, newTable);
                    $rootScope.table = newTable;
                    $rootScope.tablesMap[newTable.id] = newTable;

                    $rootScope.codeSystems = [];

                    for (var i = 0; i < $rootScope.table.codes.length; i++) {
                        if ($rootScope.codeSystems.indexOf($rootScope.table.codes[i].codeSystem) < 0) {
                            if ($rootScope.table.codes[i].codeSystem && $rootScope.table.codes[i].codeSystem !== '') {
                                $rootScope.codeSystems.push($rootScope.table.codes[i].codeSystem);
                            }
                        }
                    }
//                    if ($rootScope.filteredTablesList && $rootScope.filteredTablesList != null) {
//                        $rootScope.filteredTablesList.push(newTable);
//                        $rootScope.filteredTablesList = _.uniq($rootScope.filteredTablesList);
//                    }
                    $rootScope.$broadcast('event:openTable', newTable);

                }, function (error) {
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });


            }, function (error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        };
        
        
        svc.copyMessage = function (message) {
            var newMessage={};
            var newMessage = angular.copy(message);
            newMessage.id = new ObjectId().toString();
            newMessage.position=$rootScope.igdocument.profile.messages.length+1;
            newMessage.name = $rootScope.createNewFlavorName(message.name);
            var groups = ProfileAccessSvc.Messages().getGroups(newMessage);
            angular.forEach(groups, function (group) {
                group.id = new ObjectId().toString();
            });

            var segRefs = ProfileAccessSvc.Messages().getSegmentRefs(newMessage);
            angular.forEach(segRefs, function (segRef) {
                segRef.id = new ObjectId().toString();
            });

            MessageService.save(newMessage).then(function (result) {
                newMessage = result;
                $rootScope.messagesMap[newMessage.id]=newMessage;
                //MessageService.merge($rootScope.messagesMap[newMessage.id], newMessage);                
                $rootScope.igdocument.profile.messages.children.push(newMessage);
                
                IgDocumentService.save($rootScope.igdocument).then(function (igd) {
                    $rootScope.messages = $rootScope.igdocument.profile.messages;
                    $rootScope.message = newMessage;

                    $rootScope.processElement(newMessage);
                    //TODO Mastermap need to add Message
//                    MastermapSvc.addMessageObject(newMessage, [[$rootScope.igdocument.id, "ig"], [$rootScope.igdocument.profile.id, "profile"]]);
//                    FilteringSvc.addMsgInFilter(newMessage.name, newMessage.id);
                    $rootScope.$broadcast('event:openMessage', newMessage);
                    return newMessage;
                }, function (error) {
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
            }, function (error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });

        };

        svc.deleteValueSet = function (table) {
                 $rootScope.referencesForMenu = [];
                angular.forEach($rootScope.segments, function (segment) {
                    $rootScope.findTableRefsForMenu(table, segment, $rootScope.getSegmentLabel(segment),segment);
                });
                angular.forEach($rootScope.datatypes, function (dt) {
                    $rootScope.findTableRefsForMenu(table, dt, $rootScope.getDatatypeLabel(dt),dt);
                });

                if ($rootScope.referencesForMenu != null && $rootScope.referencesForMenu.length > 0) {
                    abortValueSetDelete(table);
                } else {
                    confirmValueSetDelete(table);
                }
         }


        svc.exportDisplayXML = function (messageID) {
            var form = document.createElement("form");
            form.action = $rootScope.api('api/igdocuments/' + $rootScope.igdocument.id + '/export/Display/' + messageID);
            form.method = "POST";
            form.target = "_target";
            var csrfInput = document.createElement("input");
            csrfInput.name = "X-XSRF-TOKEN";
            csrfInput.value = $cookies['XSRF-TOKEN'];
            form.appendChild(csrfInput);
            form.style.display = 'none';
            document.body.appendChild(form);
            form.submit();
        }

        function abortValueSetDelete(table) {
            var modalInstance = $modal.open({
                templateUrl: 'ValueSetReferencesCtrl.html',
                controller: 'ValueSetReferencesCtrl',
                resolve: {
                    tableToDelete: function () {
                        return table;
                    }
                }
            });
            modalInstance.result.then(function (table) {
                // $rootScope.tableToDelete = table;
            }, function () {
            });
        };

        function confirmValueSetDelete(table) {
            var modalInstance = $modal.open({
                templateUrl: 'ConfirmValueSetDeleteCtrl.html',
                controller: 'ConfirmValueSetDeleteCtrl',
                resolve: {
                    tableToDelete: function () {
                        return table;
                    }
                }
            });
            modalInstance.result.then(function (table) {
//                tableToDelete = table;
                if (table.id === $rootScope.activeModel) {
                    $rootScope.displayNullView();
                }
                if($rootScope.filteredTablesList && $rootScope.filteredTablesList != null) {
                    var index = $rootScope.filteredTablesList.indexOf(table);
                    if(index >= 0)
                    $rootScope.filteredTablesList.splice(index, 1);
                }

            }, function () {
            });
        };

        function confirmMessageDelete(message) {
            var modalInstance = $modal.open({
                templateUrl: 'ConfirmMessageDeleteCtrl.html',
                controller: 'ConfirmMessageDeleteCtrl',
                resolve: {
                    messageToDelete: function () {
                        return message;
                    }
                }
            });
            modalInstance.result.then(function (message) {
            }, function () {
            });
        };

        function deleteValueSets(vssIdsSincerelyDead) {
            return ProfileAccessSvc.ValueSets().removeDead(vssIdsSincerelyDead);
        }

        svc.deleteDatatype = function (datatype) {
            $rootScope.referencesForMenu = [];
            angular.forEach($rootScope.segments, function (segment) {
                if(segment && segment != null) {
                    $rootScope.findDatatypeRefsForMenu(datatype, segment, $rootScope.getSegmentLabel(segment),segment);
                }
            });
            angular.forEach($rootScope.datatypes, function (dt) {
                if (dt && dt != null && dt.id !== datatype.id) $rootScope.findDatatypeRefsForMenu(datatype, dt, $rootScope.getDatatypeLabel(dt),dt);
            });
            if ($rootScope.referencesForMenu != null && $rootScope.referencesForMenu.length > 0) {
                abortDatatypeDelete(datatype);
            } else {
                confirmDatatypeDelete(datatype);
            }
        }

        svc.deleteTableAndTableLink = function (table) {
            TableService.delete(table).then(function (result) {
                svc.deleteTableLink(table);
            }, function (error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
            });
        };

        svc.deleteTableLink = function (table) {
            TableLibrarySvc.deleteChild($rootScope.tableLibrary.id, table.id).then(function (res) {
                var index = $rootScope.tables.indexOf(table);
                $rootScope.tables.splice(index, 1);
                var tmp = TableLibrarySvc.findOneChild(table.id, $rootScope.tableLibrary.children);
                index = $rootScope.tableLibrary.children.indexOf(tmp);
                $rootScope.tableLibrary.children.splice(index, 1);
                $rootScope.tablesMap[table.id] = null;
                $rootScope.references = [];
                if ($rootScope.table === table) {
                    $rootScope.table = null;
                }
                $rootScope.msg().text = "tableDeleteSuccess";
                $rootScope.msg().type = "success";
                $rootScope.msg().show = true;
                //TODO MasterMap Need to delete Table
//                MastermapSvc.deleteTable(table.id);
            }, function (error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
            });
        };

        svc.deleteSegmentAndSegmentLink = function (segment) {
            SegmentService.delete(segment).then(function (result) {
                svc.deleteSegmentLink(segment);
            }, function (error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
            });
        };

        svc.deleteSegmentLink = function (segment) {
            SegmentLibrarySvc.deleteChild($rootScope.igdocument.profile.segmentLibrary.id, segment.id).then(function (res) {
                // We must delete from two collections.

                var tmp = SegmentLibrarySvc.findOneChild(segment.id, $rootScope.igdocument.profile.segmentLibrary.children);
                var index = $rootScope.igdocument.profile.segmentLibrary.children.indexOf(tmp);
                $rootScope.igdocument.profile.segmentLibrary.children.splice(index, 1);

                tmp = SegmentLibrarySvc.findOneChild(segment.id, $rootScope.segments);
                index = $rootScope.segments.indexOf(tmp);
                $rootScope.segments.splice(index, 1);
                $rootScope.segmentsMap[segment.id] = null;
                $rootScope.references = [];
                if ($rootScope.segment === segment) {
                    $rootScope.segment = null;
                }

                $rootScope.msg().text = "segDeleteSuccess";
                $rootScope.msg().type = "success";
                $rootScope.msg().show = true;
            }, function (error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
            });
        };


        svc.deleteDatatypeAndDatatypeLink = function (datatype) {
            DatatypeService.delete(datatype).then(function (result) {
                svc.deleteDatatypeLink(datatype);
            }, function (error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
            });
        };

        svc.deleteDatatypeLink = function (datatype) {
            DatatypeLibrarySvc.deleteChild($rootScope.datatypeLibrary.id, datatype.id).then(function (res) {
                var index = $rootScope.datatypes.indexOf(datatype);
                console.log(index);
                if(index>=0){
                    console.log("deleting");
                $rootScope.datatypes.splice(index, 1);
                }
                
                console.log($rootScope.datatypes);
                var tmp = DatatypeLibrarySvc.findOneChild(datatype.id, $rootScope.datatypeLibrary.children);
                index = $rootScope.datatypeLibrary.children.indexOf(tmp);
                $rootScope.datatypeLibrary.children.splice(index, 1);
                $rootScope.datatypesMap[datatype.id] = null;
                $rootScope.references = [];
                if ($rootScope.datatype === datatype) {
                    $rootScope.datatype = null;
                }

                $rootScope.msg().text = "DatatypeDeleteSuccess";
                $rootScope.msg().type = "success";
                $rootScope.msg().show = true;
                //TODO MasterMap need to delete datatype
//                MastermapSvc.deleteDatatype($scope.segToDelete.id);
                //$rootScope.$broadcast('event:SetToC');
            }, function (error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
            });
        };

        function abortDatatypeDelete(datatype) {
            var dtToDelete;
            var modalInstance = $modal.open({
                templateUrl: 'DatatypeReferencesCtrl.html',
                controller: 'DatatypeReferencesCtrl',
                resolve: {
                    dtToDelete: function () {
                        return datatype;
                    }
                }
            });
            modalInstance.result.then(function (datatype) {
                dtToDelete = datatype;
            }, function () {
            });
        };

        function confirmDatatypeDelete(datatype) {
            var dtToDelete;
            var modalInstance = $modal.open({
                templateUrl: 'ConfirmDatatypeDeleteCtrl.html',
                controller: 'ConfirmDatatypeDeleteCtrl',
                resolve: {
                    dtToDelete: function () {
                        return datatype;
                    }
                }
            });
            modalInstance.result.then(function (datatype) {
                if (datatype.id === $rootScope.activeModel) {
                    $rootScope.displayNullView();
                }
                if ($rootScope.filteredDatatypesList && $rootScope.filteredDatatypesList != null) {
                    var index = $rootScope.filteredDatatypesList.indexOf(datatype);
                    if (index >= 0)
                        $rootScope.filteredDatatypesList.splice(index, 1);
                }
                dtToDelete = datatype;
            }, function () {
            });
        };


        function deleteDatatypes(dtIdsLive, dtsIdsSincerelyDead) {

            // Get all value sets that are contained in the sincerely dead datatypes.
            var vssIdsMerelyDead = ProfileAccessSvc.Datatypes().findValueSetsFromDatatypeIds(dtsIdsSincerelyDead);
            // then all value sets that are contained in the live datatypes.
            var vssIdsLive = ProfileAccessSvc.Datatypes().findValueSetsFromDatatypeIds(dtIdsLive);
            var vssIdsSincerelyDead = ProfileAccessSvc.ValueSets().findDead(vssIdsMerelyDead, vssIdsLive);
            deleteValueSets(vssIdsSincerelyDead);

            var rval = ProfileAccessSvc.Datatypes().removeDead(dtsIdsSincerelyDead);

//				console.log("deleteDatatypes: vssIdsMerelyDead=" + vssIdsMerelyDead.length);
//				console.log("deleteDatatypes: vssIdsLive=" + vssIdsLive.length);
//				console.log("deleteDatatypes: vssIdsSincerelyDead=" + vssIdsSincerelyDead.length);

            return rval;
        }

        svc.deleteSegment = function (segment) {
            $rootScope.referencesForMenu = [];
            angular.forEach($rootScope.igdocument.profile.messages.children, function (message) {
                $rootScope.findSegmentRefsForMenu(segment, message, '', '', message);
            });

            if ($rootScope.referencesForMenu != null && $rootScope.referencesForMenu.length > 0) {
                abortSegmentDelete(segment);
            } else {

                confirmSegmentDelete(segment);
            }
        }

        function abortSegmentDelete(segment) {
            var segToDelete;
            var modalInstance = $modal.open({
                templateUrl: 'SegmentReferencesCtrl.html',
                controller: 'SegmentReferencesCtrl',
                resolve: {
                    segToDelete: function () {
                        return segment;
                    }
                }
            });
            modalInstance.result.then(function (segment) {
                segToDelete = segment;
            }, function () {
            });
        };

        function confirmSegmentDelete(segment) {
            var segToDelete;
            var modalInstance = $modal.open({
                templateUrl: 'ConfirmSegmentDeleteCtrl.html',
                controller: 'ConfirmSegmentDeleteCtrl',
                resolve: {
                    segToDelete: function () {
                        return segment;
                    }
                }
            });
            modalInstance.result.then(function (segment) {
                segToDelete = segment;
                if (segment.id === $rootScope.activeModel) {
                    $rootScope.displayNullView();
                }
                if ($rootScope.filteredSegmentsList && $rootScope.filteredSegmentsList != null) {
                    var index = $rootScope.filteredSegmentsList.indexOf(segment);
                    if (index >= 0)
                        $rootScope.filteredSegmentsList.splice(index, 1);
                }

            }, function () {
            });
        };

        function deleteSegments(segmentRefsLive, segmentRefsSincerelyDead) {

            // Get all datatypes that are contained in the sincerely dead segments.
            var dtIdsMerelyDead = ProfileAccessSvc.Segments().findDatatypesFromSegmentRefs(segmentRefsSincerelyDead);

            // then all datatypes that are contained in the live segments.
            var dtIdsLive = ProfileAccessSvc.Segments().findDatatypesFromSegmentRefs(segmentRefsLive);
            var dtsIdsSincerelyDead = ProfileAccessSvc.Datatypes().findDead(dtIdsMerelyDead, dtIdsLive);
            deleteDatatypes(dtIdsLive, dtsIdsSincerelyDead);

            var rval = ProfileAccessSvc.Segments().removeDead(segmentRefsSincerelyDead);

//				console.log("deleteSegments: dtIdsMerelyDead=" + dtIdsMerelyDead.length);
//				console.log("deleteSegments: dtIdsLive=" + dtIdsLive.length);
//				console.log("deleteSegments: dtsIdsSincerelyDead=" + dtsIdsSincerelyDead.length);

            return rval;
        }

        svc.execDeleteMessage = function (message) {

            // We do the delete in pairs: dead and live.  dead = things we are deleting and live = things we are keeping.
            // We are deleting the message so it's dead.
            // The message there is from the ToC so what we need is its reference,
            // and it must be an array of one.
            var msgDead = [message.id];
            // We are keeping the children so their live.
            var msgLive = ProfileAccessSvc.Messages().messages();

            // We remove the dead message from the living.
            var idxP = _.findIndex(msgLive, function (child) {
                return child.id === msgDead[0];
            });

            msgLive.splice(idxP, 1);
            if (0 === ProfileAccessSvc.Messages().messages().length) {
                ProfileAccessSvc.ValueSets().truncate();
                ProfileAccessSvc.Datatypes().truncate();
                ProfileAccessSvc.Segments().truncate();
                return;
            }
            // We get all segment refs that are contained in the dead message.
            var segmentRefsMerelyDead = ProfileAccessSvc.Messages()
                .getAllSegmentRefs(msgDead);
            // We get all segment refs that are contained in the live messages.
            var segmentRefsLive = ProfileAccessSvc.Messages()
                .getAllSegmentRefs(msgLive);
            // Until now, dead meant mearly dead.  We now remove those that are most sincerely dead.
            var segmentRefsSincerelyDead = ProfileAccessSvc.Segments().findDead(segmentRefsMerelyDead, segmentRefsLive);
            if (segmentRefsSincerelyDead.length === 0) {
                return;
            }

            var rval = deleteSegments(segmentRefsLive, segmentRefsSincerelyDead);
            //TODO mastermap need to delete message
//            MastermapSvc.deleteMessage(message.id);
//            FilteringSvc.removeMsgFromFilter(message.id);
            return rval;
        }

        svc.deleteMessage = function (message) {
            confirmMessageDelete(message);
        }

        svc.deleteSection = function (section) {
            SectionSvc.delete($rootScope.igdocument.id, section.reference).then(function (result) {
                var secLive = section.parent.childSections;

                var idxP = _.findIndex(secLive, function (child) {
                    return child.id === section.reference.id;
                });
                section.parent.childSections.splice(idxP, 1);

            }, function (error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
                $rootScope.manualHandle = true;
            });
        }

        svc.findMessageIndex = function (messages, id) {
            var idxT = _.findIndex(messages.children, function (child) {
                return child.reference.id === id;
            })
            return idxT;
        }

        function positionElements(chidren) {
            var sorted = _.sortBy(chidren, "sectionPosition");
            var start = sorted[0].sectionPosition;
            _.each(sorted, function (sortee) {
                sortee.sectionPosition = start++;
            });
            return sorted;
        }

        function sortElementsByAlphabetically(chidren) {
            return _.sortBy(chidren, "name");
        }

        return svc;
    });

/**
 * Created by haffo on 3/9/16.
 */
'use strict';
angular.module('igl').factory('CompareService',
    function($rootScope, ViewSettings, ElementUtils, $q, $http, FilteringSvc, SegmentLibrarySvc, TableLibrarySvc, DatatypeLibrarySvc, ObjectDiff) {
        var CompareService = {

            getNodes: function(parent, root) {
                if (!parent || parent == null) {
                    return root.children;
                } else {
                    return parent.children;
                }
            },
            getTemplate: function(node, root) {
                if (ViewSettings.tableReadonly) {
                    if (node.obj.type === 'segmentRef') {
                        return 'MessageSegmentRefReadTree.html';
                    } else if (node.obj.type === 'group') {
                        return 'MessageGroupReadTree.html';
                    } else if (node.obj.type === 'field') {
                        return 'MessageFieldViewTree.html';
                    } else if (node.obj.type === 'component') {
                        return 'MessageComponentViewTree.html';
                    } else {
                        return 'MessageReadTree.html';
                    }
                } else {

                    if (node.obj.type === 'segmentRef') {
                        return 'MessageSegmentRefEditTree.html';
                    } else if (node.obj.type === 'group') {
                        return 'MessageGroupEditTree.html';
                    } else if (node.obj.type === 'field') {
                        return 'MessageFieldViewTree.html';
                    } else if (node.obj.type === 'component') {
                        return 'MessageComponentViewTree.html';
                    } else {
                        return 'MessageEditTree.html';
                    }
                }
            },
            objToArray: function(object) {
                var result = [];
                $.map(object, function(value, index) {

                    result.push(value);
                });
                return result;

            },
            cmpMessage: function(msg1, msg2, dtList1, dtList2, segList1, segList2) {
                var msg1 = CompareService.fMsg(JSON.parse(msg1), dtList1, segList1);
                var msg2 = CompareService.fMsg(JSON.parse(msg2), dtList2, segList2);
                var diff = ObjectDiff.diffOwnProperties(msg1, msg2);
                var dataList = [];
                if (diff.changed === "object change") {
                    var array = CompareService.objToArray(diff);
                    var arraySeg = CompareService.objToArray(array[1].segments.value);
                    for (var i = 0; i < arraySeg.length; i++) {
                        CompareService.writettTable(arraySeg[i], dataList);
                    }
                }
                console.log("dataList---------------------------------");
                var isEmpty = true;
                var result = [];
                for (var i = 0; i < dataList.length; i++) {
                    console.log("dataList+++++");
                    console.log(dataList[i]);

                    if (!_.isEmpty(dataList[i])) {
                        console.log("inside");
                        console.log(dataList[i]);
                        result.push(dataList[i]);
                        isEmpty = false;
                    }
                }
                if (isEmpty) {
                    console.log("empty");
                    return null;
                } else {
                    console.log("empty");

                    return result;
                }


            },
            cmpSegment: function(segment1, segment2, dtList1, dtList2, segList1, segList2) {
                var seg1 = CompareService.fSegment(JSON.parse(segment1), dtList1, segList1);
                var seg2 = CompareService.fSegment(JSON.parse(segment2), dtList2, segList2);
                //var diff = ObjectDiff.diffOwnProperties(seg1, seg2);
                var diff = ObjectDiff.diff(seg1, seg2);

                console.log(diff);
                var dataList = [];
                if (diff.changed === "object change") {
                    var array = CompareService.objToArray(diff);
                    var arraySeg = CompareService.objToArray(array[1]);
                    CompareService.writettTable(arraySeg[0], dataList);
                }
                console.log(dataList);
                return dataList;
            },
            cmpDatatype: function(datatype1, datatype2, dtList1, dtList2, segList1, segList2) {

                var dt1 = CompareService.fDatatype(JSON.parse(datatype1), dtList1, segList1);
                var dt2 = CompareService.fDatatype(JSON.parse(datatype2), dtList2, segList2);
                var diff = ObjectDiff.diffOwnProperties(dt1, dt2);
                var dataList = [];
                if (diff.changed === "object change") {
                    var array = CompareService.objToArray(diff);
                    var arraySeg = CompareService.objToArray(array[1]);
                    CompareService.writettTable(arraySeg[0], dataList);
                    // }

                }
                return dataList;

            },
            cmpValueSet: function(table1, table2) {

                var vs1 = JSON.parse(table1);
                var vs2 = JSON.parse(table2);
                var diff = ObjectDiff.diffOwnProperties(vs1, vs2);
                var dataList = [];
                if (diff.changed === "object change") {
                    CompareService.writettTable(diff, dataList);
                }
                return dataList
            },
            fMsg: function(msg, datatypeList, segmentList) {

                var elements = []
                var message = {
                    name: msg.name,
                    event: msg.event,
                    structID: msg.structID,
                    position: msg.position,
                    segments: CompareService.fElements(msg.children, datatypeList, segmentList)
                };
                // for (var i = 0; i < msg.children.length; i++) {
                //     elements.push($scope.fElement(msg.children[i]));
                // };
                // message.segments=elements;

                return message;
            },
            fSegment: function(segment, datatypeList, segmentList) {
                var elements = [];

                if (segment.type === "segment") {
                    elements.push(segment);
                }

                return CompareService.fElements(elements, datatypeList, segmentList);
            },
            fDatatype: function(datatype, datatypeList, segmentList) {
                var elements = [];

                if (datatype.type === "datatype") {
                    elements.push(datatype);
                }

                return CompareService.fElements(elements, datatypeList, segmentList);
            },

            fElements: function(elements, datatypeList, segmentList) {

                var result = [];
                for (var i = 0; i < elements.length; i++) {
                    if (elements[i].type === 'segmentRef') {
                        var segment = {};

                        segment = {
                            //id: elements[i].ref.id,
                            name: elements[i].ref.name,
                            label: elements[i].ref.label,
                            type: elements[i].type,
                            minCard: elements[i].min,
                            maxCard: elements[i].max,
                            usage: elements[i].usage,
                            position: elements[i].position
                        };

                        for (var j = 0; j < segmentList.length; j++) {


                            if (elements[i].ref.id === segmentList[j].id) {

                                segment.description = segmentList[j].description;
                                segment.conformanceStatements = segmentList[j].conformanceStatements;
                                segment.coConstraints = segmentList[j].coConstraints;
                                segment.predicates = segmentList[j].predicates;
                                segment.fields = CompareService.fFields(segmentList[j].fields, datatypeList, segmentList);
                            }
                        };



                        result.push(segment);

                    } else if (elements[i].type === 'group') {
                        result.push(CompareService.fGrp(elements[i], datatypeList, segmentList));
                    } else if (elements[i].type === 'segment') {
                        elements[i].fields = CompareService.fFields(elements[i].fields, datatypeList, segmentList);
                        result.push(elements[i]);
                    } else if (elements[i].type === 'datatype') {
                        elements[i].components = CompareService.fFields(elements[i].components, datatypeList, segmentList);
                        result.push(elements[i]);
                    } else if (elements[i].type === 'component') {
                        //elements[i].fields = $scope.fFields(elements[i].fields, datatypeList, segmentList);

                    }
                };
                return result;
            },
            fGrp: function(grp, datatypeList, segmentList) {
                var group = {
                    name: grp.name,
                    type: grp.type,
                    minCard: grp.min,
                    maxCard: grp.max,
                    usage: grp.usage,
                    position: grp.position,
                    segments: CompareService.fElements(grp.children, datatypeList, segmentList)
                };
                return group;
            },
            fFields: function(fields, datatypeList, segmentList) {
                // for (var j = 0; j < datatypeList.length; j++) {
                //     for (var i = 0; i < datatypeList[j].components.length; i++) {
                //         datatypeList[j].components[i].id = "";
                //         datatypeList[j].components[i].datatype.id = "";

                //     }
                // }

                for (var i = 0; i < fields.length; i++) {
                    fields[i].id = "";
                    fields[i].dateUpdated = null;
                    for (var j = 0; j < datatypeList.length; j++) {
                        if (fields[i].datatype.id === datatypeList[j].id) {

                            fields[i].components = CompareService.fFields(datatypeList[j].components, datatypeList, segmentList);

                        }
                    };
                    if (fields[i].datatype.ext === "") {
                        fields[i].datatype.ext = null;
                    }
                    fields[i].datatype.id = "";

                };


                return fields;


            },
            writettTable: function(childArray, dataArray) {
                var result = {};


                if (childArray.changed === "object change") {
                    if (childArray.value.position && childArray.value.position.changed === "equal") {
                        result.position = {
                            element: childArray.value.position.value,

                        };
                    }

                    if (childArray.value.type.changed === "equal") {
                        result.type = {
                            element: childArray.value.type.value,
                        };

                        if (childArray.value.usage && childArray.value.usage.changed === "primitive change") {
                            result.usage = {
                                element1: childArray.value.usage.removed,
                                element2: childArray.value.usage.added

                            };
                        }
                        if (childArray.value.type.value === "field" || childArray.value.type.value === "component" || childArray.value.type.value === "datatype") {

                            if (childArray.value.name.changed === "primitive change") {
                                result.label = {
                                    element1: childArray.value.name.removed,
                                    element2: childArray.value.name.added

                                };

                            }


                            if (childArray.value.name.changed === "equal") {
                                result.label = {
                                    element: childArray.value.name.value,
                                };
                            }
                            if (childArray.value.ext && childArray.value.ext.changed === "primitive change") {
                                result.ext = {
                                    element1: childArray.value.ext.removed,
                                    element2: childArray.value.name.added

                                };

                            }


                            if (childArray.value.ext && childArray.value.ext.changed === "equal" && childArray.value.ext.value !== null) {
                                result.ext = {
                                    element: childArray.value.ext.value,

                                };
                            }
                            if (childArray.value.min && childArray.value.min.changed === "primitive change") {
                                result.minCard = {
                                    element1: childArray.value.min.removed,
                                    element2: childArray.value.min.added

                                };
                            } else if (childArray.value.min && childArray.value.min.changed === "removed") {
                                console.log(childArray.value.min);
                            } else if (childArray.value.min && childArray.value.min.changed === "added") {
                                console.log(childArray.value.min);
                            }
                            if (childArray.value.max && childArray.value.max.changed === "primitive change") {
                                result.maxCard = {
                                    element1: childArray.value.max.removed,
                                    element2: childArray.value.max.added

                                };
                            }
                            if (childArray.value.minLength && childArray.value.minLength.changed === "primitive change") {
                                result.minLength = {
                                    element1: childArray.value.minLength.removed,
                                    element2: childArray.value.minLength.added

                                };
                            }
                            if (childArray.value.maxLength && childArray.value.maxLength.changed === "primitive change") {
                                result.maxLength = {
                                    element1: childArray.value.maxLength.removed,
                                    element2: childArray.value.maxLength.added

                                };
                            }
                            if (childArray.value.confLength && childArray.value.confLength.changed === "primitive change") {
                                result.confLength = {
                                    element1: childArray.value.confLength.removed,
                                    element2: childArray.value.confLength.added

                                };
                            }
                            if (childArray.value.datatype && childArray.value.datatype.changed === "object change") {
                                result.datatype = {
                                    element1: childArray.value.datatype.value.label.removed,
                                    element2: childArray.value.datatype.value.label.added

                                };
                            }
                            if (childArray.value.components && childArray.value.components.changed === "object change") {
                                result.components = [];
                                CompareService.objToArray(childArray.value.components.value).forEach(function(childNode) {
                                    CompareService.writettTable(childNode, result.components);

                                });
                                // objToArray(childArray.value.components.value).forEach(function(childNode) {
                                //     if(childNode.changed==="added"){
                                //         result.component.push({
                                //             msg1:"";
                                //             msg2:childNode
                                //         })

                                //     } else if(childNode.changed==="removed"){

                                //     } else 
                                //     if(childNode.changed==="object change"){
                                //         writettTable(childNode, result.components);

                                //     }


                                // });

                            }
                            if (childArray.value.table && childArray.value.table.changed === "object change" && childArray.value.table.value.bindingIdentifier.changed === "primitive change") {
                                result.valueset = {
                                    element1: childArray.value.table.value.bindingIdentifier.removed,
                                    element2: childArray.value.table.value.bindingIdentifier.added

                                };

                            }


                        } else {

                            if (childArray.value.minCard && childArray.value.minCard.changed === "primitive change") {
                                result.minCard = {
                                    element1: childArray.value.minCard.removed,
                                    element2: childArray.value.minCard.added

                                };
                            }
                            if (childArray.value.maxCard && childArray.value.maxCard.changed === "primitive change") {
                                result.maxCard = {
                                    element1: childArray.value.maxCard.removed,
                                    element2: childArray.value.maxCard.added

                                };
                            }
                        }

                        if (childArray.value.type.value === "segmentRef" || childArray.value.type.value === "segment") {
                            if (childArray.value.name.changed === "primitive change") {
                                result.label = {
                                    element1: childArray.value.name.removed,
                                    element2: childArray.value.name.added
                                };
                            }
                            if (childArray.value.name.changed === "equal") {
                                result.label = {
                                    element: childArray.value.name.value,
                                };
                            }
                            if (childArray.value.ext && childArray.value.ext.changed === "primitive change") {
                                result.ext = {
                                    element1: childArray.value.ext.removed,
                                    element2: childArray.value.ext.added
                                };
                            }
                            if (childArray.value.ext && childArray.value.ext.changed === "equal") {
                                result.ext = {
                                    element: childArray.value.ext.value,
                                };
                            }
                            if (childArray.value.description && childArray.value.description.changed === "primitive change") {
                                result.description = {
                                    element1: childArray.value.description.removed,
                                    element2: childArray.value.description.added
                                };
                            } else if (childArray.value.description && childArray.value.description.changed === "equal") {
                                result.description = {
                                    element: childArray.value.description.value,

                                };
                            }


                            if (childArray.value.fields && childArray.value.fields.changed === "object change") {
                                console.log(childArray.value.fields);
                                result.fields = [];
                                CompareService.objToArray(childArray.value.fields.value).forEach(function(childNode) {
                                    CompareService.writettTable(childNode, result.fields);

                                });
                            }

                        } else if (childArray.value.type.value === "group") {
                            if (childArray.value.name.changed === "primitive change") {
                                result.label = {
                                    element1: childArray.value.name.removed,
                                    element2: childArray.value.name.added

                                };

                            }

                            if (childArray.value.name.changed === "equal") {
                                result.label = {
                                    element: childArray.value.name.value,

                                };
                            }
                            if (childArray.value.segments.changed === "object change") {
                                result.segments = [];
                                CompareService.objToArray(childArray.value.segments.value).forEach(function(childNode) {
                                    CompareService.writettTable(childNode, result.segments);

                                });


                            }
                        } else if (childArray.value.type.value === "table") {
                            if (childArray.value.bindingIdentifier.changed === "primitive change") {
                                result.label = {
                                    element1: childArray.value.bindingIdentifier.removed,
                                    element2: childArray.value.bindingIdentifier.added

                                };

                            }

                            if (childArray.value.bindingIdentifier.changed === "equal") {
                                result.label = {
                                    element: childArray.value.bindingIdentifier.value,

                                };
                            }
                            if (childArray.value.description && childArray.value.description.changed === "primitive change") {
                                result.description = {
                                    element1: childArray.value.description.removed,
                                    element2: childArray.value.description.added
                                };
                            } else if (childArray.value.description && childArray.value.description.changed === "equal") {
                                result.description = {
                                    element: childArray.value.description.value,

                                };
                            }
                            if (childArray.value.contentDefinition && childArray.value.contentDefinition.changed === "primitive change") {
                                result.contentDefinition = {
                                    element1: childArray.value.contentDefinition.removed,
                                    element2: childArray.value.contentDefinition.added
                                };
                            }
                            if (childArray.value.codes && childArray.value.codes.changed === "object change") {
                                result.codes = [];
                                CompareService.objToArray(childArray.value.codes.value).forEach(function(childNode) {
                                    CompareService.writettTable(childNode, result.codes);

                                });
                            }
                        } else if (childArray.value.type.value === "code") {
                            if (childArray.value.codeSystem && childArray.value.codeSystem.changed === "primitive change") {
                                result.codeSystem = {
                                    element1: childArray.value.codeSystem.removed,
                                    element2: childArray.value.codeSystem.added
                                };
                            }
                            if (childArray.value.codeUsage && childArray.value.codeUsage.changed === "primitive change") {
                                result.codeUsage = {
                                    element1: childArray.value.codeUsage.removed,
                                    element2: childArray.value.codeUsage.added
                                };
                            }
                            if (childArray.value.label && childArray.value.label.changed === "primitive change") {
                                result.description = {
                                    element1: childArray.value.label.removed,
                                    element2: childArray.value.label.added
                                };
                            } else if (childArray.value.label && childArray.value.label.changed === "equal") {
                                result.description = {
                                    element: childArray.value.label.value,

                                };
                            }
                            if (childArray.value.value && childArray.value.value.changed === "primitive change") {
                                result.label = {
                                    element1: childArray.value.value.removed,
                                    element2: childArray.value.value.added
                                };
                            } else if (childArray.value.value && childArray.value.value.changed === "equal") {
                                result.label = {
                                    element: childArray.value.value.value,

                                };
                            }
                        }
                    } else if (childArray.value.type.changed === "primitive change") {
                        result.label = {
                            element1: childArray.value.name.removed,
                            element2: childArray.value.name.added

                        };
                        result.type = {
                            element1: childArray.value.type.removed,
                            element2: childArray.value.type.added
                        };
                    }





                } else if (childArray.changed === "added") {
                    if (childArray.value.type === "field" || childArray.value.type === "component") {
                        var empty = "";

                        console.log("--HEEEEREE");
                        console.log(childArray);
                        result.position = {
                            element: childArray.value.position,

                        };
                        result.type = {
                            element2: childArray.value.type,

                        };
                        result.label = {
                            element1: empty,
                            element2: childArray.value.name
                        };
                        result.usage = {
                            element1: empty,
                            element2: childArray.value.usage
                        };
                        result.minCard = {
                            element1: empty,
                            element2: childArray.value.min
                        };
                        result.maxCard = {
                            element1: empty,
                            element2: childArray.value.max
                        };
                        result.minLength = {
                            element1: empty,
                            element2: childArray.value.minLength
                        };
                        result.maxLength = {
                            element1: empty,
                            element2: childArray.value.maxLength
                        };
                        result.confLength = {
                            element1: empty,
                            element2: childArray.value.confLength
                        };
                        result.datatype = {
                            element1: empty,
                            element2: childArray.value.datatype.label
                        };
                        var components = [];
                        if (childArray.value.components) {
                            for (var i = 0; i < childArray.value.components.length; i++) {
                                var component = {};
                                component.position = {
                                    element: childArray.value.components[i].position,

                                };
                                component.type = {
                                    element2: childArray.value.components[i].type,

                                };
                                component.label = {
                                    element1: empty,
                                    element2: childArray.value.components[i].name
                                };
                                component.usage = {
                                    element1: empty,
                                    element2: childArray.value.components[i].usage
                                };

                                component.minLength = {
                                    element1: empty,
                                    element2: childArray.value.components[i].minLength
                                };
                                component.maxLength = {
                                    element1: empty,
                                    element2: childArray.value.components[i].maxLength
                                };
                                component.confLength = {
                                    element1: empty,
                                    element2: childArray.value.components[i].confLength
                                };
                                component.datatype = {
                                    element1: empty,
                                    element2: childArray.value.components[i].datatype.label
                                };
                                components.push(component);


                            }
                        }

                        console.log(components);
                        result.components = components;


                    }


                } else if (childArray.changed === "removed") {
                    var empty = "";
                    if (childArray.value.type === "field" || childArray.value.type === "component") {
                        console.log("--HEEEEREE");
                        console.log(childArray);
                        result.position = {
                            element: childArray.value.position,

                        };
                        result.type = {
                            element1: childArray.value.type,

                        };
                        result.label = {
                            element2: empty,
                            element1: childArray.value.name
                        };
                        result.usage = {
                            element2: empty,
                            element1: childArray.value.usage
                        };
                        result.minCard = {
                            element2: empty,
                            element1: childArray.value.min
                        };
                        result.maxCard = {
                            element2: empty,
                            element1: childArray.value.max
                        };
                        result.minLength = {
                            element2: empty,
                            element1: childArray.value.minLength
                        };
                        result.maxLength = {
                            element2: empty,
                            element1: childArray.value.maxLength
                        };
                        result.confLength = {
                            element2: empty,
                            element1: childArray.value.confLength
                        };
                        result.datatype = {
                            element2: empty,
                            element1: childArray.value.datatype.label
                        };
                        var components = [];
                        if (childArray.value.components) {
                            for (var i = 0; i < childArray.value.components.length; i++) {
                                var component = {};
                                component.position = {
                                    element: childArray.value.components[i].position,

                                };
                                component.type = {
                                    element1: childArray.value.components[i].type,

                                };
                                component.label = {
                                    element2: empty,
                                    element1: childArray.value.components[i].name
                                };
                                component.usage = {
                                    element2: empty,
                                    element1: childArray.value.components[i].usage
                                };

                                component.minLength = {
                                    element2: empty,
                                    element1: childArray.value.components[i].minLength
                                };
                                component.maxLength = {
                                    element2: empty,
                                    element1: childArray.value.components[i].maxLength
                                };
                                component.confLength = {
                                    element2: empty,
                                    element1: childArray.value.components[i].confLength
                                };
                                component.datatype = {
                                    element2: empty,
                                    element1: childArray.value.components[i].datatype.label
                                };
                                components.push(component);


                            }
                        }

                        console.log(components);
                        result.components = components;




                    }


                }
                dataArray.push(result);
            },




        };
        return CompareService;
    });
/**
 * Created by haffo on 3/9/16.
 */
'use strict';
angular.module('igl').factory('ComponentService',
    ['$rootScope', 'ViewSettings', 'ElementUtils', '$filter', function ($rootScope, ViewSettings, ElementUtils,$filter) {
        var ComponentService = {
            create: function (position) {
                return {
                    id: new ObjectId().toString(),
                    type: 'component',
                    name: '',
                    usage: null,
                    minLength: 0,
                    maxLength: '0',
                    confLength: '1',
                    table: '',
                    bindingStrength: '',
                    bindingLocation: '',
                    datatype: null,
                    position: position,
                    comment: null,
                    text: null,
                    hide: false,
                    status:"DRAFT"
                }
            },

            deleteOne: function(component, datatype){
                if( datatype.components != null &&  datatype.components) {
                    var index = datatype.components.indexOf(component);
                    if (index > -1) datatype.components.splice(index, 1);
                }
                this.computePositions(datatype);
            },
            deleteList: function(components, datatype){
                var that = this;
                angular.forEach(components, function (child) {
                    that.deleteOne(child,datatype);
                });
                this.computePositions(datatype);
            },
            computePositions: function(datatype){
                datatype.components = $filter('orderBy')(datatype.components, 'position');
                for(var i=0; i < datatype.components.length;i++){
                    datatype.components[i].position = i+1;
                }
            }
        };
        return ComponentService;
    }]);

'use strict';
angular.module('igl').factory('CompositeMessageService',
    function($rootScope, ViewSettings, ElementUtils, $q, $http, FilteringSvc, SegmentLibrarySvc, TableLibrarySvc, DatatypeLibrarySvc) {
        var CompositeMessageService = {
            create: function(message, igId) {
                var delay = $q.defer();
                $http.post('api/composite-messages/create/' + igId, message, {
                    headers: { 'Content-Type': 'application/json' }
                }).then(function(response) {
                    var saved = angular.fromJson(response.data);
                    delay.resolve(saved);
                    return saved;
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            save: function(message) {
                var delay = $q.defer();
                $http.post('api/composite-messages/save', message, {
                    headers: { 'Content-Type': 'application/json' }
                }).then(function(response) {
                    var saved = angular.fromJson(response.data);
                    delay.resolve(saved);
                    return saved;
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            getCm: function(cmID) {
                var delay = $q.defer();
                $http.get('api/composite-messages/' + cmID).then(function(response) {
                    console.log("-----------------------");
                    console.log(response);
                    var cm = angular.fromJson(response.data);
                    console.log(cm);
                    delay.resolve(cm);
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            getSegOrGrp: function(children) {
                var delay = $q.defer();


                console.log(children);

                $http.post('api/composite-messages/getsegorgrp', children).then(function(response) {
                    console.log("-----------------------");
                    console.log(response);
                    var cm = angular.fromJson(response.data);
                    console.log(cm);
                    delay.resolve(cm);
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            SaveGroupOrSegment: function(children) {
                console.log(children);
                var delay = $q.defer();
                $http.post('api/composite-messages/savegrporseg', children).then(function(response) {
                    console.log("-----------------------");
                    console.log(response);
                    var cm = angular.fromJson(response.data);
                    console.log(cm);
                    delay.resolve(cm);
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;

            }




        };
        return CompositeMessageService;
    });
'use strict';

/**
 * @ngdoc function
 * @description
 *
 * This service is used to tranfer the state of a context menu selection between controllers.  
 * The state can be accessed but once.  It is left in its inital state. 
 */

angular.module('igl').factory('ContextMenuSvc', function () {
	
	var svc = {};
    
    svc.item = null;
    
    svc.ext = null;
    
    svc.get = function() {
    	var tmp = svc.item;
    	svc.item = null;
    	return tmp;
    };
    
    svc.put = function(item) {
    	svc.item = item;
    };
    
    return svc;
});





angular.module('igl').factory('DatatypeLibraryDocumentSvc', function ($q, $http, $httpBackend, userInfoService, blockUI, $rootScope, $cookies) {

    var svc = this;
    var dtLibStruct = function (scope, children) {
        this.id = null;
        this.scope = scope;
        this.sectionDescription = null;
        this.sectionContents = null;
        this.children = children;
    };

    svc.getDataTypeLibraryDocumentByScope= function(scope) {
        var delay = $q.defer();
        $http.post('api/datatype-library-document/findByScope',scope).then(function(response) {
            var saveResponse = angular.fromJson(response);
            delay.resolve(saveResponse);
        }, function(error) {
            //console.log("DatatypeService.save error=" + error);
            delay.reject(error);
        });
        return delay.promise;
    },

    

//    svc.getDataTypeLibraryDocumentByScopeForAll = function (scope) {
//        console.log("datatype-library-document/findByScopeForAll scope=" + scope);
//        return $http.post(
//            'api/datatype-library-document/findByScopeForAll', scope)
//            .then(function (response) {
//                console.log("getDataTypeLibraryByScope response=" + response.data.length);
//                return angular.fromJson(response);
//            });
//    };
//

    svc.create = function (hl7Version, scope, name, ext,description, orgName) {
        var dtlcw = { "hl7Version": hl7Version,
            "scope": scope,
            "name": name,
            "ext": ext,
            "description":description,
            "orgName":orgName,
            "accountId": userInfoService.getAccountID()};
        return $http.post(
            'api/datatype-library-document/create', dtlcw).then(function (response) {
                return angular.fromJson(response)
            });
    };
    
   svc.delete = function (datatypeLibraryDocumentId) {
    	
        return $http.get(
            'api/datatype-library-document/' + datatypeLibraryDocumentId + '/delete').then(function (response) {
                return angular.fromJson(response.data)
            });
    };
    
    svc.save = function (datatypeLibrary) {
        blockUI.start();

        return $http.post(
            'api/datatype-library-document/save', angular.toJson(datatypeLibrary)).then(function (response) {
            	 blockUI.stop();
                return angular.fromJson(response.data)
                
            });
    };
    svc.getAllDatatypesNames = function (datatypeLibrary) {
    	 var delay = $q.defer();

        $http.post('api/datatype-library-document/getAllDatatypesName').then(function (response) {
                delay.resolve(angular.fromJson(response.data));
            
            } , function(error) {
                    //console.log("DatatypeService.save error=" + error);
                    delay.reject(error);
                });
                return delay.promise;
    },
    
    svc.getDataTypeLibraryDocumentByScope= function(scope) {
        var delay = $q.defer();
        $http.post('api/datatype-library-document/findByScope',scope).then(function(response) {
            var saveResponse = angular.fromJson(response);
            delay.resolve(saveResponse);
        }, function(error) {
            //console.log("DatatypeService.save error=" + error);
            delay.reject(error);
        });
        return delay.promise;
    },
    

    svc.exportAs = function(dataTypeLibraryDocumentId, format) {
        blockUI.start();

            var form = document.createElement("form");
            form.action = $rootScope.api('api/datatype-library-document/' + dataTypeLibraryDocumentId + '/export/' + format);
            form.method = "POST";
            form.target = "_blank";
            var csrfInput = document.createElement("input");
            csrfInput.name = "X-XSRF-TOKEN";
            csrfInput.value = $cookies['XSRF-TOKEN'];
            form.appendChild(csrfInput);
            form.style.display = 'none';
            document.body.appendChild(form);
            form.submit();
            blockUI.stop();
        };
    
    svc.getMatrix = function () {
        
        return $http.post(
            'api/datatype-library-document/getMatrix').then(function (response) {
                return angular.fromJson(response.data)
            });
    };
    
    return svc;
});

/**
 * http://usejsdoc.org/
 */
angular.module('igl').factory('DatatypeLibrarySvc', function ($q, $http, $httpBackend, userInfoService) {

    var svc = this;

    var dtLibStruct = function (scope, children) {
        this.id = null;
        this.scope = scope;
        this.sectionDescription = null;
        this.sectionContents = null;
        this.children = children;
    };

    svc.getHL7Versions = function () {
        return $http.get(
            'api/datatype-library/findHl7Versions')
            .then(function (response) {
//					console.log("response" + JSON.stringify(response));
                return angular.fromJson(response.data);
            });
    };

    svc.getDataTypeLibraryByScope = function (scope) {
        console.log("datatype-library/findByScope scope=" + scope);
        return $http.post(
            'api/datatype-library/findByScope', scope)
            .then(function (response) {
                console.log("getDataTypeLibraryByScope response=" + response.data.length);
                return angular.fromJson(response.data);
            });
    };

    svc.getDataTypeLibraryByScopesAndVersion = function (scopes, hl7Version) {
        console.log("datatype-library/findByScopesAndVersion scopes=" + scopes + " hl7Version=" + hl7Version);
        var scopesAndVersion = {
            "scopes": scopes,
            "hl7Version": hl7Version
        };
        return $http.post(
            'api/datatype-library/findByScopesAndVersion', angular.toJson(scopesAndVersion))
            .then(function (response) {
                console.log("getDataTypeLibraryByScopesAndVersion response size=" + response.data.length);
                return angular.fromJson(response.data);
            });
    };
   

    svc.getDatatypesByLibrary = function (dtLibId) {
        return $http.get(
                'api/datatype-library/' + dtLibId + '/datatypes')
            .then(function (response) {
                //					console.log("response" + JSON.stringify(response));
                return angular.fromJson(response.data);
            });
    };

    svc.append = function (fromchildren, toChildren) {
        angular.foreach(fromchildren, function (child) {
            toChildren.push(child);
        });
        return svc.datatypeLibrary;
    };

    svc.createUpdate = function (scope, children) {
        var dtlrw = new dtLibStruct(scope, sortedChildren);
    };

    svc.create = function (hl7Version, scope, name, ext) {
        var dtlcw = { "hl7Version": hl7Version,
            "scope": scope,
            "name": name,
            "ext": ext,
            "accountId": userInfoService.getAccountID()};
        return $http.post(
            'api/datatype-library/create', dtlcw).then(function (response) {
                return angular.fromJson(response.data)
            });
    };

    svc.saveMetaData = function (datatypeLibraryId, datatypeLibraryMetaData) {
    	console.log("datatypeLibraryMetaData=" + JSON.stringify(datatypeLibraryMetaData));
        return $http.post(
            'api/datatype-library/' + datatypeLibraryId + '/saveMetaData', datatypeLibraryMetaData).then(function (response) {
                return angular.fromJson(response.data)
            });
    };

    svc.save = function (datatypeLibrary) {
    	
        return $http.post(
            'api/datatype-library/save', angular.toJson(datatypeLibrary)).then(function (response) {
                return angular.fromJson(response.data)
            });
    };
    
   svc.delete = function (datatypeLibraryId) {
    	
        return $http.get(
            'api/datatype-library/' + datatypeLibraryId + '/delete').then(function (response) {
                return angular.fromJson(response.data)
            });
    };

    svc.bindDatatypes = function (ids, dtLibId, dtLibExt) {
        var binding = {
            "datatypeIds": ids,
            "datatypeLibraryId": dtLibId,
            "datatypeLibraryExt": dtLibExt,
            "accountId": userInfoService.getAccountID()
        };
        var delay = $q.defer();
        $http.post('api/datatype-library/bindDatatypes', binding).then(function (response) {
            var datatypes = angular.fromJson(response.data);
            delay.resolve(datatypes);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };


    svc.findOneChild = function (id, list) {
        if (list) {
            for (var i = 0; i < list.length; i++) {
                if (list[i].id === id) {
                    return list[i];
                }
            }
        }
        return null;
    };

    svc.createEmptyLink = function () {
        return {id:null, ext:null, name:null};
    };


    svc.addChild = function (libId, datatypeLink) {
        var delay = $q.defer();
        $http.post('api/datatype-library/'+ libId+ '/addChild', datatypeLink).then(function (response) {
            var link = angular.fromJson(response.data);
            delay.resolve(link);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    svc.updateChild = function (libId, datatypeLink) {
        var delay = $q.defer();
        $http.post('api/datatype-library/'+ libId+ '/updateChild', datatypeLink).then(function (response) {
            var link = angular.fromJson(response.data);
            delay.resolve(link);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    svc.deleteChild = function (libId, id) {
        var delay = $q.defer();
        $http.post('api/datatype-library/'+ libId+ '/deleteChild/' + id).then(function (response) {
            var link = angular.fromJson(response.data);
            delay.resolve(link);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    svc.findFlavors = function (name, scope, hl7Version, libId) {
        var delay = $q.defer();
        $http.get('api/datatype-library/'+ libId + '/findFlavors', {params: {"name": name, "scope": scope, "hl7Version": hl7Version}}).then(function (response) {
            var datatypes = angular.fromJson(response.data);
            delay.resolve(datatypes);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    svc.findLibrariesByFlavorName = function (flavorName, flavorScope, flavorHl7Version) {
        var delay = $q.defer();
        $http.get('api/datatype-library/findLibrariesByFlavorName', {params: {"name": flavorName, "scope": flavorScope, "hl7Version": flavorHl7Version}}).then(function (response) {
            var libraries = angular.fromJson(response.data);
            delay.resolve(libraries);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    svc.findDatatypeFlavorsByName = function (flavorName, flavorScope, flavorHl7Version) {
        var delay = $q.defer();
        $http.get('api/datatype-library/findDatatypeFlavorsByName', {params: {"name": flavorName, "scope": flavorScope, "hl7Version": flavorHl7Version}}).then(function (response) {
            var libraries = angular.fromJson(response.data);
            delay.resolve(libraries);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    svc.addChildren = function (libId, datatypeLinks) {
        var delay = $q.defer();
        $http.post('api/datatype-library/'+ libId+ '/addChildren', datatypeLinks).then(function (response) {
            var res = angular.fromJson(response.data);
            delay.resolve(res);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };



    return svc;
});

/**
 * Created by haffo on 3/9/16.
 */
'use strict';
angular.module('igl').factory('DatatypeService',
    function($rootScope, ViewSettings, ElementUtils, $http, $q, FilteringSvc, userInfoService, TableLibrarySvc, DatatypeLibrarySvc) {
        var DatatypeService = {
            getNodes: function(parent, root) {
                var children = [];
                if (parent && parent != null) {
                    if (parent.datatype) {
                        var dt = $rootScope.datatypesMap[parent.datatype.id];
                        children = dt.components;
                    } else {
                        children = parent.components;
                    }
                } else {
                    if (root != null) {
                        children = root.components;
                    } else {
                        children = [];
                    }
                }
                return children;
            },
            getDatatypeNodesInLib: function(parent, root) {
                console.log(root);
                var children = [];
                if (parent && parent != null) {
                    if (parent.datatype) {
                        var dt = $rootScope.datatypesMap[parent.datatype.id];
                        children = dt.components;
                    } else {
                        children = parent.components;
                    }
                } else {
                    if (root != null) {
                        children = root.components;
                    } else {
                        children = [];
                    }
                }
                console.log(children);
                return children;
            },

            // body...

            getParent: function(child) {
                var template = $rootScope.parentsMap[child.id] ? $rootScope.parentsMap[child.id] : null;
                return template;
            },
            getTemplate: function(node, root) {
                var userAccountId = userInfoService.getAccountID().toString();
                if (ViewSettings.tableReadonly || root != null && (root.status === 'PUBLISHED')|| root.scope === null) {
                    return DatatypeService.getReadTemplate(node, root);
                } else {
                    //console.log("INTO THE NODES ")
                    //console.log(node);
                    //console.log(root);
                    return DatatypeService.getEditTemplate(node, root);
                }
            },

            getReadTemplate: function(node, root) {
                return node.type === 'Datatype' ? 'DatatypeReadTree.html' : node.type === 'component' && !DatatypeService.isDatatypeSubDT(node, root) ? 'DatatypeComponentReadTree.html' : node.type === 'component' && DatatypeService.isDatatypeSubDT(node, root) ? 'DatatypeSubComponentReadTree.html' : '';
            },

            getEditTemplate: function(node, root) {
                return node.type === 'Datatype' ? 'DatatypeEditTree.html' : node.type === 'component' && !DatatypeService.isDatatypeSubDT(node, root) ? 'DatatypeComponentEditTree.html' : node.type === 'component' && DatatypeService.isDatatypeSubDT(node, root) ? 'DatatypeSubComponentEditTree.html' : '';
            },


            getTemplateINLIB: function(node, root) {
                if ($rootScope.readOnly || root != null && root.scope === 'HL7STANDARD' || root.scope === null || root != null && root.status === 'PUBLISHED') {
                    return DatatypeService.getReadTemplateINLIB(node, root);
                } else {
                    //console.log("INTO THE NODES ")
                    //console.log(node);
                    //console.log(root);
                    return DatatypeService.getEditTemplateINLIB(node, root);
                }
            },

            getReadTemplateINLIB: function(node, root) {
                return node.type === 'Datatype' ? 'DatatypeReadTree.html' : node.type === 'component' && !DatatypeService.isDatatypeSubDT(node, root) ? 'DatatypeComponentReadTreeINLIB2.html' : node.type === 'component' && DatatypeService.isDatatypeSubDT(node, root) ? 'DatatypeSubComponentReadTreeINLIB2.html' : '';
            },

            getEditTemplateINLIB: function(node, root) {
                return node.type === 'Datatype' ? 'DatatypeEditTreeINLIB2.html' : node.type === 'component' && !DatatypeService.isDatatypeSubDT(node, root) ? 'DatatypeComponentEditTreeINLIB2.html' : node.type === 'component' && DatatypeService.isDatatypeSubDT(node, root) ? 'DatatypeSubComponentEditTreeINLIB2.html' : '';
            },



            isDatatypeSubDT: function(component, root) {
                if (root != null) {
                    for (var i = 0, len = root.components.length; i < len; i++) {
                        if (root.components[i].id === component.id)
                            return false;
                    }
                }
                return true;
            },
            isBranch: function(node) {
                var children = DatatypeService.getNodes(node);
                return children != null && children.length > 0;
            },
            isVisible: function(node) {
                //                return FilteringSvc.show(node);
                return true;
                //                return  node ? DatatypeService.isRelevant(node) ? DatatypeService.isVisible(DatatypeService.getParent(node)) : false : true;
            },
            isRelevant: function(node) {
                if (node === undefined || !ViewSettings.tableRelevance)
                    return true;
                if (node.hide == undefined || !node.hide || node.hide === false) {
                    var predicates = DatatypeService.getDatatypeLevelPredicates(node);
                    return ElementUtils.isRelevant(node, predicates);
                } else {
                    return false;
                }
            },
            getDatatypeLevelConfStatements: function(element) {
                var datatype = DatatypeService.getParent(element);
                var confStatements = [];
                if (datatype && datatype != null && datatype.conformanceStatements.length > 0) {
                    return ElementUtils.filterConstraints(element, datatype.conformanceStatements);
                }
                return confStatements;
            },

            getDatatypeLevelPredicates: function(element) {
                var datatype = DatatypeService.getParent(element);
                var predicates = [];
                if (datatype && datatype != null && datatype.predicates.length > 0) {
                    return ElementUtils.filterConstraints(element, datatype.predicates);
                }
                return predicates;
            },
            save: function(datatype) {
            	console.log(datatype);
                var delay = $q.defer();
                datatype.accountId = userInfoService.getAccountID();
                $http.post('api/datatypes/save', datatype).then(function(response) {
                    var saveResponse = angular.fromJson(response.data);
                     datatype.dateUpdated = saveResponse.dateUpdated;
                    datatype.version = saveResponse.version;
                    datatype.id = saveResponse.id;
                    delay.resolve(saveResponse);
                }, function(error) {
                    //console.log("DatatypeService.save error=" + error);
                    delay.reject(error);
                });
                return delay.promise;
            },
            publish: function(datatype) {
            	console.log(datatype);
                var delay = $q.defer();
                datatype.accountId = userInfoService.getAccountID();
                $http.post('api/datatypes/publish', datatype).then(function(response) {
                    var saveResponse = angular.fromJson(response.data);

                    delay.resolve(saveResponse);
                }, function(error) {
                    //console.log("DatatypeService.save error=" + error);
                    delay.reject(error);
                });
                return delay.promise;
            },
            saves: function(datatypes) {
                var delay = $q.defer();
                for (var i = 0; i < datatypes.length; i++) {
                    datatypes[i].accountId = userInfoService.getAccountID();
                }

                $http.post('api/datatypes/saveDts', datatypes).then(function(response) {
                    var saveResponse = angular.fromJson(response.data);
                    for (var i = 0; i < datatypes.length; i++) {
                        datatypes[i].dateUpdated = saveResponse[i].dateUpdated;
                        datatypes[i].version = saveResponse[i].version;
                    }

                    delay.resolve(saveResponse);
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            saveAll: function(datatypes) {
                var delay = $q.defer();
                $http.post('api/datatypes/saveAll', datatypes).then(function(response) {
                    //                    var saveResponse = angular.fromJson(response.data);
                    //                    datatype.date = saveResponse.date;
                    //                    datatype.version = saveResponse.version;
                    //                    datatype.id = saveResponse.id;
                    //                    delay.resolve(datatypes);
                }, function(error) {
                    //console.log("DatatypeService.save error=" + error);
                    delay.reject(error);
                });
                return delay.promise;
            },
            getOne: function(id) {
                var delay = $q.defer();
                if ($rootScope.datatypesMap[id] === undefined || $rootScope.datatypesMap[id] === null) {
                    $http.get('api/datatypes/' + id).then(function(response) {
                        var datatype = angular.fromJson(response.data);
                        delay.resolve(datatype);
                    }, function(error) {
                        delay.reject(error);
                    });
                } else {
                    delay.resolve($rootScope.datatypesMap[id]);
                }
                return delay.promise;
            },

            getOneDatatype: function(id) {
                var delay = $q.defer();

                $http.get('api/datatypes/' + id).then(function(response) {
                    var datatype = angular.fromJson(response.data);
                    delay.resolve(datatype);
                }, function(error) {
                    delay.reject(error);
                });

                return delay.promise;
            },


            get: function(ids) {
                var delay = $q.defer();
                $http.post('api/datatypes/findByIds', ids).then(function(response) {
                    var datatypes = angular.fromJson(response.data);
                    delay.resolve(datatypes);
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },

            getOneStandard: function(name, version, versions) {
                var wrapper = {
                    name: name,
                    hl7Version: version,
                    scope: "HL7STANDARD",
                    versions: versions
                }
                var delay = $q.defer();
                $http.post('api/datatypes/findOneStrandard', angular.toJson(wrapper)).then(function(response) {
                    console.log(response);
                    var datatype = angular.fromJson(response.data);
                    delay.resolve(datatype);
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },

            getLastMaster: function(name, version) {
                var wrapper = {
                    name: name,
                    version: version,
                }
                var delay = $q.defer();
                $http.post('api/datatypes/getLastMaster', angular.toJson(wrapper)).then(function(response) {
                    console.log(response);
                    var datatype = angular.fromJson(response.data);
                    delay.resolve(datatype);
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            getPublishedMaster: function(hl7Version) {
                var delay = $q.defer();

                $http.post('api/datatypes/findPublished', hl7Version).then(function(response) {
                    console.log(response);
                    var datatype = angular.fromJson(response.data);
                    delay.resolve(datatype);
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            getDataTypesByScopesAndVersion: function(scopes, hl7Version) {
                //console.log("datatypes/findByScopesAndVersion scopes=" + scopes + " hl7Version=" + hl7Version);
                var scopesAndVersion = {
                    "scopes": scopes,
                    "hl7Version": hl7Version
                };
                return $http.post(
                        'api/datatypes/findByScopesAndVersion', angular.toJson(scopesAndVersion))
                    .then(function(response) {
                        //console.log("getDataTypesByScopesAndVersion response size=" + response.data.length);
                        return angular.fromJson(response.data);
                    });
            },
            merge: function(to, from) {
                to = angular.extend(to, from);
                //                to.name = from.name;
                //                to.ext = from.ext;
                //                to.label = from.label;
                //                to.description = from.description;
                //                to.status = from.status;
                //                to.comment = from.comment;
                //                to.usageNote = from.usageNote;
                //                to.scope = from.scope;
                //                to.hl7Version = from.hl7Version;
                //                to.accountId = from.accountId;
                //                to.participants = from.participants;
                //                to.libId = from.libId;
                //                to.predicates = from.predicates;
                //                to.conformanceStatements = from.conformanceStatements;
                //                to.sectionPosition = from.sectionPosition;
                //                to.components = from.components;
                //                to.version = from.version;
                //                to.date = from.date;
                //                to.purposeAndUse = from.purposeAndUse;
                return to;
            },
            findFlavors: function(name, scope, hl7Version) {
                var delay = $q.defer();
                $http.get('api/datatypes/findFlavors', { params: { "name": name, "scope": scope, "hl7Version": hl7Version } }).then(function(response) {
                    var datatypes = angular.fromJson(response.data);
                    delay.resolve(datatypes);
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },

            delete: function(datatype) {
                return $http.get('api/datatypes/' + datatype.id + '/delete');
            },

            getDatatypeLink: function(datatype) {
                return { id: datatype.id, ext: datatype.ext, name: datatype.name };
            },
            collectDatatypes: function(id) {
                var delay = $q.defer();
                $http.get('api/datatypes/' + id + '/datatypes').then(function(response) {
                    delay.resolve(angular.fromJson(response.data));
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },

            saveNewElements: function() {
              saveNewElements(false);
            },

            saveNewElements: function(silent) {
                var delay = $q.defer();
                var datatypeLinks = ElementUtils.getNewDatatypeLinks();
                if (datatypeLinks&&datatypeLinks.length > 0) {
                    DatatypeLibrarySvc.addChildren($rootScope.datatypeLibrary.id, datatypeLinks).then(function() {
                        $rootScope.igdocument.profile.datatypeLibrary.children = $rootScope.datatypeLibrary.children.concat(datatypeLinks);
                        _.each($rootScope.addedDatatypes, function(datatype) {
                            if (ElementUtils.indexIn(datatype.id, $rootScope.datatypes) < 0) {
                                $rootScope.datatypes.push(datatype);
                            }
                        });
                        var tableLinks = ElementUtils.getNewTableLinks();
                        if (tableLinks.length > 0) {
                            TableLibrarySvc.addChildren($rootScope.tableLibrary.id, tableLinks).then(function() {
                                $rootScope.tableLibrary.children = $rootScope.tableLibrary.children.concat(tableLinks);
                                _.each($rootScope.addedTables, function(table) {
                                    if (ElementUtils.indexIn(table.id, $rootScope.tables) < 0) {
                                        $rootScope.tables.push(table);
                                    }
                                });
                                if(silent) {
                                  DatatypeService.completeSaveSilent();
                                } else {
                                  DatatypeService.completeSave();
                                }
                                delay.resolve(true);
                            }, function(error) {
                                delay.reject(error);
                            });
                        } else {
                            if(silent) {
                              DatatypeService.completeSaveSilent();
                            } else {
                              DatatypeService.completeSave();
                            }
                            delay.resolve(true);
                        }
                    }, function(error) {
                        delay.reject(error);
                    });
                } else {
                    if(silent) {
                      DatatypeService.completeSaveSilent();
                    } else {
                      DatatypeService.completeSave();
                    }
                    delay.resolve(true);
                }
                return delay.promise;
            },

            completeSave: function() {
                $rootScope.addedDatatypes = [];
                $rootScope.addedTables = [];
                $rootScope.clearChanges();
                $rootScope.msg().text = "datatypeSaved";
                $rootScope.msg().type = "success";
                $rootScope.msg().show = true;
            },

            completeSaveSilent: function() {
              $rootScope.addedDatatypes = [];
              $rootScope.addedTables = [];
              $rootScope.clearChanges();
            },

            reset: function() {
                if ($rootScope.addedDatatypes != null && $rootScope.addedDatatypes.length > 0) {
                    _.each($rootScope.addedDatatypes, function(id) {
                        delete $rootScope.datatypesMap[id];
                    });
                }
                if ($rootScope.addedTables != null && $rootScope.addedTables.length > 0) {
                    _.each($rootScope.addedTables, function(id) {
                        delete $rootScope.tablesMap[id];
                    });
                }
                $rootScope.datatype = angular.copy($rootScope.datatypesMap[$rootScope.datatype.id]);
            },
            resetLib: function() {
                if ($rootScope.addedDatatypes != null && $rootScope.addedDatatypes.length > 0) {
                    _.each($rootScope.addedDatatypes, function(id) {
                        delete $rootScope.datatypesMap[id];
                    });
                }
                if ($rootScope.addedTables != null && $rootScope.addedTables.length > 0) {
                    _.each($rootScope.addedTables, function(id) {
                        delete $rootScope.tablesMap[id];
                    });
                }
                $rootScope.datatype = angular.copy($rootScope.datatypesMap[$rootScope.datatype.id]);
            },

            updateTableBinding: function(datatypeUpdateParameterList) {
                var delay = $q.defer();
                $http.post('api/datatypes/updateTableBinding/', datatypeUpdateParameterList).then(function(response) {
                    delay.resolve(true);
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            updateDatatypeBinding: function(datatypeUpdateParameterList) {
                var delay = $q.defer();
                $http.post('api/datatypes/updateDatatypeBinding/', datatypeUpdateParameterList).then(function(response) {
                    delay.resolve(true);
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            share:function(datatypeId,shareParticipantIds, accountId){
                var delay = $q.defer();
                $http.post('api/datatypes/' + datatypeId + '/share', {'accountId': accountId, 'participantsList': shareParticipantIds}).then(function (response) {
                    delay.resolve(response.data);
                }, function (error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            unshare: function(datatypeId, participantId){
                var delay = $q.defer();
                $http.post('api/datatypes/' + datatypeId + '/unshare', participantId).then(function (response) {
                    delay.resolve(response.data);
                 }, function (error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            getSharedDatatypes: function(){
                var delay = $q.defer();
                $http.get('api/datatypes/findShared').then(function (response) {
                    delay.resolve(response.data);
                 }, function (error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            getPendingSharedDatatypes: function(){
                var delay = $q.defer();
                $http.get('api/datatypes/findPendingShared').then(function (response) {
                    delay.resolve(response.data);
                 }, function (error) {
                    delay.reject(error);
                });
                return delay.promise;
            }

        };
        return DatatypeService;
    });

/**
 * http://usejsdoc.org/
 */
angular.module('igl').factory('afterDrop', function($http, $q,userInfoService) {
	var svc = this;
	
	
	
    svc.addSectionToIg = function (id, section) {
        var delay = $q.defer();
        $http.post('api/igdocuments/'+ id+ '/section/save', section).then(function (response) {
            var saveResponse = angular.fromJson(response.data);
            delay.resolve(saveResponse);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };
    
    
    
    $scope.reOrderMessages = function(id,children) {
        var childrenMap = [];

        for (var i = 0; i <= children.length - 1; i++) {
            var childMap = {};
            childMap.id = children[i].id;
            childMap.position = children[i].position;
            messagesMap.push(childMap);
        }
        var req = {
            method: 'POST',
            url: "api/igdocuments/" + id + "/updateOrder",
            headers: {
                'Content-Type': "application/json"
            },
            data: childrenMap
        }


        var promise = $http(req)
            .success(function(data, status, headers, config) {

                return data;
            })
            .error(function(data, status, headers, config) {
                if (status === 404) {
                    console.log("Could not reach the server");
                } else if (status === 403) {
                    console.log("limited access");
                }
            });
        return promise;
    }
    
    
    
    
    
    
    



    return svc;
});

/**
 * Created by haffo on 3/9/16.
 */
'use strict';
angular.module('igl').factory('ElementUtils',
    ['$rootScope', 'ViewSettings', function ($rootScope, ViewSettings) {
        var ElementUtils = {
            filterConstraints: function (node, constraints) {
                if (constraints) {
                    return $filter('filter')(constraints, {constraintTarget: node.position + '[1]'}, true);
                }
                return null;
            },
            isRelevant: function (node, predicates) {
                if (predicates && predicates != null && predicates.length > 0) {
                    return  predicates[0].trueUsage === "R" || predicates[0].trueUsage === "RE" || predicates[0].falseUsage === "R" || predicates[0].falseUsage === "RE";
                } else {
                    return node.usage == null || !node.usage || node.usage === "R" || node.usage === "RE" || node.usage === "C";
                }
            },
            setUsage: function (node) {
                if (node.usage && node.min) {
                    if (node.usage === "R" && (node.min == 0 || node.min === "0")) {
                        node.min = 1;
                    }
                    if (node.usage === "O") {
                        node.min = 0;
                    }
                }
            },
            getNewTableLink: function (obj) {
                var link = {};
                link['id'] = obj.id;
                link['bindingIdentifier'] = obj.bindingIdentifier;
                link['bindingStrength'] = obj.bindingStrength;
                link['bindingLocation'] = obj.bindingLocation;
                return link;
            },
            getNewDatatypeLink: function (obj) {
                var link = {};
                link['id'] = obj.id;
                link['name'] = obj.name;
                link['ext'] = obj.ext;
                return link;
            },
            indexIn: function (id, collection) {
                for (var i = 0; i < collection.length; i++) {
                    if (collection[i].id === id) {
                        return i;
                    }
                }
                return -1;
            },
            getNewDatatypeLinks: function () {
                var links = [];
                if ($rootScope.addedDatatypes != null && $rootScope.addedDatatypes.length > 0) {
                    _.each($rootScope.addedDatatypes, function (datatype) {
                        if (ElementUtils.indexIn(datatype.id, $rootScope.igdocument.profile.datatypeLibrary.children) < 0) {
                            var link = ElementUtils.getNewDatatypeLink(datatype);
                            links.push(link);
                        }
                    });
                }
                return links;
            },

            getNewTableLinks: function () {
                var links = [];
                if ($rootScope.addedTables != null && $rootScope.addedTables.length > 0) {
                    _.each($rootScope.addedTables, function (table) {
                        if (ElementUtils.indexIn(table.id, $rootScope.igdocument.profile.tableLibrary.children) < 0) {
                            var link = ElementUtils.getNewTableLink(table);
                            links.push(link);
                        }
                    });
                }
                return links;
            },
            getNewSegmentLinks: function () {
                var links = [];
                if ($rootScope.addedSegments != null && $rootScope.addedSegments.length > 0) {
                    _.each($rootScope.addedSegments, function (datatype) {
                        if (ElementUtils.indexIn(datatype.id, $rootScope.igdocument.profile.segmentLibrary.children) < 0) {
                            var link = ElementUtils.getNewSegmentLink(datatype);
                            links.push(link);
                        }
                    });
                }
                return links;
            }





        };
        return ElementUtils;
    }]);

angular.module('igl').factory(
    'ExportSvc',

    function ($rootScope, $modal, $cookies) {

        var svc = this;

       
        
        svc.exportAsXMLByMessageIds = function (id, mids, xmlFormat) {
            var form = document.createElement("form");

            if (xmlFormat === 'Validation') {
                form.action = $rootScope.api('api/igdocuments/' + id + '/export/Validation/' + mids);
            } else if (xmlFormat === 'Display') {
                form.action = $rootScope.api('api/igdocuments/' + id + '/export/Display/' + mids);
            } else if (xmlFormat === 'Gazelle') {
                form.action = $rootScope.api('api/igdocuments/' + id + '/export/Gazelle/' + mids);
            }
            form.method = "POST";
            form.target = "_target";
            var csrfInput = document.createElement("input");
            csrfInput.name = "X-XSRF-TOKEN";
            csrfInput.value = $cookies['XSRF-TOKEN'];
            form.appendChild(csrfInput);
            form.style.display = 'none';
            document.body.appendChild(form);
            form.submit();
        };
        
        
        return svc;
    });

/**
 * Created by haffo on 3/9/16.
 */
'use strict';
angular.module('igl').factory('FieldService',
    ['$rootScope', 'ViewSettings', 'ElementUtils', '$filter', function ($rootScope, ViewSettings, ElementUtils,$filter) {
        var ComponentService = {
            create: function (position) {
                return {
                    id: new ObjectId().toString(),
                    type: 'field',
                    min: 0,
                    max: '0',
                    name: '',
                    usage: null,
                    minLength: 0,
                    maxLength: '0',
                    confLength: '1',
                    table: '',
                    bindingStrength: '',
                    bindingLocation: '',
                    datatype: null,
                    position: position,
                    comment: null,
                    text: null,
                    hide: false,
                    status:"DRAFT",
                    itemNo:null
                }
            },

            deleteOne: function(field, segment){
                if( segment.fields != null &&  segment.fields) {
                    var index = segment.fields.indexOf(field);
                    if (index > -1) segment.fields.splice(index, 1);
                }
                this.computePositions(segment);
            },
            deleteList: function(fields, segment){
                var that = this;
                angular.forEach(fields, function (child) {
                    that.deleteOne(child,segment);
                });
                this.computePositions(segment);
            },
            computePositions: function(segment){
                segment.fields = $filter('orderBy')(segment.fields, 'position');
                for(var i=0; i < segment.fields.length;i++){
                    segment.fields[i].position = i+1;
                }
            }
        };
        return ComponentService;
    }]);

'use strict';
angular
.module('igl')
.factory(
  'FilteringSvc',
  function($rootScope, MastermapSvc) {

    var svc = {};

    svc.filtermsgmodel = [];
    svc.filtermsgdata = [];
    svc.filtermsgsettings = [];
    svc.filtermsgtexts = [];

    svc.filterusagesmodel = [];
    svc.filterusagesdata = [];
    svc.filterusagessettings = [];
    svc.filterusagestexts = [];

    svc.getMsgmodel = function(){
      return this.filtermsgmodel;
    };

    svc.setMsgmodel = function(msgmodel){
      this.filtermsgmodel = msgmodel;
    };

    svc.getMsgdata = function(){
      return this.filtermsgdata;
    };

    svc.setMsgdata = function(msgdata){
      this.filtermsgdata = msgdata;
    };

    svc.getMsgsettings = function(){
      return this.filtermsgsettings;
    };

    svc.setMsgsettings = function(msgsettings){
      this.filtermsgsettings = msgsettings;
    };

    svc.getMsgtexts = function(){
      return this.filtermsgtexts;
    };

    svc.setMsgtexts = function(msgtexts){
      this.filtermsgtexts = msgtexts;
    };

    svc.getUsagesmodel = function(){
      return this.filterusagesmodel;
    };

    svc.setUsagesmodel = function(usagesmodel){
      this.filterusagesmodel = usagesmodel;
    };

    svc.getUsagesdata = function(){
      return this.filterusagesdata;
    };

    svc.setUsagesdata = function(usagesdata){
      this.filterusagesdata = usagesdata;
    };

    svc.getUsagessettings = function(){
      return this.filterusagessettings;
    };

    svc.setUsagessettings = function(usagessettings){
      this.filterusagessettings = usagessettings;
    };

    svc.getUsagestexts = function(){
      return this.filterusagestexts;
    };

    svc.setUsagestexts = function(usagestexts){
      this.filterusagestexts = usagestexts;
    };

    svc.getMessages = function(igdocument){
      if (igdocument !== null && igdocument !== undefined){
        var msgHolder = [];
        _.each(igdocument.profile.messages.children, function(msg) {
          msgHolder.push({"label": msg.name, "id": msg.id});
        });
        return msgHolder;
      }
      return [];
    };

    svc.getUsages = function(){
      return [{"label":"R" , "id":0},{"label":"RE" , "id":1},{"label":"O" , "id":2},{"label":"C" , "id":3},{"label":"X" , "id":4},{"label":"B" , "id":5}];
    };

    svc.getUsageById = ["R", "RE", "O", "C", "X", "B"];

    svc.getSettings = function(){
      return {
        scrollableHeight: '200px',
        scrollable: true,
        enableSearch: true,
        buttonClasses: 'btn btn-xs btn-primary',
        displayProp: 'label'
      };
    };

    svc.getTexts = function(text){
        return {
            checkAll: 'Check All',
            uncheckAll: 'Uncheck All',
            selectionCount: 'checked',
            selectionOf: '/',
            searchPlaceholder: 'Search...',
            buttonDefaultText: text,
            dynamicButtonTextSuffix: 'checked'
        };
    };

    svc.searchById = function(idKey, myArray){
        for (var i=0; i < myArray.length; i++) {
            if (myArray[i].id === idKey) {
                return i;
            }
        }
        return undefined;
    };

    svc.removeMsgFromFilter = function(msgId){
        var elt = svc.searchById(msgId, svc.getMsgmodel());
        if (elt !== undefined){
            svc.getMsgmodel().splice(elt, 1)
            }
    };

    svc.addMsgInFilter = function(name, msgId){
        if (name != undefined && msgId !== undefined) {
        //if (svc.searchById(svc.getMsgmodel(), msgId !== undefined) {
            if (_.find(svc.getMsgmodel(), function(usg) {
                    return usg.id === msgId;
                }).length !== 0) {
                    svc.getMsgmodel().push({"label": name, "id": msgId});
                }
            }
    };

    svc.updateMsgFromFilter = function(name, msgId){
        var elt = svc.searchById(msgId, svc.getMsgmodel());
        if (elt !== undefined){
            svc.getMsgmodel()[elt].label = name;
            }
    };

    svc.loadMessages = function(igdocument){
        svc.setMsgdata(svc.getMessages(igdocument));
        svc.setMsgmodel(svc.getMessages(igdocument));
        svc.setMsgsettings(svc.getSettings());
        svc.setMsgtexts(svc.getTexts("Conf. profiles"));
}
     svc.loadUsages = function(){
         svc.setUsagesdata(svc.getUsages());
         svc.setUsagesmodel(svc.getUsages());
         svc.setUsagessettings(svc.getSettings());
         svc.setUsagestexts(svc.getTexts("Usages"));
     };

    svc.showToC = function(node){
        var rst1 = false;
        _.each(svc.getMsgmodel(), function(filterElt){
            rst1 = rst1 || svc.filterByMsg(node, filterElt);
        });
        return rst1;
    };

    svc.show = function(leaf){
      if (leaf === undefined) {
        return true;
      }
      var rst1 = false;
      _.each(svc.getMsgmodel(), function(filterElt){
        rst1 = rst1 || svc.filterByMsg(leaf, filterElt);
      });

      var rst2 = false;
      _.each(svc.getUsagesmodel(), function(filterElt){
        rst2 = rst || svc.filterByUsage(leaf, filterElt);
        });

       var rst = rst1 && rst2;
       if (rst === undefined){
        rst = true;
      }
      return rst;
    };

    svc.filterByMsg = function(leaf, filterElt){
        if (leaf.id !== undefined && leaf.type !== undefined){
            if (leaf.type === "message" && leaf.id === filterElt.id) {
                return true;
            }
            if (MastermapSvc.getElement(leaf.id, leaf.type) !== undefined) {
                return (MastermapSvc.getElementByKey(leaf.id, leaf.type, "message").indexOf(filterElt.id) !== -1);
            }
        }
        return false;
    }

    svc.filterByUsage = function(leaf, filterElt){
        if (MastermapSvc.getElement(leaf.id, leaf.type) !== undefined){
            if (MastermapSvc.getUsage(leaf.id, leaf.type) !== undefined){
                if (MastermapSvc.getElementByKey(leaf.id, leaf.type, "usage").length === 0) {
                    return true;
                }
                if (leaf.type === "message"){
                    return (MastermapSvc.getUsage(leaf.id, leaf.type).indexOf(svc.getUsageById[filterElt.id]) !== -1);
                }

                if (leaf.type === "table"){
                    return true;
                }
                if (leaf.type === "subcomponent"){
                    return (MastermapSvc.getUsage(leaf.id, "component").indexOf(filterElt) !== -1);
                } else {
                    return (MastermapSvc.getUsage(leaf.id, leaf.type).indexOf(filterElt) !== -1);
                }
            }
        }
    }

  svc.showInnerHtml = function(node, parentNode){
          var validUsages = [];
          _.each(svc.getUsagesmodel(), function(filterElt){
            validUsages.push(svc.getUsageById[filterElt.id]);
            });

          return svc.filterByUsageWithParent(node, parentNode, validUsages);
  }

    svc.filterByUsageWithParent = function(node, parentNode, filter){
            if (node.type === "subcomponent"){
                var showElt = svc.filterByUsage({"id":node.id, "type":"component"}, filter);
            } else {
                var showElt = svc.filterByUsage(node, filter);
            }
            var showParents = svc.filterByUsage(parentNode, filter);
            if (showElt && showParents !== undefined) {
                return showElt && showParents;
            } else {
                return true;
            }
    }

    svc.isUnused = function(node){
        return false;
//        if (MastermapSvc.getElement(node.id, node.type) !== undefined){
//            if (node.type == "datatype") {
//                return (MastermapSvc.getElementByKey(node.id, node.type, "field").length === 0) &&
//                (MastermapSvc.getElementByKey(node.id, node.type, "datatype").length === 0);
//            } else if (node.type == "table") {
//                return (MastermapSvc.getElementByKey(node.id, node.type, "field").length === 0) &&
//                (MastermapSvc.getElementByKey(node.id, node.type, "datatype").length === 0);
//            } else if (node.type == "component") {
//                return (MastermapSvc.getElementByKey(node.id, node.type, "datatype").length === 0);
//            } else if (node.type == "field") {
//                return (MastermapSvc.getElementByKey(node.id, node.type, "segment").length === 0);
//            } else if (node.type == "segment") {
//                return (MastermapSvc.getElementByKey(node.id, node.type, "segmentRef").length === 0);
//            } else if (node.type == "group" | node.type == "segmentRef") {
//                 return (MastermapSvc.getElementByKey(node.id, node.type, "field").length === 0) &&
//                 (MastermapSvc.getElementByKey(node.id, node.type, "datatype").length === 0);
//            } else if (node.type == "message") {
//                 return (MastermapSvc.getElementByKey(node.id, node.type, "profile").length === 0);
//            } else if (node.type == "profile") {
//                 return (MastermapSvc.getElementByKey(node.id, node.type, "ig").length === 0);
//            }
//        } else {
//            return false;
//        }
    }

    return svc;
  });

angular.module('igl')
		.factory('FormsSelectSvc', function($rootScope, $timeout, ngTreetableParams, DatatypeService) {

	var svc = this;

	var tableWidth;
	var scrollbarWidth;
	var csWidth;
	var predWidth;
	var commentWidth;
	svc.datatypesParams;

    svc.selectDocumentMetaData = function () {
      $scope.subview = "EditDocumentMetadata.html";
      $scope.loadingSelection = true;
      $timeout(
        function () {
          $scope.loadingSelection = false;
        }, 100);
    };

		svc.selectDatatype = function (datatype) {
        if (datatype && datatype != null) {
            $rootScope.datatype = datatype;
                    tableWidth = null;
                    scrollbarWidth = $rootScope.getScrollbarWidth();
                    csWidth = getDynamicWidth(1, 3, 890);
                    predWidth = getDynamicWidth(1, 3, 890);
                    commentWidth = getDynamicWidth(1, 3, 890);
        }
        return "EditDatatypes.html";
    };

//    svc.datatypesParams = new ngTreetableParams({
//        getNodes: function (parent) {
//            return DatatypeService.getNodes(parent);
//        },
//        getTemplate: function (node) {
//            return DatatypeService.getTemplate(node);
//        }
//    });

    function getDynamicWidth(a, b, otherColumsWidth) {
        var tableWidth = getTableWidth();
        if (tableWidth > 0) {
            var left = tableWidth - otherColumsWidth;
            return {"width": a * parseInt(left / b) + "px"};
        }
        return "";
    };

    function getTableWidth() {
        if (tableWidth === null || tableWidth == 0) {
            tableWidth = $("#nodeDetailsPanel").width();
        }
        return tableWidth;
    };

	return svc;
})

/**
 * Created by haffo on 3/9/16.
 */
'use strict';
angular.module('igl').factory('IdleService',
    function ($http) {
        var IdleService = {
            keepAlive: function () {
                 return $http.get(
                    'api/session/keepAlive');
            }
        };
        return IdleService;
    });

/**
 * Created by haffo on 3/9/16.
 */
'use strict';
angular.module('igl').factory('IgDocumentMapping',
    ['$rootScope', 'ViewSettings', '$q', 'userInfoService', '$http', 'StorageService', function ($rootScope, ViewSettings, $q, userInfoService, $http,StorageService) {
        var IgDocumentMapping = {
            createMapping : function(){

            }
        };
        return IgDocumentMapping;
    }]);

/**
 * Created by haffo on 3/9/16.
 */
'use strict';
angular.module('igl').factory('IgDocumentService', function($rootScope, ViewSettings, $q, userInfoService, $http, StorageService, $cookies, blockUI) {
    var IgDocumentService = {
        save: function(igDocument) {
            $rootScope.saved = false;
            var delay = $q.defer();
            var changes = angular.toJson([]);
            igDocument.accountId = userInfoService.getAccountID();
            var data = angular.fromJson({ "changes": changes, "igDocument": igDocument });
            $http.post('api/igdocuments/save', data).then(function(response) {
                var saveResponse = angular.fromJson(response.data);
                igDocument.metaData.date = saveResponse.date;
                igDocument.metaData.version = saveResponse.version;
                $rootScope.saved = true;
                delay.resolve(saveResponse);
            }, function(error) {
                delay.reject(error);
                $rootScope.saved = false;
            });
            return delay.promise;
        },
        exportAs: function(igDocument, format) {
            blockUI.start();
            var form = document.createElement("form");
            form.action = $rootScope.api('api/igdocuments/' + igDocument.id + '/export/' + format);
            form.method = "POST";
            form.target = "_blank";
            var csrfInput = document.createElement("input");
            csrfInput.name = "X-XSRF-TOKEN";
            csrfInput.value = $cookies['XSRF-TOKEN'];
            form.appendChild(csrfInput);
            form.style.display = 'none';
            document.body.appendChild(form);
            form.submit();
            blockUI.stop();
        },

        exportAsWithLayout: function(igDocument, format, layout) {
            blockUI.start();
            var form = document.createElement("form");
            form.action = $rootScope.api('api/igdocuments/' + igDocument.id + '/export/' + format + '/' +layout);
            form.method = "POST";
            form.target = "_blank";
            var layoutParameter = document.createElement("input");
            layoutParameter.type = "text";
            layoutParameter.name = "layout";
            layoutParameter.value = layout;
            form.appendChild(layoutParameter);
            var csrfInput = document.createElement("input");
            csrfInput.name = "X-XSRF-TOKEN";
            csrfInput.value = $cookies['XSRF-TOKEN'];
            form.appendChild(csrfInput);
            form.style.display = 'none';
            document.body.appendChild(form);
            form.submit();
            blockUI.stop();
        },

        addMessage: function(igId, child) {
            var delay = $q.defer();
            $http.post('api/igdocuments/' + igId + '/addMessage', child).then(function(response) {
                var link = angular.fromJson(response.data);
                delay.resolve(link);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        addMessages: function(igId, childrenIds) {
            var delay = $q.defer();
            $http.post('api/igdocuments/' + igId + '/addMessages', childrenIds).then(function(response) {
                //var link = angular.fromJson(response.data);
                delay.resolve(true);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        findAndAddMessages: function(igId, event) {
            var delay = $q.defer();
            // var namesAndscopeAndVersion = {
            //     "name": event.name,
            //     "parentStructId": event.parentStructId,
            //     "scope": event.scope,
            //     "hl7Version": event.hl7Version
            // };
            $http.post('api/igdocuments/' + igId + '/findAndAddMessages', angular.toJson(event)).then(function(response) {
                var msgs = angular.fromJson(response.data);
                delay.resolve(msgs);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },

        deleteMessage: function(igId, messageId) {
            var delay = $q.defer();
            $http.post('api/igdocuments/' + igId + '/deleteMessage/' + messageId).then(function(response) {
                var res = angular.fromJson(response.data);
                delay.resolve(res);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        saveMetadata: function(id, metaData) {
            var delay = $q.defer();
            $http.post('api/igdocuments/' + id + '/metadata/save', metaData).then(function(response) {
                var saveResponse = angular.fromJson(response.data);
                delay.resolve(saveResponse);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        getIgDocumentsByScopesAndVersion: function(scopes, hl7Version) {
            console.log("igdocuments/findByScopesAndVersion scopes=" + scopes + " hl7Version=" + hl7Version);
            var scopesAndVersion = {
                "scopes": scopes,
                "hl7Version": hl7Version
            };
            return $http.post(
                    'api/igdocuments/findByScopesAndVersion', angular.toJson(scopesAndVersion))
                .then(function(response) {
                    console.log("getIgDocumentsByScopesAndVersion response size=" + response.data.length);
                    return angular.fromJson(response.data);
                });
        },
        getOne: function(id) {
            var delay = $q.defer();
            $http.get('api/igdocuments/' + id).then(function(response) {
                var igDocument = angular.fromJson(response.data);
                delay.resolve(igDocument);
            }, function(error) {
                delay.reject(error);
            });

            return delay.promise;
        },
        share: function(igDocId, shareParticipantIds) {
            var delay = $q.defer();
            $http.post('api/igdocuments/' + igDocId + '/share', shareParticipantIds).then(function(response) {
                delay.resolve(response.data);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        unshare: function(igDocId, participantId) {
            var delay = $q.defer();
            $http.post('api/igdocuments/' + igDocId + '/unshare', participantId).then(function(response) {
                delay.resolve(response.data);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        saveProfileComponent: function(id, pc) {
            var delay = $q.defer();
            $http.post('api/igdocuments/' + id + '/profile/profilecomponent/save', pc).then(function(response) {
                var saveResponse = angular.fromJson(response.data);
                delay.resolve(saveResponse);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;

        },
        updateDate: function(igdocument) {
            var delay = $q.defer();
            $http.post('api/igdocuments/' + igdocument.id + '/updateDate').then(function(response) {
                var resu = response.data;
                igdocument.dateUpdated = resu;
                delay.resolve(resu);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        }
    };
    return IgDocumentService;
});

'use strict';
angular.module('igl').service('MastermapSvc', function($rootScope) {
    var svc = {};
    svc.mastermap = [];
    svc.segmentLibrary = {};
    svc.datatypeLibrary = {};
    svc.tableLibrary = {};
    svc.parseIg = function(igdocument) {
        if (igdocument !== null && igdocument !== undefined) {
            svc.addIG(igdocument);
            return svc.getMastermap();
        }
        return [];
    };
    svc.getMastermap = function() {
        return this.mastermap;
    };
    svc.getSegmentLibrary = function() {
        return this.segmentLibrary;
    };
    svc.setSegmentLibrary = function(segmentLibrary) {
        this.segmentLibrary = segmentLibrary;
    };
    svc.getDatatypeLibrary = function() {
        return this.datatypeLibrary;
    };
    svc.setDatatypeLibrary = function(datatypeLibrary) {
        this.datatypeLibrary = datatypeLibrary;
    };
    svc.getTableLibrary = function() {
        return this.tableLibrary;
    };
    svc.setTableLibrary = function(tableLibrary) {
        this.tableLibrary = tableLibrary;
    };
    svc.addComponent = function(c, parent) {
        if (c !== undefined && c !== null) {
            svc.createMMElement(c.id, "component");
            svc.addParentsId(c.id, "component", parent);
            if (svc.getElementByKey(c.id, "component", "usage") !==
                undefined) {
                svc.setElement(c.id, "component", "usage", [c[
                    "usage"]]);
            }
            if (c.datatype !== undefined && svc.getDatatypeLibrary()[
                c.datatype] !== null) {
                svc.addDatatypeObject(svc.getDatatypeLibrary()[c.datatype],
                    parent.concat([
                        [c.id, "component"]
                    ]));
            }
            if (c.table !== undefined && svc.getTableLibrary()[c.table] !==
                null) {
                svc.addValueSetObject(svc.getTableLibrary()[c.table],
                    parent.concat([
                        [c.id, "component"]
                    ]));
            }
        }
    };
    svc.deleteComponent = function(componentId) {
        svc.removeMastermapElt(componentId, "component");
    }
    svc.addValueSetId = function(tableId, parent) {
        if (tableId !== undefined && tableId !== null && tableId !==
            "") {
            svc.createMMElement(tableId, "table");
            svc.addParentsId(tableId, "table", parent);
            //            var table = svc.getTableLibrary()[tableId];
            //            if (table !== undefined){
            //                _.each(table.codes, function(c) {
            //                    svc.addCodes(c, parent.concat([[table.id, 'table']]));
            //                });
            //            } else {
            //                // Table not found
            //                // console.log("!!! => table " + tableId + " not found in library");
            //            }
        }
    };
    svc.addValueSetObject = function(table, parent) {
        if (table !== undefined && table !== null) {
            svc.createMMElement(table.id, "table");
            svc.addParentsId(table.id, "table", parent);
            //            _.each(table.codes, function(c) {
            //                svc.addCodes(c, parent.concat([[table.id, 'table']]));
            //            });
        };
    };
    svc.deleteValueset = function(tableId) {
        svc.removeMastermapElt(tableId, "table");
    }
    svc.addCodes = function(code, parent) {
        svc.createMMElement(code.id, "code");
        svc.addParentsId(code.id, "code", parent);
    }
    svc.addDatatypeId = function(datatypeId, parent) {
        // Add id then check if in library
        if (datatypeId !== undefined && datatypeId !== null &&
            datatypeId !== "") {
            svc.createMMElement(datatypeId, "datatype");
            svc.addParentsId(datatypeId, "datatype", parent);
            var dt = svc.getDatatypeLibrary()[datatypeId];
            if (dt !== undefined && dt !== null && dt !== "") {
                _.each(dt.components, function(c) {
                    svc.addComponent(c, parent.concat([
                        [dt.id, "datatype"]
                    ]));
                });
            }
        }
    }
    svc.addDatatypeObject = function(dtLink, parent) {
        if (dtLink !== undefined && dtLink !== null) {
            svc.createMMElement(dtLink.id, "datatype");
            svc.addParentsId(dtLink.id, "datatype", parent);
            var dt = svc.getDatatypeLibrary()[dtLink.id];
            if (dt !== undefined && dt !== null && dt !== "") {
                _.each(dt.components, function(c) {
                    svc.addComponent(c, parent.concat([
                        [dtLink.id, "datatype"]
                    ]));
                });
            }
        }
    }
    svc.deleteDatatype = function(datatypeId) {
        svc.removeMastermapElt(datatypeId, "datatype");
    }
    svc.deleteElementChildren = function(elementId, elementType, childrenToBeRemoved, childrenType) {
        svc.removeId(childrenToBeRemoved, svc.getElementByKey(elementId, elementType, childrenType));
    }
    svc.addFieldObject = function(field, parent) {
        if (field !== undefined && field !== null) {
            svc.createMMElement(field.id, "field");
            svc.addParentsId(field.id, "field", parent);
            svc.setElement(field.id, "field", "usage", [field[
                "usage"]]);
            svc.addValueSetObject(field.table, parent.concat([
                [field.id, "field"]
            ]));
            svc.addDatatypeObject(field.datatype, parent.concat([
                [field.id, "field"]
            ]));
        }
    }
    svc.addSegmentId = function(segmentId, parent) {
        // Add the id in mastermap when given. Then check if object can be found in segment library.
        if (segmentId !== undefined && segmentId !== null &&
            segmentId !== "") {
            svc.createMMElement(segmentId, "segment");
            svc.addParentsId(segmentId, "segment", parent);
            var segment = svc.getSegmentLibrary()[segmentId];
            if (segment !== undefined && segment !== null) {
                _.each(segment.fields, function(field) {
                    svc.addFieldObject(field, parent.concat(
                        [
                            [segmentId, "segment"]
                        ]));
                });
            }
        }
    }
    svc.addSegmentObject = function(segmentLink, parent) {
        console.log(segmentLink);
        if (segmentLink !== undefined && segmentLink !== null) {
            svc.createMMElement(segmentLink.id, "segment");
            svc.addParentsId(segmentLink.id, "segment", parent);
            var segment = svc.getSegmentLibrary()[segmentLink.id];
            if (segment !== undefined && segment !== null) {
                _.each(segment.fields, function(f) {
                    svc.addFieldObject(f, parent.concat([
                        [segmentLink.id, "segment"]
                    ]));
                });
            }
        }
    }
    svc.deleteSegment = function(segmentId) {
        svc.removeMastermapElt(segmentId, "segment");
    }
    svc.deleteMessage = function(messageId) {
        svc.removeMastermapElt(messageId, "message");
    }
    svc.addMessageObject = function(message, parent) {
        svc.createMMElement(message.id, "message");
        svc.addParentsId(message.id, "message", parent);
        var tmp = svc.getElementByKey(message.id, "message",
            "usage");
        _.each(message.children, function(segrefOrGroup) {
            if (segrefOrGroup.type === "segmentRef") {
                svc.addSegmentRef(segrefOrGroup, parent.concat(
                    [
                        [message.id, 'message']
                    ]));
            } else {
                svc.addGroup(segrefOrGroup, parent.concat([
                    [message.id, 'message']
                ]));
            }
            svc.addInArray(segrefOrGroup.usage, tmp);
        });
        svc.getElement(message.id, "message").usage = tmp;
    }
    svc.addSegmentRef = function(segmentRef, parent) {
        if (segmentRef !== undefined && segmentRef !== null) {
            if (segmentRef.id !== undefined && segmentRef.id !==
                null) {
                svc.createMMElement(segmentRef.id, "segmentRef");
                svc.addParentsId(segmentRef.id, "segmentRef",
                    parent);
                svc.setElement(segmentRef.id, "segmentRef", "usage", [
                    segmentRef["usage"]
                ]);
                if (segmentRef.ref.id !== undefined && segmentRef.ref
                    .id !== null) {
                    svc.addSegmentId(segmentRef.ref.id, parent.concat(
                        [
                            [segmentRef.id, "segmentRef"]
                        ]));
                }
            }
        }
    }
    svc.deleteSegmentRef = function(segmentRefId) {
        svc.removeMastermapElt(segmentRefId, "segmentRef");
    }
    svc.addGroup = function(group, parent) {
        if (group !== undefined && group !== null) {
            svc.createMMElement(group.id, "group");
            svc.addParentsId(group.id, "group", parent);
            if (group["usage"] !== undefined && group["usage"] !==
                null && group["usage"] !== "") {
                svc.setElement(group.id, "group", "usage", [group[
                    "usage"]]);
            }
            _.each(group.children, function(n) {
                if (n.type === "segmentRef") {
                    svc.addSegmentRef(n, parent.concat([
                        [group.id, 'group']
                    ]));
                } else {
                    svc.addGroup(n, parent.concat([
                        [group.id, 'group']
                    ]));
                }
            });
        }
    }
    svc.addIG = function(igdocument) {
        //console.log("Creating mastermap\nprocessing IG : " + igdocument.id);
        svc.mastermap = [];

        var profile = igdocument.profile;

        // Setting libraries
        svc.createSegmentLibrary($rootScope.segmentsMap);
        svc.createDatatypeLibrary($rootScope.datatypesMap);
        svc.createTableLibrary($rootScope.tablesMap);

        // Initializing mastermap
        _.each(svc.getTableLibrary(), function(tbl) {
            svc.createMMElement(tbl.id, "table");
        });
        _.each(svc.getDatatypeLibrary(), function(dt) {
            //console.log(dt);
            svc.createMMElement(dt.id, "datatype");
        });
        _.each(svc.getSegmentLibrary(), function(sgt) {

            //console.log(sgt);
            svc.createMMElement(sgt.id, "segment");
        });

        // Adding reference to IG document
        svc.createMMElement(igdocument.id, "ig");
        svc.addParentsId(igdocument.id, "ig", [
            [igdocument.id, "ig"]
        ]);

        // Adding reference to profile
        var parents = [
            [igdocument.id, "ig"]
        ];
        svc.createMMElement(profile.id, "profile");
        svc.addParentsId(profile.id, "profile", parent);

        // Adding message content in mastermap
        parents = parents.concat([
            [profile.id, "profile"]
        ]);
        _.each(profile.messages.children, function(msg) {
            svc.addMessageObject(msg, parents);
        });

        //        try {
        //            console.log("mm");
        //            console.log(svc.getMastermap());
        //        } catch (err) {
        //                console.log(err);
        //        }
    }
    svc.deleteIgdocument = function(igdocumentId) {
        svc.removeMastermapElt(igdocumentId, "ig");
    }
    svc.deleteProfile = function(profileId) {
        svc.removeMastermapElt(profileId, "profile");
    }
    svc.addParentsId = function(elementId, elementType, parentsList) {
        // Element refers to self
//        svc.setElement(elementId, elementType, elementType, svc.getElementByKey(
//            elementId, elementType, elementType).concat(
//            elementId));
        _.each(parentsList, function(parent) {
            var parentId = parent[0];
            var parentType = parent[1];
            //Add parents reference in element if not present
            if (svc.getElementByKey(elementId, elementType,
            parentType) !== undefined || svc.getElementByKey(elementId,
            elementType, parentType) !== null) {
                if (svc.getElementByKey(elementId, elementType,
                    parentType).indexOf(parentId) === -1) {
                    svc.setElement(elementId, elementType,
                        parentType, svc.getElementByKey(
                            elementId, elementType,
                            parentType).concat(parentId));
                }
            }
//            // Add element reference in parents if not already present
//            if (svc.getElementByKey(parentId, parentType,
//                elementType).indexOf(elementId) === -1) {
//                svc.setElement(parentId, parentType,
//                    elementType, svc.getElementByKey(
//                        parentId, parentType,
//                        elementType).concat(elementId));
//            }
        });
    }
    svc.createMMElement = function(id, type) {
        if (id !== null && id !== undefined && svc.getElement(id, type) === undefined) {
            var eltColl = new Object();
            eltColl["ig"] = [];
            eltColl["profile"] = [];
            eltColl["message"] = [];
            eltColl["field"] = [];
            eltColl["segment"] = [];
            eltColl["segmentRef"] = [];
            eltColl["group"] = [];
            eltColl["table"] = [];
            eltColl["datatype"] = [];
            eltColl["component"] = [];
            eltColl["code"] = [];
            eltColl["usage"] = [];
            eltColl["scope"] = [];
            eltColl["type"] = type;
            eltColl["id"] = id;
            svc.mastermap[id.concat(type)] = eltColl;
        }
        else {
        //console.log("null id")
        }
    }
    svc.removeMastermapElt = function(toBeRemovedId, toBeRemovedType) {
        // Collects elements about elements to delete
        var toBeRemovedInfo = svc.getElement(toBeRemovedId,
            toBeRemovedType);
        var areas = ["ig", "profile", "message", "field", "segment",
            "segmentRef", "group", "table", "datatype",
            "component", "code"
        ];
        // Remove element in parents
        _.each(areas, function(area) {
            if (toBeRemovedInfo[area] !== null || toBeRemovedInfo[area] !== undefined){
                _.each(toBeRemovedInfo[area], function(idParent) {
                    svc.removeId(idParent, svc.getElementByKey(
                        idParent, area,
                        toBeRemovedType));
                });
            }
        });
        // Remove element in mastermap
        svc.removeId(toBeRemovedId.concat(toBeRemovedType), svc.getMastermap());
    }
    svc.createSegmentLibrary = function(segmentsLibrary) {
        svc.segmentLibrary = segmentsLibrary;
    }
    svc.createTableLibrary = function(tablesLibrary) {
        svc.tableLibrary = tablesLibrary;
    }
    svc.createDatatypeLibrary = function(datatypesLibrary) {
        svc.datatypeLibrary = datatypesLibrary;
    }
    svc.getElement = function(id, type) {
        if (id !== null || id !== undefined) {
            return svc.mastermap[id.concat(type)];
        } else {
            //console.log(type);
            return null;
        }
    }
    svc.getElementByKey = function(id, type, key) {
        return svc.getElement(id, type)[key];
    }
    svc.setElement = function(id, type, key, value) {
        svc.mastermap[id.concat(type)][key] = value;
    }
    svc.removeId = function(idKey, myArray) {
    if (idKey !== null || idKey !== undefined || myArray !== null || myArray !== undefined) {
            var index = myArray.indexOf(idKey);
            if (index !== -1) {
                myArray.splice(index, 1);
            }
        }
    };
    svc.searchById = function(idKey, myArray) {
        for (var i = 0; i < myArray.length; i++) {
            if (myArray[i].id === idKey) {
                return i;
            }
        }
        return undefined;
    };
    svc.addInArray = function(elt, myArray) {
        if (myArray.indexOf(elt) === -1) {
            myArray.push(elt);
        }
    }
    svc.getUsage = function(id, type) {
        var item = svc.getElement(id, type);
        if (item !== undefined) {
            if (type === "message") {
                // usage is union of first level usages of segmentRefs or groups.
                // usage is union of first level usages of segmentRefs or groups.
                return svc.getElementByKey(id, type, "usage");
            }
            if (type === "field" || type === "segmentRef" || type ===
                "group" || type === "component") {
                // usage is set in element
                return svc.getElementByKey(id, type, "usage");
            }
            if (type === "segment") {
                var sgt = svc.getElement(id, type);
                var rst = [];
                var usg = "";
                _.each(sgt["segmentRef"], function(elt) {
                    usg = svc.getElementByKey(elt,
                        "segmentRef", "usage");
                    if (rst.indexOf(usg) === -1) rst.push(
                        usg);
                });
                return rst;
            }
            if (type === "table") {
                var tbl = svc.getElement(id, type);
                var rst = [];
                _.each(tbl["segment"], function(elt) {
                    var usgs = svc.getUsage(elt, "segment");
                    _.each(usgs, function(usg) {
                        if (rst.indexOf(usg) === -1) {
                            rst.push(usg);
                        }
                    });
                });
                _.each(tbl["datatype"], function(elt) {
                    var usgs = svc.getUsage(elt, "datatype");
                    _.each(usgs, function(usg) {
                        if (rst.indexOf(usg) === -1) {
                            rst.push(usg);
                        }
                    });
                });
                return rst;
            }
            if (type === "datatype") {
                var dt = svc.getElement(id, type);
                var rst = [];
                var usg = "";
                _.each(dt["segment"], function(elt) {
                    var usgs = svc.getUsage(elt, "segment");
                    _.each(usgs, function(usg) {
                        if (rst.indexOf(usg) === -1) {
                            rst.push(usg);
                        }
                    });
                });
                _.each(dt["datatype"], function(elt) {
                    var usgs = svc.getUsage(elt, "datatype");
                    _.each(usgs, function(usg) {
                        if (rst.indexOf(usg) === -1) {
                            rst.push(usg);
                        }
                    });
                });
                return rst;
            }
            if (type === "code") {
                var cd = svc.getElement(id, type);
                var rst = [];
                var usg = "";
                _.each(cd["table"], function(elt) {
                    var usgs = svc.getUsage(elt, "table");
                    _.each(usgs, function(usg) {
                        if (rst.indexOf(usg) === -1) {
                            rst.push(usg);
                        }
                    });
                });
                return rst;
            }
        }
    }
    return svc;
});
'use strict';

/**
 * @ngdoc function
 * @description
 * 
 * This service enables the MessageEvents structure to be accessed from both the
 * controllers of the Create IG Dialog.
 */

angular.module('igl').factory('MessageEventsSvc', function($http) {

    var svc = this;

    //	svc.messagesByVersion = {};

    //	svc.state = {};
    //	
    //	svc.getState = function() {
    //		return svc.state; 
    //	}
    //	
    //	svc.putState = function(state) {
    //		svc.state = state; 
    //	}

    //	svc.getMessageEvents = function(hl7Version) {
    //		return new ngTreetableParams( {
    //			getNodes: function(parent) {
    //				return parent ? parent.children : mes(hl7Version)
    //			},
    //	        getTemplate: function(node) {
    //	            return 'MessageEventsNode.html';
    //	        },
    //	        options: {
    //	            onNodeExpand: function() {
    //	                console.log('A node was expanded!');
    //	            }
    //	        }
    //		});
    //	};


    svc.getMessageEvents = function(hl7Version) {
        return $http.post(
            'api/igdocuments/messageListByVersion', hl7Version).then(function(response) {
            var messageEvents = angular.fromJson(response.data);
                messageEvents =  _.filter(messageEvents, function(messageEvent){
                    return messageEvent.children && messageEvent.children !== null && messageEvent.children.length > 0;
                });


            return _.sortBy(messageEvents, function(messageEvent) {
                return messageEvent.name;
            });
        });
    };

    return svc;
});
/**
 * Created by haffo on 3/9/16.
 */
'use strict';
angular.module('igl').factory('MessageService',
    function($rootScope, ViewSettings, ElementUtils, $q, $http, FilteringSvc, SegmentLibrarySvc, TableLibrarySvc, DatatypeLibrarySvc) {
        var MessageService = {
            save: function(message) {
                var delay = $q.defer();
                $http.post('api/messages/save', message, {
                    headers: { 'Content-Type': 'application/json' }
                }).then(function(response) {
                    var saved = angular.fromJson(response.data);
                    delay.resolve(saved);
                    return saved;
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            getNodes: function(parent, root) {
                if (!parent || parent == null) {
                    return root.children;
                } else {
                    return parent.children;
                }
            },
            getTemplate: function(node, root) {
                if (ViewSettings.tableReadonly) {
                    if (node.obj.type === 'segmentRef') {
                        return 'MessageSegmentRefReadTree.html';
                    } else if (node.obj.type === 'group') {
                        return 'MessageGroupReadTree.html';
                    } else if (node.obj.type === 'field') {
                        return 'MessageFieldViewTree.html';
                    } else if (node.obj.type === 'component') {
                        return 'MessageComponentViewTree.html';
                    } else {
                        return 'MessageReadTree.html';
                    }
                } else {

                    if (node.obj.type === 'segmentRef') {
                        return 'MessageSegmentRefEditTree.html';
                    } else if (node.obj.type === 'group') {
                        return 'MessageGroupEditTree.html';
                    } else if (node.obj.type === 'field') {
                        return 'MessageFieldViewTree.html';
                    } else if (node.obj.type === 'component') {
                        return 'MessageComponentViewTree.html';
                    } else {
                        return 'MessageEditTree.html';
                    }
                }
            },
            merge: function(to, from) {
                to = _.extend(to, from);
                //                to.accountID = from.accountID;
                //                to.children = from.children;
                //                to.comment = from.comment;
                //                to.conformanceStatements = from.conformanceStatements;
                //                to.date = from.date;
                //                to.description = from.description;
                //                to.event = from.event;
                //                to.hl7Version = from.hl7Version;
                //                to.id = from.id;
                //                to.identifier = from.identifier;
                //                to.libIds = from.libIds;
                //                to.messageID = from.messageID;
                //                to.messageType = from.messageType;
                //                to.name = from.name;
                //                to.participants = from.participants;
                //                to.position = from.position;
                //                to.predicates = from.predicates;
                //                to.scope = from.scope;
                //                to.status = from.status;
                //                to.structID = from.structID;
                //                to.type = from.type;
                //                to.usageNote = from.usageNote;
                //                to.version = from.version;
                return to;
            },

            indexIn: function(id, collection) {
                for (var i = 0; i < collection.length; i++) {
                    if (collection[i].id === id) {
                        return i;
                    }
                }
                return -1;
            },


            completeSave: function() {
                $rootScope.addedDatatypes = [];
                $rootScope.addedTables = [];
                $rootScope.addedSegments = [];
                $rootScope.msg().text = "messageSaved";
                $rootScope.msg().type = "success";
                $rootScope.msg().show = true;
                $rootScope.processElement($rootScope.message);
                $rootScope.clearChanges();
                $rootScope.messageTree = null;
                $rootScope.processMessageTree($rootScope.message);
            },


            saveNewElements: function() {
                var delay = $q.defer();
                var links = ElementUtils.getNewSegmentLinks();
                if (links.length > 0) {
                    SegmentLibrarySvc.addChildren($rootScope.igdocument.profile.segmentLibrary.id, links).then(function() {
                        $rootScope.igdocument.profile.segmentLibrary.children = $rootScope.igdocument.profile.segmentLibrary.children.concat(links);
                        _.each($rootScope.addedSegments, function(segment) {
                            if (ElementUtils.indexIn(segment.id, $rootScope.segments) < 0) {
                                $rootScope.segments.push(segment);
                            }
                        });
                        var datatypeLinks = ElementUtils.getNewDatatypeLinks();
                        if (datatypeLinks.length > 0) {
                            DatatypeLibrarySvc.addChildren($rootScope.igdocument.profile.datatypeLibrary.id, datatypeLinks).then(function() {
                                $rootScope.igdocument.profile.datatypeLibrary.children = $rootScope.igdocument.profile.datatypeLibrary.children.concat(datatypeLinks);
                                _.each($rootScope.addedDatatypes, function(datatype) {
                                    if (ElementUtils.indexIn(datatype.id, $rootScope.datatypes) < 0) {
                                        $rootScope.datatypes.push(datatype);
                                    }
                                });
                                var tableLinks = ElementUtils.getNewTableLinks();
                                if (tableLinks.length > 0) {
                                    TableLibrarySvc.addChildren($rootScope.igdocument.profile.tableLibrary.id, tableLinks).then(function() {
                                        $rootScope.igdocument.profile.tableLibrary.children = $rootScope.igdocument.profile.tableLibrary.children.concat(tableLinks);
                                        _.each($rootScope.addedTables, function(table) {
                                            if (ElementUtils.indexIn(table.id, $rootScope.tables) < 0) {
                                                $rootScope.tables.push(table);
                                            }
                                        });
                                        MessageService.completeSave();
                                        delay.resolve(true);
                                    }, function(error) {
                                        delay.reject(error);
                                    });
                                } else {
                                    MessageService.completeSave();
                                    delay.resolve(true);
                                }
                            }, function(error) {
                                delay.reject(error);
                            });
                        } else {
                            MessageService.completeSave();
                            delay.resolve(true);
                        }
                    }, function(error) {
                        delay.reject(error);
                    });
                } else {
                    MessageService.completeSave();
                    delay.resolve(true);
                }
                return delay.promise;
            },


            reset: function() {
                if ($rootScope.addedSegments != null && $rootScope.addedSegments.length > 0) {
                    _.each($rootScope.addedSegments, function(segment) {
                        delete $rootScope.segmentsMap[segment.id];
                    });
                }
                if ($rootScope.addedDatatypes != null && $rootScope.addedDatatypes.length > 0) {
                    _.each($rootScope.addedDatatypes, function(datatype) {
                        delete $rootScope.datatypesMap[datatype.id];
                    });
                }
                if ($rootScope.addedTables != null && $rootScope.addedTables.length > 0) {
                    _.each($rootScope.addedTables, function(table) {
                        delete $rootScope.tablesMap[table.id];
                    });
                }
                $rootScope.message = angular.copy($rootScope.messagesMap[$rootScope.message.id]);
            },

            findIndex: function(id) {
                for (var i = 0; i < $rootScope.igdocument.profile.messages.children.length; i++) {
                    if ($rootScope.igdocument.profile.messages.children[i].id === id) {
                        return i;
                    }
                }
                return -1;
            },
            updatePosition: function(children, old_index, new_index) {
                if (new_index >= children.length) {

                    var k = new_index - children.length;
                    while ((k--) + 1) {
                        children.push(undefined);
                    }
                }
                children.splice(new_index, 0, children.splice(old_index, 1)[0]);

                angular.forEach(children, function(child) {
                    child.position = children.indexOf(child) + 1;

                });
            },
            addSegToPath: function(path, message, segment, oldPos, newPos) {



                if (path.length === 1) {
                    if (message.children) {
                        console.log(message);
                        (message.children[path[0] - 1]).children.push(segment);
                        console.log((message.children[path[0] - 1]).children);

                        MessageService.updatePosition((message.children[path[0] - 1]).children, oldPos, newPos);

                    }
                } else {
                    var x = angular.copy(path);
                    path.splice(0, 1);
                    //message.children[x[0] - 1]
                    MessageService.addSegToPath(path, message.children[x[0] - 1], segment, oldPos, newPos);

                }
                return message;
            },
            deleteSegFromPath: function(path, message) {
                var delay = $q.defer();

                if (path.length === 1) {
                    if (message.children) {

                        message.children.splice(path[0] - 1, 1);
                        $rootScope.parentGroup = message;
                    }
                } else {

                    var x = angular.copy(path);
                    path.splice(0, 1);
                    //message.children[x[0] - 1]
                    MessageService.deleteSegFromPath(path, message.children[x[0] - 1]);


                }
                delay.resolve(true);
                return delay.promise;

            },
            findParentByPath: function(path, message) {
                var delay = $q.defer();

                if (path.length === 1) {
                    if (message.children) {
                        $rootScope.segParent = message;


                    }
                } else {
                    var x = angular.copy(path);
                    path.splice(0, 1);
                    //message.children[x[0] - 1]
                    MessageService.findParentByPath(path, message.children[x[0] - 1]);

                }
                delay.resolve(true);
                return delay.promise;
            },

            updateSegmentBinding: function(segmentBindingUpdateParameterList) {
                var delay = $q.defer();
                $http.post('api/messages/updateSegmentBinding/', segmentBindingUpdateParameterList).then(function(response) {
                    delay.resolve(true);
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            },
            updateProfileComponentBinding: function(profileComponentBindingUpdateParameterList) {
                var delay = $q.defer();
                $http.post('api/messages/updateProfileComponent/', profileComponentBindingUpdateParameterList).then(function(response) {
                    delay.resolve(true);
                }, function(error) {
                    delay.reject(error);
                });
                return delay.promise;
            }



        };
        return MessageService;
    });
/**
 * http://usejsdoc.org/
 */
angular.module('igl').factory('MessagesSvc', function($http, userInfoService, $q) {

    var svc = this;

    var messagesStruct = function(scope, children) {
        this.id = null;
        this.scope = scope;
        this.sectionDescription = null;
        this.sectionContents = null;
        this.children = children;
    };

    svc.findOneChild = function(id, list) {
        if (list) {
            for (var i = 0; i < list.length; i++) {
                if (list[i].id === id) {
                    return list[i];
                }
            }
        }
        return null;
    };

    svc.delete = function(message) {
        return $http.post('api/messages/' + message.id + '/delete');
    };
    svc.findMessageById = function(id) {

    };
    svc.findByIds = function(ids) {
        var delay = $q.defer();
        $http.post('api/messages/findByIds', ids).then(function(response) {
            var messages = angular.fromJson(response.data);
            delay.resolve(messages);
        }, function(error) {
            delay.reject(error);
        });
        return delay.promise;
    };
    svc.findByNamesAndScopeAndVersion = function(names, scope, hl7Version) {
        var namesAndscopeAndVersion = {
            "names": names,
            "scope": scope,
            "hl7Version": hl7Version
        };
        return $http.post(
                'api/messages/findByNamesScopeAndVersion', angular.toJson(namesAndscopeAndVersion))
            .then(function(response) {
                return angular.fromJson(response.data);
            });
    };


    return svc;
});
'use strict';

angular.module('igl').factory('Authors', ['$resource',
    function ($resource) {
        return $resource('api/shortaccounts', {filter:'accountType::author'});
    }
]);

angular.module('igl').factory('Supervisors', ['$resource',
    function ($resource) {
        return $resource('api/shortaccounts', {filter:'accountType::supervisor'});
    }
]);


angular.module('igl').factory('MultiAuthorsLoader', ['Authors', '$q',
    function (Authors, $q) {
        return function() {
            var delay = $q.defer();
            Authors.query(
                function(auth) {
                    delay.resolve(auth);
                },
                function() {
                    delay.reject('Unable to fetch list of authors');
                }
            );
            return delay.promise;
        };
    }
]);

angular.module('igl').factory('MultiSupervisorsLoader', ['Supervisors', '$q',
    function (Supervisors, $q) {
        return function() {
            var delay = $q.defer();
            Supervisors.query(
                function(res) {
                    delay.resolve(res);
                },
                function() {
                    delay.reject('Unable to fetch list of supervisors');
                }
            );
            return delay.promise;
        };
    }
]);

/**
 * Created by haffo on 3/9/16.
 */
'use strict';
angular.module('igl').factory('PcService', ['$rootScope', 'ViewSettings', 'ElementUtils', '$http', '$q', 'userInfoService', function($rootScope, ViewSettings, ElementUtils, $http, $q, userInfoService) {
    var PcService = {

        create: function(pc) {
            var delay = $q.defer();
            // table.accountId = userInfoService.getAccountID();
            $http.post('api/profile-components/create', pc).then(function(response) {
                console.log(response);
                var saved = angular.fromJson(response.data);
                delay.resolve(saved);
                return saved;
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        getPc: function(pcId) {
            var delay = $q.defer();
            $http.get('api/profile-components/' + pcId).then(function(response) {
                console.log("-----------------------");
                console.log(response);
                var pc = angular.fromJson(response.data);
                console.log(pc);
                delay.resolve(pc);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },


        findAll: function() {
            var delay = $q.defer();
            $http.post('api/profile-components/findAll').then(function(response) {
                var res = angular.fromJson(response.data);
                delay.resolve(res);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        addPCs: function(pcId, pcs) {
            var delay = $q.defer();

            $http.post('api/profile-components/' + pcId + '/addMult', pcs).then(function(response) {

                console.log(response);
                var saved = angular.fromJson(response.data);
                delay.resolve(saved);
                return saved;
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        save: function(pcLibId, profileComponent) {
            //$rootScope.saved = false;
            var delay = $q.defer();
            //var changes = angular.toJson([]);
            //var data = angular.fromJson({ "changes": changes, "igDocument": igDocument });
            $http.post('api/profile-components/save/' + pcLibId, profileComponent).then(function(response) {
                var saveResponse = angular.fromJson(response.data);

                delay.resolve(saveResponse);
            }, function(error) {
                delay.reject(error);
                $rootScope.saved = false;
            });
            return delay.promise;
        },
        saveAll: function(profileComponents) {
            //$rootScope.saved = false;
            var delay = $q.defer();
            //var changes = angular.toJson([]);
            //var data = angular.fromJson({ "changes": changes, "igDocument": igDocument });
            $http.post('api/profile-components/saveAll/', profileComponents).then(function(response) {
                var saveResponse = angular.fromJson(response.data);

                delay.resolve(saveResponse);
            }, function(error) {
                delay.reject(error);
                $rootScope.saved = false;
            });
            return delay.promise;
        },
        delete: function(pcLibId, profileComponent) {
            //$rootScope.saved = false;
            var delay = $q.defer();
            //var changes = angular.toJson([]);
            //var data = angular.fromJson({ "changes": changes, "igDocument": igDocument });
            $http.post('api/profile-components/delete/' + pcLibId, profileComponent).then(function(response) {
                var saveResponse = angular.fromJson(response.data);

                delay.resolve(saveResponse);
            }, function(error) {
                delay.reject(error);
                $rootScope.saved = false;
            });
            return delay.promise;
        },

    }
    return PcService;
}]);
angular.module('igl').factory ('ProfileAccessSvc', function($rootScope) {

	var svc = this;

	svc.Version = function() {
		return $rootScope.igdocument.profile.metaData.hl7Version;
	}

	svc.Messages = function() {
	
		var msgs = this;
	
		msgs.messages = function() {
			return $rootScope.igdocument.profile.messages.children;
		};
		
		msgs.findById = function(id) {
			return _.find(msgs.messages(), function(message) {
				return message.id === id;
			});
		}
		
		msgs.getMessageIds = function() {

			var rval = [];

			_.each($rootScope.igdocument.profile.messages.children, function(message) {
				rval.push(message.id);
			});

			return rval;
		}
		
		msgs.getAllSegmentRefs = function(messages) {

			var segRefs = [];
			
			_.each(messages, function(message) {
				var refs = msgs.getSegmentRefs(message);
				_.each(refs, function(ref){
					segRefs.push(ref);
				});
			});
			
			return _.uniq(segRefs);
		}
	
		msgs.getSegmentRefs = function(message) {
			
			var segRefs = [];
			
			_.each(message.children, function(groupORsegment) {
				var refs = fetchSegmentRefs(groupORsegment);
				_.each(refs, function(ref){
					segRefs.push(ref.id);
				});
			});
			
		  return _.uniq(segRefs);
		}
		
		msgs.getGroups = function(message) {
			
			var groups = [];
			
			_.each(message.children, function(groupORsegment) {
//				console.log("Was a what? groupORsegment.type="
//						+ groupORsegment.type + " name=" + message.name);
				var grps = fetchGroups(groupORsegment);
				_.each(grps, function(grp){
					groups.push(grp);
				});
			});
			
		  return groups;
		}
		
		function fetchGroups(groupORsegment) {

			var groups = [];
			
			if (groupORsegment.type === "group") {
				console.log("Was a group groupORsegment.type="
						+ groupORsegment.type);
				groups.push(groupORsegment);
				_.each(groupORsegment.children, function(groupORsegment1) {
					var grps = fetchGroups(groupORsegment1);
					_.each(grps, function(grp){
						groups.push(grp);
					});
				});
			} else {
				console.log("Was a segmentRef groupORsegment.type="
								+ groupORsegment.type);
			}
			
			return groups;
		}
	
		function fetchSegmentRefs(groupORsegment) {

			var segRefs = [];
			
			if (groupORsegment.type === "group") {
				_.each(groupORsegment.children, function(groupORsegment1) {
					var refs = fetchSegmentRefs(groupORsegment1);
					_.each(refs, function(ref){
						segRefs.push(ref);
					});
				});
			} else if (groupORsegment.type === "segmentRef") {
				segRefs.push(groupORsegment.ref);
			} else {
				console.log("Was neither group nor segmentRef groupORsegment.type="
								+ groupORsegment.type);
			}
			
			return segRefs;
		}
	
		return msgs;
	}

	svc.Segments = function() {
	
		var segs = this;
	
		segs.segments = function() {
			return $rootScope.segments;
		}
		
		segs.truncate = function() {
			segs.segments().length = 0;
		}
		
		segs.getAllSegmentIds = function() {
			var rval = [];
			_.each(segs.segments(), function(seg){
				rval.push(seg.id);
			});
			return rval;
		}
		
		segs.findByIds = function(ids) {
			var segments = [];
			_.each(ids, function(id){
				var segment = segs.findById(id);
				if (segment) {
					segments.push(segment);
				}
			});
			return segments;
		}
		
		segs.findById = function(segId) {
//			console.log("segIds=" + segs.getAllSegmentIds());
			var segments = segs.segments();
			
			var segment = _.find(segments, function(segment1) {
				return segment1.id === segId;
			});
			
			if (!segment) {
				console.log("segs.findById: segment not found, segId=" + segId);
			}
			return segment;
		}
		
		segs.findDead = function(idsDead, idsLive) {
			var segIds = _.difference(idsDead, idsLive);
			return segIds;
		}
		
		segs.removeDead = function(segIds) {
			var segments = segs.segments();
			var i = -1;
		
			_.each(ensureArray(segIds), function(id) {
				i = _.findIndex(segments, { 'id' : id });
				if (i > -1) {
					segments.splice(i, 1);
				}
			});
			
			return segments.length;
		}
		
		segs.getParentalDependencies = function(segment) {
			var messages = svc.Messages().messages();
			var rval = _.filter(messages, function(message) {
				var segRefs= svc.Messages().getSegmentRefs(message);
				return _.indexOf(segRefs, segment.id) >= 0;
			});
			return rval;
		}
		
		segs.findDatatypesFromSegmentRefs  = function(segRefs) {
			
			var dtIds = [];
			
			_.each(segRefs, function(segRef) {
				var segment = segs.findById(segRef);
				if (segment) {
					dtIds.push(segs.findDatatypesFromSegment(segment));
				} else {
					console.log("segs.findDatatypesFromSegmentRefs: Did not find seg for segRef=" + segRef);
				}
			});
			
			return _.uniq(_.flatten(dtIds));
		}
		
		segs.findDatatypesFromSegment = function(segment) {
			
			var dtIds = [];
			
			_.each(segment.fields, function(field) {
				dtIds.push(field.datatype);
			});
			
			return _.uniq(dtIds);
		}

		return segs;
	}

	svc.Datatypes = function() {
	
		var dts = this;
	
		dts.datatypes = function() {
			return $rootScope.datatypes;
		}
		
		dts.truncate = function() {
			dts.datatypes().length = 0;
		}
		
		dts.getAllDatatypeIds = function() {
			
			var dtIds = [];
			
			_.each(dts.datatypes(), function(datatype) {
				dtIds.push(datatype.id);
			});
			
			return dtIds;
		}
		
		dts.findById = function(id) {
			var datatype = _.find(dts.datatypes(), function(datatype) {
				return datatype.id === id;
			});
			if (!datatype) {
				console.log("dts.findById: datatype not found id=" + id);
			}
			return datatype;
		}						
		
		dts.findDead = function(idsDead, idsLive) {
			var dtIds = _.difference(idsDead, idsLive);
			return dtIds;
		}
				
		dts.removeDead = function(dtIds) {
			var datatypes = dts.datatypes();
			var i = 0;
			
			_.each(ensureArray(dtIds), function(id) {
				i = _.findIndex(datatypes, { 'id' : id });
				if (i > -1) {
					datatypes.splice(i, 1);
				}
			});
			
			return datatypes.length;
		}
		
		dts.findValueSetsFromDatatypeIds = function(dtIds) {
			
			var vsIds = [];
			
			_.each(dtIds, function(dtId) {
				var datatype = dts.findById(dtId);
				if (datatype) {
					var rvals = dts.findValueSetsFromDatatype(datatype);
					_.each(rvals, function(rval) {
						vsIds.push(rval);
					});
				} else {
					console.log("dts.findValueSetsFromDatatypeIds: Did not find dt for dtId=" + dtId);
				}
			});
			
			return _.uniq(vsIds);
		}
		
		dts.findValueSetsFromDatatype = function(datatype) {
			
			vsIds = [];
			
			_.each(datatype.components, function(component) {
				if (component.table.trim()) {
					vsIds.push(component.table);
				}
			});
			
			return _.uniq(vsIds);
		}
		
		return dts;
	}
	
	svc.ValueSets = function() {
		
		var vss = this;
		
		vss.valueSets = function() {
			return $rootScope.tables;
		};
				
		vss.truncate = function() {
			vss.valueSets().length = 0;
		};
		
		vss.getAllValueSetIds = function() {
			
			var vsIds = [];
			var valueSets = vss.valueSets();
			var i = 0;
			_.each(valueSets, function(valueSet) {
				if (valueSet) {
					vsIds.push(valueSet.id);
				}
			});
			
			return vsIds;
		}
		
		vss.findById = function(id) {
			var valueSet =  _.find(vss.valueSets(), function(vs) {
				return vs.id === id;
			});
			if (!valueSet) {
				console.log("vss.findById:: Did not find vs for vsId=" + dtId);
			}
			return valueSet;
		}
		
		vss.findDead = function(idsDead, idsLive) {
			var vsIds = _.difference(idsDead, idsLive);
			return vsIds;
		}
		
		vss.removeDead = function(vsIds) {			
			var valueSets = vss.valueSets();
//			console.log("b vss.removeDead=" + valueSets.length);
			
			_.each(ensureArray(vsIds), function(vsId) {
				var i = 0;
				_.each(valueSets, function(valueSet) {
					i = _.findIndex(valueSets, { 'id' : vsId });
					if (i > -1) {
						valueSets.splice(i, 1);
					}
				});
			});
			
			return valueSets.length;
		}
		
		return vss;
	}
	
	function ensureArray(possibleArray) {
		if(angular.isArray(possibleArray)) {
			return possibleArray;
		} else {
			console.log("Array ensured.");
			return [possibleArray];
		}
	}
	
	return svc;
});
/**
 * http://usejsdoc.org/
 */
angular.module('igl').factory('ProfileSvc', function($http, $q,userInfoService) {
	var svc = this;
    svc.saveMetaData = function (id, metaData) {
        var delay = $q.defer();
        $http.post('api/igdocuments/'+ id+ '/profile/metadata/save', metaData).then(function (response) {
            var saveResponse = angular.fromJson(response.data);
            delay.resolve(saveResponse);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    return svc;
});

/**
 * http://usejsdoc.org/
 */
angular.module('igl').factory('SectionSvc', function($http, $q,userInfoService, $rootScope) {
	var svc = this;
    svc.save = function (id, section) {
        var delay = $q.defer();
        $http.post('api/igdocuments/'+ id+ '/section/save', section).then(function (response) {
            var dateUpdated = angular.fromJson(response.data);
            section.dateUpdated = dateUpdated;
            $rootScope.$emit("event:updateIgDate",dateUpdated);
            delay.resolve(dateUpdated);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };
    svc.update = function (id, section) {
        var delay = $q.defer();
        console.log("section");
        console.log(section);
        $http.post('api/igdocuments/'+ id+ '/section/update', section).then(function (response) {
            var dateUpdated = angular.fromJson(response.data);
            section.dateUpdated = dateUpdated;
            $rootScope.$emit("event:updateIgDate",dateUpdated);
            delay.resolve(dateUpdated);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    svc.delete = function (id, sectionId) {
        var delay = $q.defer();
        $http.post('api/igdocuments/'+ id+ '/section/'+sectionId+'/delete').then(function (response) {
            var dateUpdated = angular.fromJson(response.data);
            $rootScope.$emit("event:updateIgDate",dateUpdated);
            delay.resolve(dateUpdated);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    svc.merge = function(oldValue, newValue){
        angular.extend(oldValue, newValue);
//        oldValue.id =  newValue.id;
//        oldValue.sectionTitle =  newValue.sectionTitle;
//        oldValue.sectionDescription =  newValue.sectionDescription;
//        oldValue.sectionPosition =  newValue.sectionPosition;
//        oldValue.sectionContents =  newValue.sectionContents;
//        oldValue.type =  newValue.type;
    };

    return svc;
});

/**
 * http://usejsdoc.org/
 */
angular.module('igl').factory('SegmentLibrarySvc', function($http, userInfoService,$q) {

	var svc = this;

	var segLibStruct = function(scope, children) {
		this.id = null;
		this.scope = scope;
	    this.sectionDescription = null;
	    this.sectionContents = null;
		this.children = children;
	};

  svc.getHL7Versions = function() {
		return $http.get(
				'api/segment-library/findHl7Versions')
				.then(function(response) {
//					console.log("response" + JSON.stringify(response));
					return angular.fromJson(response.data);
				});
  };

	svc.getSegmentLibraryByScopes = function(scopes) {
		console.log("segment-library/findByScopes scopes=" + scopes);
        return $http.post(
            'api/segment-library/findByScopes', angular.toJson(scopes))
            .then(function(response) {
    					console.log("getSegmentLibraryByScopes response=" + response.data.length);
              return angular.fromJson(response.data);
            });
	};

	svc.getSegmentLibraryByScopesAndVersion = function(scopes, hl7Version) {
		console.log("segment-library/findByScopesAndVersion scopes=" + scopes + " hl7Version=" + hl7Version);
        var scopesAndVersion = {
          "scopes" : scopes,
          "hl7Version" : hl7Version
        };
        return $http.post(
            'api/segment-library/findByScopesAndVersion', angular.toJson(scopesAndVersion))
            .then(function(response) {
     					console.log("getSegmentLibraryByScopesAndVersion response size=" + response.data.length);
//   					  console.log("getSegmentLibraryByScopesAndVersion response=" + JSON.stringify(response.data));
              return angular.fromJson(response.data);
            });
	};

  svc.getSegmentsByLibrary = function(segLibId) {
        return $http.get(
            'api/segment-library/' + segLibId + '/segments')
            .then(function(response) {
    //					console.log("response" + JSON.stringify(response));
              return angular.fromJson(response.data);
            });
  }

	svc.append = function(fromchildren, toChildren) {
		angular.forEach(fromchildren, function(child) {
			toChildren.push(child);
		});
		return svc.segmentLibrary;
	};

	svc.createUpdate = function(scope, children) {
		var dtlrw = new segLibStruct(scope, children);
	};

	svc.create = function(hl7Version, scope, name, ext) {
    var dtlcw = { "hl7Version" : hl7Version,
                  "scope" : scope,
                  "name" : name,
                  "ext" : ext,
                  "accountId" : userInfoService.getAccountID()};
		return $http.post(
			'api/segment-library/create', dtlcw).then(function(response) {
			return angular.fromJson(response.data)});
	};

	svc.save = function(segmentLibrary) {
		return $http.post(
			'api/segment-library/save', angular.toJson(segmentLibrary)).then(function(response) {
			return angular.fromJson(response.data)});
	};

    svc.addSegment = function(segmentLibrary, segment) {




        return $http.post(

            'api/segment-library/save', angular.toJson(segmentLibrary)).then(function(response) {
                return angular.fromJson(response.data)});
    };

    svc.findOneChild = function (id, list) {
        if (list) {
            for (var i = 0; i < list.length; i++) {
                if (list[i].id === id) {
                    return list[i];
                }
            }
        }
        return null;
    };

    svc.createEmptyLink = function () {
        return {id:null, ext:null, name:null};
    };


    svc.addChild = function (libId, child) {
        var delay = $q.defer();
        $http.post('api/segment-library/'+ libId+ '/addChild', child).then(function (response) {
            var link = angular.fromJson(response.data);
            delay.resolve(link);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    svc.updateChild = function (libId, child) {
        var delay = $q.defer();
        $http.post('api/segment-library/'+ libId+ '/updateChild', child).then(function (response) {
            var link = angular.fromJson(response.data);
            delay.resolve(link);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    svc.findLibrariesByFlavorName = function (flavorName, flavorScope, flavorHl7Version) {
        var delay = $q.defer();
        $http.get('api/segment-library/findLibrariesByFlavorName', {params: {"name": flavorName, "scope": flavorScope, "hl7Version": flavorHl7Version}}).then(function (response) {
            var libraries = angular.fromJson(response.data);
            delay.resolve(libraries);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };
    
    svc.deleteChild = function (libId, id) {
        var delay = $q.defer();
        $http.post('api/segment-library/'+ libId+ '/deleteChild/' + id).then(function (response) {
            var link = angular.fromJson(response.data);
            delay.resolve(link);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    svc.addChildren = function (libId, segmentLinks) {
        var delay = $q.defer();
        $http.post('api/segment-library/'+ libId+ '/addChildren', segmentLinks).then(function (response) {
            var res = angular.fromJson(response.data);
            delay.resolve(res);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };


    return svc;
});

/**
 * Created by haffo on 3/9/16.
 */
'use strict';
angular.module('igl').factory('SegmentService', ['$rootScope', 'ViewSettings', 'ElementUtils', '$q', '$http', 'FilteringSvc', 'userInfoService', function($rootScope, ViewSettings, ElementUtils, $q, $http, FilteringSvc, userInfoService) {
    var SegmentService = {
        getNodes: function(parent, root) {
            var children = [];

            if (parent && parent.type && parent.type === 'case') {
                children = $rootScope.datatypesMap[parent.datatype].components;
            } else {
                children = parent ? parent.fields ? parent.fields : parent.datatype ? $rootScope.datatypesMap[parent.datatype.id].components : parent.children : root != null ? root.fields : [];

                if (parent && parent.datatype && $rootScope.datatypesMap[parent.datatype.id].name === 'varies') {
                    var mapping = _.find($rootScope.segment.dynamicMapping.mappings, function(mapping) {
                        return mapping.position == parent.position;
                    });
                    if (mapping) children = mapping.cases;
                }
            }

            return children;
        },
        getParent: function(child) {
            var parent = $rootScope.parentsMap && $rootScope.parentsMap[child.id] ? $rootScope.parentsMap[child.id] : null;
            return parent;
        },
        getTemplate: function(node, root) {
            var template = null;
            if (ViewSettings.tableReadonly || (root != null && root.scope === 'HL7STANDARD') || root.scope === null) {
                return SegmentService.getReadTemplate(node, root);
            } else {
                return SegmentService.getEditTemplate(node, root);
            }
            return template;
        },

        getReadTemplate: function(node, root) {
            var template = node.type === 'segment' ? 'SegmentReadTree.html' : node.type === 'field' ? 'SegmentFieldReadTree.html' : node.type === 'case' ? 'SegmentCaseReadTree.html' : 'SegmentComponentReadTree.html';
            return template;
        },

        getEditTemplate: function(node, root) {
            var template = node.type === 'segment' ? 'SegmentEditTree.html' : node.type === 'field' ? 'SegmentFieldEditTree.html' : node.type === 'case' ? 'SegmentCaseReadTree.html' : 'SegmentComponentEditTree.html';
            return template;
        },

        getSegmentLevelConfStatements: function(element) {
            var parent = SegmentService.getParent(element.id);
            var conformanceStatements = [];
            if (parent && parent != null && parent.conformanceStatements.length > 0) {
                return ElementUtils.filterConstraints(element, parent.conformanceStatements);
            }
            return conformanceStatements;
        },

        getSegmentLevelPredicates: function(element) {
            var parent = SegmentService.getParent(element.id);
            var predicates = [];
            if (parent && parent != null && parent.predicates.length > 0) {
                return ElementUtils.filterConstraints(element, parent.predicates);
            }
            return predicates;
        },

        isBranch: function(node) {
            var children = SegmentService.getNodes(node);
            return children != null && children.length > 0;
        },
        isVisible: function(node) {
            //return FilteringSvc.show(node);
            return true;

            //                 return  node ? SegmentService.isRelevant(node) ? SegmentService.isVisible(SegmentService.getParent(node)) : false : true;
        },

        isRelevant: function(node) {
            if (node === undefined || !ViewSettings.tableRelevance)
                return true;
            if (node.hide == undefined || !node.hide || node.hide === false) {
                var predicates = SegmentService.getSegmentLevelPredicates(node);
                return ElementUtils.isRelevant(node, predicates);
            } else {
                return false;
            }
        },

        save: function(segment) {
            var delay = $q.defer();
            segment.accountId = userInfoService.getAccountID();
            $http.post('api/segments/save', segment).then(function(response) {
                var saveResponse = angular.fromJson(response.data);
                segment.date = saveResponse.date;
                segment.version = saveResponse.version;
                delay.resolve(saveResponse);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        saves: function(segments) {
            var delay = $q.defer();
            for (var i = 0; i < segments.length; i++) {
                segments[i].accountId = userInfoService.getAccountID();
            }

            $http.post('api/segments/saveSegs', segments).then(function(response) {
                var saveResponse = angular.fromJson(response.data);
                for (var i = 0; i < segments.length; i++) {
                    segments[i].date = saveResponse[i].date;
                    segments[i].version = saveResponse[i].version;
                }

                delay.resolve(saveResponse);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },

        get: function(id) {
            var delay = $q.defer();
            if ($rootScope.segmentsMap[id] === undefined || $rootScope.segmentsMap[id] === undefined) {
                $http.get('api/segments/' + id).then(function(response) {
                    var segment = angular.fromJson(response.data);
                    delay.resolve(segment);
                }, function(error) {
                    delay.reject(error);
                });
            } else {
                delay.resolve($rootScope.segmentsMap[id]);
            }
            return delay.promise;
        },
        getSegmentsByScopesAndVersion: function(scopes, hl7Version) {
            console.log("segments/findByScopesAndVersion scopes=" + scopes + " hl7Version=" + hl7Version);
            var scopesAndVersion = {
                "scopes": scopes,
                "hl7Version": hl7Version
            };
            return $http.post(
                    'api/segments/findByScopesAndVersion', angular.toJson(scopesAndVersion))
                .then(function(response) {
                    console.log("getSegmentsByScopesAndVersion response size=" + response.data.length);
                    return angular.fromJson(response.data);
                });
        },

        merge: function(to, from) {
            console.log("to");
            console.log(to);
            to = angular.extend(to, from);
            //            to.name = from.name;
            //            to.ext = from.ext;
            //            to.label = from.label;
            //            to.description = from.description;
            //            to.status = from.status;
            //            to.comment = from.comment;
            //            to.usageNote = from.usageNote;
            //            to.scope = from.scope;
            //            to.hl7Version = from.hl7Version;
            //            to.accountId = from.accountId;
            //            to.participants = from.participants;
            //            to.libIds = from.libIds;
            //            to.predicates = from.predicates;
            //            to.conformanceStatements = from.conformanceStatements;
            //            to.sectionPosition = from.sectionPosition;
            //            to.fields = from.fields;
            //            to.version = from.version;
            //            to.date = from.date;
            //            to.purposeAndUse = from.purposeAndUse;
            //            to.coConstraints = to.coConstraints;
            return to;
        },

        delete: function(segment) {
            var delay = $q.defer();
            $http.post('api/segments/' + segment.id + '/delete').then(function(response) {
                var saveResponse = angular.fromJson(response.data);
                delay.resolve(saveResponse);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },

        getSegmentLink: function(segment) {
            return { id: segment.id, ext: segment.ext, name: segment.name };
        },

        findByIds: function(ids) {
            var delay = $q.defer();
            $http.post('api/segments/findByIds', ids).then(function(response) {
                var datatypes = angular.fromJson(response.data);
                delay.resolve(datatypes);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },

        collectDatatypes: function(id) {
            var delay = $q.defer();
            $http.get('api/segments/' + id + '/datatypes').then(function(response) {
                var datatypes = angular.fromJson(response.data);
                delay.resolve(datatypes);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },

        saveNewElements: function() {
            var delay = $q.defer();
            var datatypeLinks = ElementUtils.getNewDatatypeLinks();
            if (datatypeLinks.length > 0) {
                DatatypeLibrarySvc.addChildren($rootScope.igdocument.profile.datatypeLibrary.id, datatypeLinks).then(function() {
                    $rootScope.igdocument.profile.datatypeLibrary.children = $rootScope.igdocument.profile.datatypeLibrary.children.concat(datatypeLinks);
                    _.each($rootScope.addedDatatypes, function(datatype) {
                        if (ElementUtils.indexIn(datatype.id, $rootScope.datatypes) < 0) {
                            $rootScope.datatypes.push(datatype);
                        }
                    });
                    var tableLinks = ElementUtils.getNewTableLinks();
                    if (tableLinks.length > 0) {
                        TableLibrarySvc.addChildren($rootScope.igdocument.profile.tableLibrary.id, tableLinks).then(function() {
                            $rootScope.igdocument.profile.tableLibrary.children = $rootScope.igdocument.profile.tableLibrary.children.concat(tableLinks);
                            _.each($rootScope.addedTables, function(table) {
                                if (ElementUtils.indexIn(table.id, $rootScope.tables) < 0) {
                                    $rootScope.tables.push(table);
                                }
                            });
                            SegmentService.completeSave();
                            delay.resolve(true);
                        }, function(error) {
                            delay.reject(error);
                        });
                    } else {
                        SegmentService.completeSave();
                        delay.resolve(true);
                    }
                }, function(error) {
                    delay.reject(error);
                });
            } else {
                SegmentService.completeSave();
                delay.resolve(true);
            }
            return delay.promise;
        },

        completeSave: function() {
            $rootScope.addedDatatypes = [];
            $rootScope.addedTables = [];
            $rootScope.clearChanges();
            $rootScope.msg().text = "segmentSaved";
            $rootScope.msg().type = "success";
            $rootScope.msg().show = true;
        },

        reset: function() {
            if ($rootScope.addedDatatypes != null && $rootScope.addedDatatypes.length > 0) {
                _.each($rootScope.addedDatatypes, function(id) {
                    delete $rootScope.datatypesMap[id];
                });
            }
            if ($rootScope.addedTables != null && $rootScope.addedTables.length > 0) {
                _.each($rootScope.addedTables, function(id) {
                    delete $rootScope.tablesMap[id];
                });
            }
            $rootScope.segment = angular.copy($rootScope.segmentsMap[$rootScope.segment.id]);
        },

        updateTableBinding: function(segmentUpdateParameterList) {
            var delay = $q.defer();
            $http.post('api/segments/updateTableBinding/', segmentUpdateParameterList).then(function(response) {
                delay.resolve(true);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        updateDatatypeBinding: function(segmentUpdateParameterList) {
            var delay = $q.defer();
            $http.post('api/segments/updateDatatypeBinding/', segmentUpdateParameterList).then(function(response) {
                delay.resolve(true);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        }
    };
    return SegmentService;
}]);
'use strict';
angular.module('igl').factory('StorageService',
    ['localStorageService', function (localStorageService) {
        var service = {
            TABLE_COLUMN_SETTINGS_KEY: 'SETTINGS_KEY',
            SELECTED_IG_DOCUMENT_TYPE:'SelectedIgDocumentType',
            SELECTED_IG_DOCUMENT_ID:'SelectedIgDocumentId',
            APP_VERSION:'APP_VERSION',
            TABLE_CONCISE_SETTINGS:'TABLE_CONCISE_SETTINGS',
            TABLE_RELEVANCE_SETTINGS:'TABLE_RELEVANCE_SETTINGS',
            TABLE_COLLAPSE_SETTINGS:'TABLE_COLLAPSE_SETTINGS',
            TABLE_READONLY_SETTINGS:'TABLE_READONLY_SETTINGS',
            IG_DOCUMENT:'IG_DOCUMENT',
            remove: function (key) {
                return localStorageService.remove(key);
            },

            removeList: function removeItems(key1, key2, key3) {
                return localStorageService.remove(key1, key2, key3);
            },

            clearAll: function () {
                return localStorageService.clearAll();
            },
            set: function (key, val) {
                return localStorageService.set(key, val);
            },
            get: function (key) {
                return localStorageService.get(key);
            },
            setSelectedIgDocumentType: function (val) {
                this.set(this.SELECTED_IG_DOCUMENT_TYPE,val);
            },
            getSelectedIgDocumentType: function () {
                return this.get(this.SELECTED_IG_DOCUMENT_TYPE);
            },
            setAppVersion: function (version) {
                this.set(this.APP_VERSION,version);
            },
            getAppVersion: function () {
                return this.get(this.APP_VERSION);
            },
            getIgDocument: function () {
                return this.get(this.IG_DOCUMENT) != null ? angular.fromJson(this.get(this.IG_DOCUMENT)):null;
            },
            setIgDocument: function (igDocument) {
                this.set(this.IG_DOCUMENT,igDocument != null ?  angular.toJson(igDocument):null);
            }
        };
        return service;
    }]
);

/**
 * http://usejsdoc.org/
 */
angular.module('igl').factory('TableLibrarySvc', function($http, $httpBackend, $q, userInfoService) {

	var svc = this;

	var tableLibStruct = function(scope, children) {
		this.id = null;
		this.scope = scope;
	    this.sectionDescription = null;
	    this.sectionContents = null;
		this.children = children;
	};

  svc.getHL7Versions = function() {
		return $http.get(
				'api/table-library/findHl7Versions')
				.then(function(response) {
//					console.log("response" + JSON.stringify(response));
					return angular.fromJson(response.data);
				});
  };

	svc.getDataTypeLibraryByScopes = function(scopes) {
		console.log("table-library/findByScopes scopes=" + scopes);
        return $http.post(
            'api/table-library/findByScopes', angular.toJson(scopes))
            .then(function(response) {
    					console.log("getDataTypeLibraryByScopes response=" + response.data.length);
              return angular.fromJson(response.data);
            });
	};

	svc.getDataTypeLibraryByScopesAndVersion = function(scopes, hl7Version) {
		console.log("table-library/findByScopesAndVersion scopes=" + scopes + " hl7Version=" + hl7Version);
        var scopesAndVersion = {
          "scopes" : scopes,
          "hl7Version" : hl7Version
        };
        return $http.post(
            'api/table-library/findByScopesAndVersion', angular.toJson(scopesAndVersion))
            .then(function(response) {
     					console.log("getDataTypeLibraryByScopesAndVersion response size=" + response.data.length);
//   					  console.log("getDataTypeLibraryByScopesAndVersion response=" + JSON.stringify(response.data));
              return angular.fromJson(response.data);
            });
	};

  svc.getTablesByLibrary = function(tableLibId) {
        return $http.get(
            'api/table-library/' + tableLibId + '/tables')
            .then(function(response) {
    //					console.log("response" + JSON.stringify(response));
              return angular.fromJson(response.data);
            });
  }

	svc.append = function(fromchildren, toChildren) {
		angular.foreach(fromchildren, function(child) {
			toChildren.push(child);
		});
		return svc.tableLibrary;
	};

	svc.createUpdate = function(scope, children) {
		var tablelrw = new tableLibStruct(scope, sortedChildren);
	};

	svc.create = function(hl7Version, scope, name, ext) {
    var tablelcw = { "hl7Version" : hl7Version,
                  "scope" : scope,
                  "name" : name,
                  "ext" : ext,
                  "accountId" : userInfoService.getAccountID()};
		return $http.post(
			'api/table-library/create', tablelcw).then(function(response) {
			return angular.fromJson(response.data)});
	};

	svc.save = function(tableLibrary) {
		return $http.post(
			'api/table-library/save', angular.toJson(tableLibrary)).then(function(response) {
			return angular.fromJson(response.data)});
	};

    svc.findOneChild = function (id, list) {
        if (list) {
            for (var i = 0; i < list.length; i++) {
                if (list[i].id === id) {
                    return list[i];
                }
            }
        }
        return null;
    };

    svc.createEmptyLink = function () {
        return {id:null, bindingIdentifier:null};
    };


    svc.addChild = function (libId, child) {
        var delay = $q.defer();
        $http.post('api/table-library/'+ libId+ '/addChild', child).then(function (response) {
            var link = angular.fromJson(response.data);
            delay.resolve(link);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    svc.updateChild = function (libId, child) {
        var delay = $q.defer();
        $http.post('api/table-library/'+ libId+ '/updateChild', child).then(function (response) {
            var link = angular.fromJson(response.data);
            delay.resolve(link);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };
    
    svc.deleteChild = function (libId, id) {
        var delay = $q.defer();
        $http.post('api/table-library/'+ libId+ '/deleteChild/' + id).then(function (response) {
            var link = angular.fromJson(response.data);
            delay.resolve(link);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };

    svc.addChildren = function (libId, tableLinks) {
        var delay = $q.defer();
        $http.post('api/table-library/'+ libId+ '/addChildren', tableLinks).then(function (response) {
            var res = angular.fromJson(response.data);
            delay.resolve(res);
        }, function (error) {
            delay.reject(error);
        });
        return delay.promise;
    };


    return svc;
});

/**
 * Created by haffo on 3/9/16.
 */
'use strict';
angular.module('igl').factory('TableService', ['$rootScope', 'ViewSettings', 'ElementUtils', '$http', '$q', 'FilteringSvc', 'userInfoService', function($rootScope, ViewSettings, ElementUtils, $http, $q, FilteringSvc, userInfoService) {
    var TableService = {

        save: function(table) {
            var delay = $q.defer();
            table.accountId = userInfoService.getAccountID();
            $http.post('api/tables/save', table).then(function(response) {
                console.log(table);
                var saved = angular.fromJson(response.data);
                delay.resolve(saved);
                return saved;
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        getOne: function(id) {
            var delay = $q.defer();
//            if ($rootScope.tablesMap[id] === undefined || $rootScope.tablesMap[id] === undefined) {
//                console.log("getOne==>");
                $http.get('api/tables/' + id).then(function(response) {
                    var table = angular.fromJson(response.data);
                    delay.resolve(table);
                }, function(error) {
                    delay.reject(error);
                });
//            } else {
//                delay.resolve($rootScope.tablesMap[id]);
//            }
            return delay.promise;
        },
        get: function(ids) {
            var delay = $q.defer();
            $http.post('api/tables/findAllByIds', ids).then(function(response) {
                var tables = angular.fromJson(response.data);
                delay.resolve(tables);
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        getBindingIdentifiers: function(ids) {

        },
        merge: function(to, from) {
            to = angular.extend(to, from);
            //                to.libIds = from.libIds;
            //            	to.name = from.name;
            //            	to.description = from.description;
            //            	to.version = from.version;
            //            	to.oid = from.oid;
            //            	to.bindingIdentifier = from.bindingIdentifier;
            //            	to.stability = from.stability;
            //            	to.extensibility = from.extensibility;
            //            	to.contentDefinition = from.contentDefinition;
            //            	to.group = from.group;
            //            	to.order = from.order;
            //            	to.codes = from.codes;
            //            	to.status = from.status;
            //            	to.accountId = from.accountId;
            //            	to.date = from.date;
            //            	to.scope = from.scope;

            return to;
        },
        delete: function(table) {
            return $http.post('api/tables/' + table.id + '/delete');
        },

        getTableLink: function(table) {
            return { id: table.id, bindingIdentifier: table.bindingIdentifier };
        },
        findAllByIds: function(tableIds) {
            var delay = $q.defer();
            $http.post('api/tables/findShortAllByIds', tableIds).then(function(response) {
                delay.resolve(angular.fromJson(response.data));
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
         publish: function(table) {
                var delay = $q.defer();
                table.accountId = userInfoService.getAccountID();
                //table.status="PUBLISHED";
                $http.post('api/tables/publish', table).then(function(response) {
                    var saveResponse = angular.fromJson(response.data);
                   
                    delay.resolve(saveResponse);
                }, function(error) {
                    //console.log("DatatypeService.save error=" + error);
                    delay.reject(error);
                });
                return delay.promise;
        },
        share:function(tableId,shareParticipantIds, accountId){
            var delay = $q.defer();
            $http.post('api/tables/' + tableId + '/share', {'accountId': accountId, 'participantsList': shareParticipantIds}).then(function (response) {
                delay.resolve(response.data);
            }, function (error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        unshare: function(tableId, participantId){
            var delay = $q.defer();
            $http.post('api/tables/' + tableId + '/unshare', participantId).then(function (response) {
                delay.resolve(response.data);
             }, function (error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        getSharedTables: function(){
            var delay = $q.defer();
            $http.get('api/tables/findShared').then(function (response) {
                delay.resolve(response.data);
             }, function (error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        getPendingSharedTables: function(){
            var delay = $q.defer();
            $http.get('api/tables/findPendingShared').then(function (response) {
                delay.resolve(response.data);
             }, function (error) {
                delay.reject(error);
            });
            return delay.promise;
        }

    };
    return TableService;
}]);

angular
		.module('igl')
		.factory(
				'ToCSvc',
				function(FilteringSvc, MastermapSvc,$rootScope) {

					var svc = this;

					function entry(id, label, position, type, parent, reference) {
						this.id = id;
						this.label = label;
						this.selected = false;
						this.position = position;
						this.type = type;
						this.parent = parent;
						this.reference = reference;
					}
					;

					svc.currentLeaf = {
						selected : false
					};

					svc.findEntryFromRefId = function(refId, entries) {
						var rval = undefined;
						if (angular.isArray(entries)) {
							_.each(entries, function(entry) {
								if (entry.reference && entry.reference.id) {
									if (entry.reference.id === refId) {
										rval = entry;
									} else {
										if (rval) {
											return rval;
										}
										rval = svc.findEntryFromRefId(refId,
												entry.children);
									}
								}
							});
						}
						return rval;
					};

					svc.getToC = function(igdocument) {
//						console.log("Getting toc... version="
//								+ igdocument.profile.metaData.hl7Version + " "
//								+ igdocument.id);
						toc = [];

//						console.log("childSections=" +
//						igdocument.childSections.length);
						var documentMetadata = getMetadata(igdocument,
								"documentMetadata");
						toc.push(documentMetadata);
						var sections = getSections(igdocument.childSections,
								igdocument.type, igdocument);
						_.each(sections, function(section) {
							toc.push(section);
						});
						var conformanceProfile = getMessageInfrastructure(igdocument);
						toc.push(conformanceProfile);
//             console.log("toc=" + toc);
						return toc;
					};

					function getMetadata(parent, type) {
						var rval = new entry(type, "Metadata", 0, type, parent,
								parent.metaData);
						return rval;
					}
					;

					function getSections(childSections, parentType, parent) {

						var rval = [];

						_.each(childSections, function(childSection) {
							var section = new entry(childSection.id,
									childSection.sectionTitle,
									childSection.sectionPosition,
									childSection.type, parent, childSection);
							rval.push(section);
							var sections1 = getSections(
									childSection.childSections,
									childSection.type, childSection);
							_.each(sections1, function(section1) {
								if (!section.children) {
									section.children = [];
								}
								section.children.push(section1);
							});
						});
						var section2 = _.sortBy(rval, "position");
						rval = section2;
						return rval;
					}
					;

					function getMessageInfrastructure(igdocument) {
						var rval = new entry(igdocument.profile.id,
								igdocument.profile.sectionTitle,
								igdocument.profile.sectionPosition,
								igdocument.profile.type, 0, igdocument.profile);

                        var datatypes = angular.copy(igdocument.profile.datatypeLibrary);
                        datatypes.children = $rootScope.datatypes;
                        var segments = angular.copy(igdocument.profile.segmentLibrary);
                        segments.children = $rootScope.segments;
                        var tables = angular.copy(igdocument.profile.tableLibrary);
                        tables.children = $rootScope.tables;

                        var children = [];
						children.push(getMetadata(igdocument.profile,
								"profileMetadata"));
						children.push(getTopEntry(igdocument.profile.messages,
								igdocument.profile));
						children.push(getTopEntry(segments,
								igdocument.profile));
						children.push(getTopEntry(datatypes,
								igdocument.profile));
						children.push(getTopEntry(tables,
								igdocument.profile));
						rval.children = children;
						return rval;
					}
					;

					// Returns a top level entry. It can be dropped on, but
					// cannot be
					// dragged.
					function getTopEntry(child, parent) {
						// console.log("getTopEntry sectionTitle=" +
						// child.sectionTitle);
						// console.log("getTopEntry type=" + child.type);
						var children = [];
						var rval = new entry(child.id, child.sectionTitle,
								child.sectionPosition, child.type, parent,
								child);
						if (child) {
							rval["reference"] = child;
							if (angular.isArray(child.children)
									&& child.children.length > 0) {
								rval["children"] = createEntries(
										child.children[0].type, child,
										child.children);
							}
						}
						return rval;
					}
					;

					// Returns a second level set entries, These are draggable.
					// "drag"
					function createEntries(parentType, parent, children) {
						var rval = [];
						var entry = {};
						_
								.each(
										children,
										function(child) {
											if (parentType === "message") {
												entry = createEntry(child,
														child.name, parent);
//												console
//														.log("createEntries entry.reference.id="
//																+ entry.reference.id
//																+ " entry.reference.name="
//																+ entry.reference.name
//																+ "entry.parent="
//																+ rval.parent);
											} else if (parentType === "table") {
												entry = createEntry(
														child,
														child.bindingIdentifier,
														parent);
											} else if (parentType === "datatype") {
												var label = $rootScope.getDatatypeLabel(child);
//												console.log("ToC datatype label=" + label);
												entry = createEntry(child,
														label, parent);
											}  else {
												entry = createEntry(child,
														child.label, parent);
											}
											rval.push(entry);
										});
						return rval;
//						return _.sortBy(rval, "label");
					}
					;

					function createEntry(child, label, parent) {

						var rval = new entry(child.id, label,
								child.sectionPosition, child.type, parent,
								child);
						return rval;
					};

          return svc;
				})

angular.module('igl').factory('VersionAndUseService',
    function($rootScope, $http, $q) {
	
	var VersionAndUseService={
			findAll:function(){
				
			},
			findById:function(id){
				console.log("loooking for "+id);
				 var delay = $q.defer();
	                    $http.get('api/versionAndUse/' + id).then(function(response) {
	                        var info = angular.fromJson(response.data);
	                        delay.resolve(info);
	                    }, function(error) {
	                        delay.reject(error);
	                    });
	                
	                return delay.promise;
				
			},
			findAllByIds:function(ids){

	                var delay = $q.defer();
	                $http.post('api/versionAndUse/findByIds', ids).then(function(response) {
	                    var datatypes = angular.fromJson(response.data);
	                    delay.resolve(datatypes);
	                }, function(error) {
	                    delay.reject(error);
	                });
	                return delay.promise;

				
			},
			update:function(info){
				
			},
			save:function(info){
            	console.log(info);
                var delay = $q.defer();
                //datatype.accountId = userInfoService.getAccountID();
                console.log("Saving");
                console.log(info);
                $http.post('api/versionAndUse/save', info).then(function(response) {
                	console.log("resopense");
                	console.log(response);
                    delay.resolve(info);
                }, function(error) {
                    //console.log("DatatypeService.save error=" + error);
                    delay.reject(error);
                });
                return delay.promise;
				
			},
			findAll:function(){
                var delay = $q.defer();
                //datatype.accountId = userInfoService.getAccountID();
                $http.post('api/versionAndUse/findAll').then(function(response) {
                    var versions = angular.fromJson(response.data);
                    delay.resolve(versions);

                }, function(error) {
                    //console.log("DatatypeService.save error=" + error);
                    delay.reject(error);
                });
                return delay.promise;
				
			}
			
	};
	
	
	
	return VersionAndUseService;
});
/**
 * Created by haffo on 5/4/15.
 */

angular.module('igl').factory('ViewSettings',
    ['StorageService', function (StorageService) {
        var columnOptions = [
            { id: "datatype", label: "Datatype"},
            { id: "valueSet", label: "Value Set"},
            { id: "predicate", label: "Predicate"},
            { id: "confStatement", label: "Conf. Statement"},
            { id: "defText", label: "Defin. Text"},
            { id: "comment", label: "Comment"}
        ];
        var selectedColumns =  {
            "datatype": true,
            "valueSet": true,
            "predicate": true,
            "confStatement": true,
            "defText": true,
            "comment": true
        };

//        var visibleColumns = StorageService.get(StorageService.TABLE_COLUMN_SETTINGS_KEY) == null ? angular.copy(columnOptions) : angular.fromJson(StorageService.get(StorageService.TABLE_COLUMN_SETTINGS_KEY));
        var visibleColumns = angular.copy(columnOptions);
        var ViewSettings = {
            columnOptions: columnOptions,
            visibleColumns: visibleColumns,
            selectedColumns: selectedColumns,
            translations: {buttonDefaultText: 'Visible Columns'},
            extra: {displayProp: 'label', buttonClasses: 'btn btn-xs btn-primary', showCheckAll: false, showUncheckAll: false, scrollable: false},
            tableRelevance:StorageService.get(StorageService.TABLE_RELEVANCE_SETTINGS) == null ? false : StorageService.get(StorageService.TABLE_RELEVANCE_SETTINGS),
            tableConcise:StorageService.get(StorageService.TABLE_CONCISE_SETTINGS) == null ? false : StorageService.get(StorageService.TABLE_CONCISE_SETTINGS),
            tableCollapse:StorageService.get(StorageService.TABLE_COLLAPSE_SETTINGS) == null ? true : StorageService.get(StorageService.TABLE_COLLAPSE_SETTINGS),
            tableReadonly:StorageService.get(StorageService.TABLE_READONLY_SETTINGS) == null ? false : StorageService.get(StorageService.TABLE_READONLY_SETTINGS),
            events: {
                onItemSelect: function (item) {
                    console.log("selected " + item);
                    ViewSettings.setVisibleColumns();
                    ViewSettings.selectedColumns[item.id] = true;
                },
                onItemDeselect: function (item) {
                    console.log("deselected " + item);
                    ViewSettings.setVisibleColumns();
                    ViewSettings.selectedColumns[item.id] = false;
                }
            },
            setVisibleColumns: function () {
                StorageService.set(StorageService.TABLE_COLUMN_SETTINGS_KEY, angular.toJson(ViewSettings.visibleColumns));
            },
            setTableConcise: function (concise) {
                ViewSettings.tableConcise = concise;
                StorageService.set(StorageService.TABLE_CONCISE_SETTINGS, ViewSettings.tableConcise);
            },
            setTableRelevance: function (relevance) {
                ViewSettings.tableRelevance = relevance;
                StorageService.set(StorageService.TABLE_RELEVANCE_SETTINGS, ViewSettings.tableRelevance);
            },
            setTableCollapse: function (collapse) {
                ViewSettings.tableCollapse = collapse;
                StorageService.set(StorageService.TABLE_COLLAPSE_SETTINGS, ViewSettings.tableCollapse);
            },
            setTableReadonly: function (value) {
                ViewSettings.tableReadonly = value;
                StorageService.set(StorageService.TABLE_READONLY_SETTINGS, ViewSettings.tableReadonly);
            },
            isVisibleColumn: function (column) {
                return ViewSettings.selectedColumns[column];
            }
        };
        return ViewSettings;
    }]);


'use strict';

/**
 * @ngdoc function
 * @name clientApp.controller:AboutCtrl
 * @description
 * # AboutCtrl
 * Controller of the clientApp
 */
angular.module('igl')
  .controller('AboutService', function ($scope) {

  });

/*jshint bitwise: false*/

'use strict';

angular.module('igl')
	.service('base64', function base64() {
    // AngularJS will instantiate a singleton by calling "new" on this function
    var keyStr = 'ABCDEFGHIJKLMNOP' +
        'QRSTUVWXYZabcdef' +
        'ghijklmnopqrstuv' +
        'wxyz0123456789+/' +
        '=';
    this.encode = function (input) {
        var output = '',
            chr1, chr2, chr3 = '',
            enc1, enc2, enc3, enc4 = '',
            i = 0;

        while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output = output +
                keyStr.charAt(enc1) +
                keyStr.charAt(enc2) +
                keyStr.charAt(enc3) +
                keyStr.charAt(enc4);
            chr1 = chr2 = chr3 = '';
            enc1 = enc2 = enc3 = enc4 = '';
        }

        return output;
    };

    this.decode = function (input) {
        var output = '',
            chr1, chr2, chr3 = '',
            enc1, enc2, enc3, enc4 = '',
            i = 0;

        // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

        while (i < input.length) {
            enc1 = keyStr.indexOf(input.charAt(i++));
            enc2 = keyStr.indexOf(input.charAt(i++));
            enc3 = keyStr.indexOf(input.charAt(i++));
            enc4 = keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output = output + String.fromCharCode(chr1);

            if (enc3 !== 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 !== 64) {
                output = output + String.fromCharCode(chr3);
            }

            chr1 = chr2 = chr3 = '';
            enc1 = enc2 = enc3 = enc4 = '';
        }
    };
});

'use strict';

angular.module('igl').factory('i18n', function() {
    // AngularJS will instantiate a singleton by calling "new" on this function   
    var language;
    var setLanguage = function (theLanguage) {
        $.i18n.properties({
            name: 'messages',
            path: 'lang/',
            mode: 'map',
            language: theLanguage,
            callback: function () {
                language = theLanguage;
            }
        });
    };
    setLanguage('en');
    return {
        setLanguage: setLanguage
    };
});

/*angular.module('ehrRandomizerApp')
  .service('i18n', function i18n() {
    // AngularJS will instantiate a singleton by calling "new" on this function
    var self = this;
    this.setLanguage = function (language) {
        $.i18n.properties({
            name: 'messages',
            path: 'lang/',
            mode: 'map',
            language: language,
            callback: function () {
                self.language = language;
            }
        });
    };
    this.setLanguage('en');
  });*/
'use strict';

/**
 * @ngdoc function
 * @description # AboutCtrl Controller of the clientApp
 */
//
// // Declare factory
// angular.module('igl').factory('Profiles', function(Restangular) {
// return Restangular.service('profiles');
// });

angular.module('igl').factory('Section', function($http, $q) {
	var Section = function() {
		this.data = null;
		this.type = null;
		this.sections = [];
	};
	return Section;
});

angular.module('igl').factory('IGDocumentSvc', function($http, $q, $rootScope) {
	var IGDocumentSvc = {
		loadIgDocumentMetaData : function() {
			var delay = $q.defer();
			if ($rootScope.config || $rootScope.config === null) {
				$http.get('api/igdocuments/config').then(function(response) {
					$rootScope.config = angular.fromJson(response.data);
					delay.resolve($rootScope.config);
				}, function(error) {
					delay.reject(error);
				});
			} else {
				delay.resolve($rootScope.config);
			}
			return delay.promise;
		}
	}
	
	return IGDocumentSvc;
});

'use strict';

/**
 * @ngdoc function
 * @name clientApp.controller:MainCtrl
 * @description
 * # MainCtrl
 * Controller of the clientApp
 */
angular.module('igl')
  .controller('MainService', function ($scope) {
  });

/**
 * http://usejsdoc.org/
 */
angular.module('igl').factory('PcLibraryService', function($http, $httpBackend, $q, userInfoService) {

    var svc = this;
    svc.getProfileComponentsByLibrary = function(pcLibId) {
            return $http.get(
                    'api/profilecomponent-library/' + pcLibId + '/profilecomponents')
                .then(function(response) {
                    //					console.log("response" + JSON.stringify(response));
                    return angular.fromJson(response.data);
                });
        },
        svc.getProfileComponentLibrary = function(pcLibId) {
            return $http.get(
                    'api/profilecomponent-library/' + pcLibId)
                .then(function(response) {
                    //					console.log("response" + JSON.stringify(response));
                    return angular.fromJson(response.data);
                });
        },
        svc.addComponentToLib = function(igId, pc) {
            var delay = $q.defer();

            $http.post('api/profilecomponent-library/' + igId + '/add', pc).then(function(response) {

                console.log(response);
                var saved = angular.fromJson(response.data);
                delay.resolve(saved);
                return saved;
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        },
        svc.addComponentsToLib = function(igId, pcs) {
            var delay = $q.defer();

            $http.post('api/profilecomponent-library/' + igId + '/addMult', pcs).then(function(response) {

                console.log(response);
                var saved = angular.fromJson(response.data);
                delay.resolve(saved);
                return saved;
            }, function(error) {
                delay.reject(error);
            });
            return delay.promise;
        }




    return svc;
});
/**
 * Created by haffo on 2/6/15.
 */

//
//
//// Declare factory
//angular.module('igl').factory('Users', function(Restangular) {
//    return Restangular.service('users');
//});
//


'use strict';

angular.module('igl').filter('bytes', [
    function () {
        return function (bytes, precision) {
            if (isNaN(parseFloat(bytes)) || !isFinite(bytes)) { return '-'; }
            if (typeof precision === 'undefined') { precision = 1; }
            var units = ['bytes', 'kB', 'MB', 'GB', 'TB', 'PB'],
                number = Math.floor(Math.log(bytes) / Math.log(1024));
            return (bytes / Math.pow(1024, Math.floor(number))).toFixed(precision) +  ' ' + units[number];
        };
    }
]);

/**
 * Created by haffo on 3/3/16.
 */

angular.module('igl').filter('flavors',function(){
    return function(inputArray,name){
        return inputArray.filter(function(item){
            return item.name === name || angular.equals(item.name,name);
        });
    };
});
/**
 * Created by haffo on 4/14/16.
 */

angular.module('igl').filter('propsFilter', function() {
    return function(items, props) {
        var out = [];

        if (angular.isArray(items)) {
            var keys = Object.keys(props);

            items.forEach(function(item) {
                var itemMatches = false;

                for (var i = 0; i < keys.length; i++) {
                    var prop = keys[i];
                    var text = props[prop].toLowerCase();
                    if (item[prop].toString().toLowerCase().indexOf(text) !== -1) {
                        itemMatches = true;
                        break;
                    }
                }

                if (itemMatches) {
                    out.push(item);
                }
            });
        } else {
            // Let the output be the input untouched
            out = items;
        }

        return out;
    };
});
angular.module('igl').filter('startsWith', function() {
    return function(input, alpha, property){
		
		var _out = [];

		if(angular.isUndefined(alpha)){
			_out = input;
		}
		
		angular.forEach(input, function(item){
			var filteritem = item;
			if(angular.isDefined(property) && item[property]){
				filteritem = item[property];
			}

			if(_(filteritem).startsWith(alpha)){
				_out.push(item);
			}
		});
		return _out;
	};
});

'use strict';

angular.module('igl').filter('yesno', [ function () {
    return function (input) {
        return input ? 'YES' : 'NO';
    };
}]);
angular
  .module('angularjs-dropdown-multiselect', [])
  .directive('ngDropdownMultiselect', ['$filter', '$document', '$compile', '$parse',

function ($filter, $document, $compile, $parse) {

    return {
        restrict: 'AE',
        scope: {
            selectedModel: '=',
            options: '=',
            extraSettings: '=',
            events: '=',
            searchFilter: '=?',
            translationTexts: '=',
            groupBy: '@'
        },
        template: function (element, attrs) {
            var checkboxes = attrs.checkboxes ? true : false;
            var groups = attrs.groupBy ? true : false;

            var template = '<div class="multiselect-parent btn-group dropdown-multiselect">';
            template += '<button type="button" class="dropdown-toggle" ng-class="settings.buttonClasses" ng-click="toggleDropdown()">{{getButtonText()}}&nbsp;<span class="caret"></span></button>';
            template += '<ul class="dropdown-menu dropdown-menu-form" ng-style="{display: open ? \'block\' : \'none\', height : settings.scrollable ? settings.scrollableHeight : \'auto\' }" style="overflow: scroll" >';
            template += '<li ng-hide="!settings.showCheckAll || settings.selectionLimit > 0"><a data-ng-click="selectAll()"><span class="glyphicon glyphicon-ok"></span>  {{texts.checkAll}}</a>';
            template += '<li ng-show="settings.showUncheckAll"><a data-ng-click="deselectAll();"><span class="glyphicon glyphicon-remove"></span>   {{texts.uncheckAll}}</a></li>';
            template += '<li ng-hide="(!settings.showCheckAll || settings.selectionLimit > 0) && !settings.showUncheckAll" class="divider"></li>';
            template += '<li ng-show="settings.enableSearch"><div class="dropdown-header"><input type="text" class="form-control" style="width: 100%;" ng-model="searchFilter" placeholder="{{texts.searchPlaceholder}}" /></li>';
            template += '<li ng-show="settings.enableSearch" class="divider"></li>';

            if (groups) {
                template += '<li ng-repeat-start="option in orderedItems | filter: searchFilter" ng-show="getPropertyForObject(option, settings.groupBy) !== getPropertyForObject(orderedItems[$index - 1], settings.groupBy)" role="presentation" class="dropdown-header">{{ getGroupTitle(getPropertyForObject(option, settings.groupBy)) }}</li>';
                template += '<li ng-repeat-end role="presentation">';
            } else {
                template += '<li role="presentation" ng-repeat="option in options | filter: searchFilter">';
            }

            template += '<a role="menuitem" tabindex="-1" ng-click="setSelectedItem(getPropertyForObject(option,settings.idProp))">';

            if (checkboxes) {
                template += '<div class="checkbox"><label><input class="checkboxInput" type="checkbox" ng-click="checkboxClick($event, getPropertyForObject(option,settings.idProp))" ng-checked="isChecked(getPropertyForObject(option,settings.idProp))" /> {{getPropertyForObject(option, settings.displayProp)}}</label></div></a>';
            } else {
                template += '<span data-ng-class="{\'glyphicon glyphicon-ok\': isChecked(getPropertyForObject(option,settings.idProp))}"></span> {{getPropertyForObject(option, settings.displayProp)}}</a>';
            }

            template += '</li>';

            template += '<li class="divider" ng-show="settings.selectionLimit > 1"></li>';
            template += '<li role="presentation" ng-show="settings.selectionLimit > 1"><a role="menuitem">{{selectedModel.length}} {{texts.selectionOf}} {{settings.selectionLimit}} {{texts.selectionCount}}</a></li>';

            template += '</ul>';
            template += '</div>';

            element.html(template);
        },
        link: function ($scope, $element, $attrs) {
            var $dropdownTrigger = $element.children()[0];

            $scope.toggleDropdown = function () {
                $scope.open = !$scope.open;
            };

            $scope.checkboxClick = function ($event, id) {
                $scope.setSelectedItem(id);
                $event.stopImmediatePropagation();
            };

            $scope.externalEvents = {
                onItemSelect: angular.noop,
                onItemDeselect: angular.noop,
                onSelectAll: angular.noop,
                onDeselectAll: angular.noop,
                onInitDone: angular.noop,
                onMaxSelectionReached: angular.noop
            };

            $scope.settings = {
                dynamicTitle: true,
                scrollable: false,
                scrollableHeight: '300px',
                closeOnBlur: true,
                displayProp: 'name',
                idProp: 'id',
                externalIdProp: 'id',
                enableSearch: true,
                selectionLimit: 0,
                showCheckAll: true,
                showUncheckAll: true,
                closeOnSelect: false,
                buttonClasses: 'btn btn-xs',
                closeOnDeselect: false,
                 groupBy: $attrs.groupBy || undefined,
                groupByTextProvider: null,
                smartButtonMaxItems: 0,
                smartButtonTextConverter: angular.noop
            };

            $scope.texts = {
                checkAll: 'Check All',
                uncheckAll: 'Uncheck All',
                selectionCount: 'checked',
                selectionOf: '/',
                searchPlaceholder: 'Search...',
                buttonDefaultText: 'Select',
                dynamicButtonTextSuffix: 'checked'
            };

            $scope.searchFilter = $scope.searchFilter || '';

            if (angular.isDefined($scope.settings.groupBy)) {
                $scope.$watch('options', function (newValue) {
                    if (angular.isDefined(newValue)) {
                        $scope.orderedItems = $filter('orderBy')(newValue, $scope.settings.groupBy);
                    }
                });
            }

            angular.extend($scope.settings, $scope.extraSettings || []);
            angular.extend($scope.externalEvents, $scope.events || []);
            angular.extend($scope.texts, $scope.translationTexts);

            $scope.singleSelection = $scope.settings.selectionLimit === 1;

            function getFindObj(id) {
                var findObj = {};

                if ($scope.settings.externalIdProp === '') {
                    findObj[$scope.settings.idProp] = id;
                } else {
                    findObj[$scope.settings.externalIdProp] = id;
                }

                return findObj;
            }

            function clearObject(object) {
                for (var prop in object) {
                    delete object[prop];
                }
            }

            if ($scope.singleSelection) {
                if (angular.isArray($scope.selectedModel) && $scope.selectedModel.length === 0) {
                    clearObject($scope.selectedModel);
                }
            }

            if ($scope.settings.closeOnBlur) {
                $document.on('click', function (e) {
                    var target = e.target.parentElement;
                    var parentFound = false;

                    while (angular.isDefined(target) && target !== null && !parentFound) {
                        if (_.contains(target.className.split(' '), 'multiselect-parent') && !parentFound) {
                            if (target === $dropdownTrigger) {
                                parentFound = true;
                            }
                        }
                        target = target.parentElement;
                    }

                    if (!parentFound) {
                        $scope.$apply(function () {
                            $scope.open = false;
                        });
                    }
                });
            }

            $scope.getGroupTitle = function (groupValue) {
                if ($scope.settings.groupByTextProvider !== null) {
                    return $scope.settings.groupByTextProvider(groupValue);
                }

                return groupValue;
            };

//            $scope.getButtonText = function () {
//                if ($scope.settings.dynamicTitle && ($scope.selectedModel.length > 0 || (angular.isObject($scope.selectedModel) && _.keys($scope.selectedModel).length > 0))) {
//                    if ($scope.settings.smartButtonMaxItems > 0) {
//                        var itemsText = [];
//
//                        angular.forEach($scope.options, function (optionItem) {
//                            if ($scope.isChecked($scope.getPropertyForObject(optionItem, $scope.settings.idProp))) {
//                                var displayText = $scope.getPropertyForObject(optionItem, $scope.settings.displayProp);
//                                var converterResponse = $scope.settings.smartButtonTextConverter(displayText, optionItem);
//
//                                itemsText.push(converterResponse ? converterResponse : displayText);
//                            }
//                        });
//
//                        if ($scope.selectedModel.length > $scope.settings.smartButtonMaxItems) {
//                            itemsText = itemsText.slice(0, $scope.settings.smartButtonMaxItems);
//                            itemsText.push('...');
//                        }
//
//                        return itemsText.join(', ');
//                    } else {
//                        var totalSelected;
//
//                        if ($scope.singleSelection) {
//                            totalSelected = ($scope.selectedModel !== null && angular.isDefined($scope.selectedModel[$scope.settings.idProp])) ? 1 : 0;
//                        } else {
//                            totalSelected = angular.isDefined($scope.selectedModel) ? $scope.selectedModel.length : 0;
//                        }
//
//                        if (totalSelected === 0) {
//                            return $scope.texts.buttonDefaultText;
//                        }  else {
//                            return totalSelected + ' ' + $scope.texts.dynamicButtonTextSuffix;
//                        }
//                    }
//                } else {
//                    return $scope.texts.buttonDefaultText;
//                }
//            };

            $scope.getPropertyForObject = function (object, property) {
                if (angular.isDefined(object) && object.hasOwnProperty(property)) {
                    return object[property];
                }

                return '';
            };

            $scope.selectAll = function () {
                $scope.deselectAll(false);
                $scope.externalEvents.onSelectAll();

                angular.forEach($scope.options, function (value) {
                    $scope.setSelectedItem(value[$scope.settings.idProp], true);
                });
            };

            $scope.deselectAll = function (sendEvent) {
                sendEvent = sendEvent || true;

                if (sendEvent) {
                    $scope.externalEvents.onDeselectAll();
                }

                if ($scope.singleSelection) {
                    clearObject($scope.selectedModel);
                } else {
                    $scope.selectedModel.splice(0, $scope.selectedModel.length);
                }
            };

            $scope.setSelectedItem = function (id, dontRemove) {
                var findObj = getFindObj(id);
                var finalObj = null;

                if ($scope.settings.externalIdProp === '') {
                    finalObj = _.find($scope.options, findObj);
                } else {
                    finalObj = findObj;
                }

                if ($scope.singleSelection) {
                    clearObject($scope.selectedModel);
                    angular.extend($scope.selectedModel, finalObj);
                    $scope.externalEvents.onItemSelect(finalObj);
                    if ($scope.settings.closeOnSelect) $scope.open = false;

                    return;
                }

                dontRemove = dontRemove || false;

                var exists = _.findIndex($scope.selectedModel, findObj) !== -1;

                if (!dontRemove && exists) {
                    $scope.selectedModel.splice(_.findIndex($scope.selectedModel, findObj), 1);
                    $scope.externalEvents.onItemDeselect(findObj);
                } else if (!exists && ($scope.settings.selectionLimit === 0 || $scope.selectedModel.length < $scope.settings.selectionLimit)) {
                    $scope.selectedModel.push(finalObj);
                    $scope.externalEvents.onItemSelect(finalObj);
                }
                if ($scope.settings.closeOnSelect) $scope.open = false;
            };

            $scope.isChecked = function (id) {
                if ($scope.singleSelection) {
                    return $scope.selectedModel !== null && angular.isDefined($scope.selectedModel[$scope.settings.idProp]) && $scope.selectedModel[$scope.settings.idProp] === getFindObj(id)[$scope.settings.idProp];
                }

                return _.findIndex($scope.selectedModel, getFindObj(id)) !== -1;
            };

            $scope.externalEvents.onInitDone();
        }
    };
}]);

angular.module('igl').directive('preventRightClick', [

function() {
	return {
		restrict : 'A',
		link : function($scope, $ele) {
			$ele.bind("contextmenu", function(e) {
				e.preventDefault();
			});
		}
	};
} ])
angular
		.module('igl')
		.directive(
				'trunk',
				function() {
//					console.log("trunk");

					var template = "<ul class='trunk'><branch ng-repeat='branch in trunk track by trackBy()' branch='branch'></branch></ul>";

					return {
						restrict : "E",
						replace : true,
						controller : "ToCCtl",
						scope : {
							trunk : '='
						},
						template : template
					}
				})
		.directive(
				'drop',
				function() {
//					console.log("drop");

					var template = "<ul dnd-list='drop'>"
							+ "<branch ng-repeat='branch in drop track by $index' index='$index' branch='branch' drop='drop'></branch>"
							+ "</ul>";

					return {
						restrict : "E",
						replace : true,
						scope : {
							drop : '='
						},
						template : template
					}
				})
		.directive(
				"branch",
				function($compile) {
					var branchNoCtxTemplate = "<li class='branch' prevent-right-click>"
						+ "<label for='{{branch.id}}' class='fa fa-lg' ng-class=\" {'fa-caret-right': branch.selected,'fa-caret-down': !branch.selected} \" />"
						+ "</label>"
						+ "<input type='checkbox' id='{{branch.id}}' ng-model='branch.selected'/>"
						+ "<a ng-click='tocSelection(branch)' ng-class=\" {'toc-selected' : branch.highlight, 'selected': models.selected === branch} \" >{{branch.label}}</a>"
						+ "<trunk trunk='branch.children'></trunk>"
						+ "</li>";
					var branchTemplate = "<li class='branch'"
						+ " context-menu context-menu-close='closedCtxSubMenu(branch)' data-target='contextDiv.html''> "
						+ "<label for='{{branch.id}}' class='fa fa-lg' ng-class=\" {'fa-caret-right': branch.selected,'fa-caret-down': !branch.selected} \" />"
						+ "</label>"
						+ "<input type='checkbox' id='{{branch.id}}' ng-model='branch.selected'/>"
						+ "<a ng-click='tocSelection(branch)' ng-class=\" {'toc-selected' : branch.highlight, 'selected': models.selected === branch} \" >{{branch.label}}</a>"
						+ "<trunk trunk='branch.children'></trunk>"
						+ "</li>";
					var branchMessagesTemplate = "<li class='branch'"
						+ " context-menu context-menu-close='closedCtxSubMenu(branch)' data-target='messageHeadContextDiv.html'>"
						+ "<label for='{{branch.id}}' class='fa fa-lg' ng-class=\" {'fa-caret-right': branch.selected,'fa-caret-down': !branch.selected} \" />"
						+ "<input type='checkbox' id='{{branch.id}}'ng-model='branch.selected'/>"
						+ "<a ng-click='tocSelection(branch)' ng-class=\" {'toc-selected' : branch.highlight, 'selected': models.selected === branch} \" >{{branch.label}}</a>"
						+ "<drop drop='branch.children'></drop>"
						+ "</li>";
					var branchTablesTemplate = "<li class='branch'"
						+ " context-menu context-menu-close='closedCtxSubMenu(branch)' data-target='tableHeadContextDiv.html'>"
						+ "<label for='{{branch.id}}' class='fa fa-lg' ng-class=\" {'fa-caret-right': branch.selected,'fa-caret-down': !branch.selected} \" />"
						+ "</label>"
						+ "<input type='checkbox' id='{{branch.id}}' ng-model='branch.selected'/>"
						+ "<a ng-click='tocSelection(branch)' ng-class=\" {'toc-selected' : branch.highlight, 'selected': models.selected === branch} \" >{{branch.label}}</a>"
						+ "<drop drop='branch.children'></drop>"
						+ "</li>";
					var leafTemplate = "<leaf leaf='branch' index='index'></leaf>";

					var linker = function(scope, element, attrs) {
//						console.log("<=label=" + scope.branch.label);
						if (angular.isArray(scope.branch.children)) {
//							 console.log("branch id=" + scope.branch.id + " branch type=" + scope.branch.type +
//							 " label=" + scope.branch.label + " children=" +
//							 scope.branch.children.length);
							if ( _.indexOf(["profile", "segments", "datatypes"], scope.branch.type) > -1) {
								element.append(branchNoCtxTemplate);
							} else if (scope.branch.type === "messages") {
								element.append(branchMessagesTemplate);
							} else if (scope.branch.type === "tables") {
								element.append(branchTablesTemplate);
							} else {
								element.append(branchTemplate);
							}
							$compile(element.contents())(scope);

						} else {
//							console.log("leaf id=" + scope.branch.id + " leaf type="  + scope.branch.type + " leaf label="  + scope.branch.label + " parent=" + scope.branch.parent.type);
							element.append(leafTemplate).show();
							$compile(element.contents())(scope);
						}
					};

					return {
						restrict : "E",
						replace : true,
						controller : "ToCCtl",
						scope : {
							index : '=',
							drop : '=',
							branch : '='
						},
						link : linker
					}
				})
		.directive(
				"leaf",
				function($compile) {

					var leafMetadata = "<li class='point leaf'"
						+ "  prevent-right-click> "
						+ "<a ng-click='tocSelection(leaf)' ng-class=\" {'toc-selected' : leaf.highlight, 'selected': models.selected === leaf} \" >{{leaf.label}}</a>"
						+ "</li>";

					var leafMessage = "<li class='point leaf'"
			            + " ng-show='show(leaf)'"
			            + " dnd-draggable='leaf'"
			            + " dnd-effect-allowed='move'"
			            + " dnd-moved='moved(index, leaf)'"
			            + " dnd-selected='models.selected = leaf'"
						+ " context-menu context-menu-close='closedCtxSubMenu(leaf)' data-target='messageContextDiv.html'> "
						+ "<a ng-click='tocSelection(leaf)' ng-class=\" {'toc-selected' : leaf.highlight, 'selected': models.selected === leaf} \" >{{leaf.reference.name}} - {{leaf.reference.description}}</a>"
						+ "</li>";

					var leafValueSet = "<li class='point leaf'"
            + " ng-show='show(leaf)'"
						+ " context-menu context-menu-close='closedCtxSubMenu(leaf)' data-target='contextDiv.html'> "
						+ "<a ng-click='tocSelection(leaf)' ng-class=\" {'toc-selected' : leaf.highlight, 'selected': models.selected === leaf} \" >{{leaf.reference.bindingIdentifier}} - {{leaf.reference.name}}</a>"
						+ "</li>";

					var leafSection = "<li class='point leaf'"
						+ " context-menu context-menu-close='closedCtxSubMenu(leaf)' data-target='contextDiv.html'> "
						+ "<a ng-click='tocSelection(leaf)' ng-class=\" {'toc-selected' : leaf.highlight, 'selected': models.selected === leaf} \" >{{leaf.reference.sectionTitle}}</a>"

					var leafDefault = "<li class='point leaf'"
            + " ng-show='show(leaf)'"
						+ " context-menu context-menu-close='closedCtxSubMenu(leaf)' data-target='contextDiv.html'> "
						+ "<a ng-click='tocSelection(leaf)' ng-class=\" {'toc-selected' : leaf.highlight, 'selected': models.selected === leaf} \" >{{leaf.label}} - {{leaf.reference.description}}</a>"
						+ "</li>";

					var linker = function(scope, element, attrs) {
						if (_.indexOf(["documentMetadata", "profileMetadata"] ,scope.leaf.type) > -1) {
							element.html(leafMetadata).show();
//							console.log("leafMeta=" + scope.leaf.label + " type=" + scope.leaf.type + " parent=" + scope.leaf.parent);
						} else if (scope.leaf.type === "section") {
							element.html(leafSection).show();
//							console.log("leafSection=" + scope.leaf.label + " type=" + scope.leaf.type  + " parent=" + scope.leaf.parent);
						} else if (scope.leaf.type === "message") {
							element.html(leafMessage).show();
//							console.log("leafMessage=" + scope.leaf.label + " type=" + scope.leaf.type  + " parent=" + scope.leaf.parent + " leaf.reference.id=" + scope.leaf.reference.id + " leaf.reference.position=" + scope.leaf.reference.position);
						} else if (scope.leaf.type === "table") {
							element.html(leafValueSet).show();
//								console.log("leafTable=" + scope.leaf.label + " type=" + scope.leaf.type  + " parent=" + scope.leaf.parent);
						} else {
							element.html(leafDefault).show();
							console.log("ToCDir leafDefault label=" + scope.leaf.label + " type=" + scope.leaf.type);
//							console.log("leafDefault=" + scope.leaf.label + " parent=" + scope.leaf.parent);
						}
						$compile(element.contents())(scope);
					};

					return {
						restrict : "E",
						replace : true,
						controller : "ToCCtl",
						scope : {
							index : '=',
							leaf : '=',
							drop : '='
						},
						link : linker
					}
				});

/**
 * Created by haffo on 4/5/15.
 */
angular.module('igl').directive('click', ['$location', function($location) {
        return {
            link: function(scope, element, attrs) {
                element.on('click', function() {
                    scope.$apply(function() {
                        $location.path(attrs.clickGo);
                    });
                });
            }
        }
    }]);


//angular.module('igl').directive('csSelect', function () {
//    return {
//        require: '^stTable',
//        template: '',
//        scope: {
//            row: '=csSelect'
//        },
//        link: function (scope, element, attr, ctrl) {
//
//            element.bind('change', function (evt) {
//                scope.$apply(function () {
//                    ctrl.select(scope.row, 'single');
//                });
//            });
//
//            scope.$watch('row.isSelected', function (newValue, oldValue) {
//                if (newValue === true) {
//                    element.parent().addClass('st-selected');
//                } else {
//                    element.parent().removeClass('st-selected');
//                }
//            });
//        }
//    };
//});

/**
 * Created by haffo on 10/20/15.
 */
angular.module('igl').directive('compile', function ($compile) {
    return function(scope, element, attrs) {
        scope.$watch(
            function(scope) {
                // watch the 'compile' expression for changes
                return scope.$eval(attrs.compile);
            },
            function(value) {
                // when the 'compile' expression changes
                // assign it into the current DOM
                element.html(value);

                // compile the new DOM and link it to the current
                // scope.
                // NOTE: we only compile .childNodes so that
                // we don't get into infinite loop compiling ourselves
                $compile(element.contents())(scope);
            }
        );
    };
});
/**
 * Created by haffo on 5/20/16.
 */

angular.module('igl').directive('confirmOnLeave', function ($rootScope,$location) {
    return {
        priority:-100,
        link: function ($scope, elem, attrs) {
            window.onbeforeunload = function () {
                if ($rootScope.hasChanges()) {
                    return "You have unsaved data on this page. If you leave this page your data will be lost.\n\n Are you sure you want to leave this page?";
                }
            };
            $scope.$on('$locationChangeStart', function (event, next, current) {
                if ($rootScope.hasChanges()) {
                    event.preventDefault();
                    $rootScope.openConfirmLeaveDlg().result.then(function () {
                        $rootScope.clearChanges();
                        var go = next.substring(next.indexOf("#")+1,next.length);
                        $location.path(go);
                    },function(){

                    });
                }
            });
        }




    };
});
/**
 * Created by haffo on 2/13/15.
 */


angular.module('igl').directive('csSelect', function () {
    return {
        require: '^stTable',
        template: '',
        scope: {
            row: '=csSelect'
        },
        link: function (scope, element, attr, ctrl) {

            element.bind('change', function (evt) {
                scope.$apply(function () {
                    ctrl.select(scope.row, 'single');
                });
            });

            scope.$watch('row.isSelected', function (newValue, oldValue) {
                if (newValue === true) {
                    element.parent().addClass('st-selected');
                } else {
                    element.parent().removeClass('st-selected');
                }
            });
        }
    };
});
angular.module('igl').directive('windowExit', function($window, $templateCache,$http, $rootScope,StorageService,IgDocumentService,ViewSettings,AutoSaveService) {
    return {
        restrict: 'AE',
        //performance will be improved in compile
        compile: function(element, attrs){
            var myEvent = $window.attachEvent || $window.addEventListener,
                chkevent = $window.attachEvent ? 'onbeforeunload' : 'beforeunload'; /// make IE7, IE8 compatable
            myEvent(chkevent, function (e) { // For >=IE7, Chrome, Firefox
                $templateCache.removeAll();
            });
        }
    };
});
'use strict';

angular.module('igl')
.directive('focus', [function () {
    return {
        restrict: 'EAC',
        link: function(scope, element, attrs) {
//            element[0].focus();
        }
    };
}]);

'use strict';

angular.module('igl').directive('igCheckEmail', [ '$resource',
    function ($resource) {
        return {
            restrict: 'AC',
            require: 'ngModel',
            link: function (scope, element, attrs, ctrl) {
                var Email = $resource('api/sooa/emails/:email', {email: '@email'});

                var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$/;

                element.on('keyup', function() {
                    if ( element.val().length !== 0 && EMAIL_REGEXP.test(element.val()) ) {
                        var emailToCheck = new Email({email:element.val()});
                        emailToCheck.$get(function() {
                            scope.emailUnique  = ((emailToCheck.text === 'emailNotFound') ? 'valid' : undefined);
                            scope.emailValid = (EMAIL_REGEXP.test(element.val()) ? 'valid' : undefined);
                            if(scope.emailUnique && scope.emailValid) {
                                ctrl.$setValidity('email', true);
                            } else {
                                ctrl.$setValidity('email', false);
                            }

                        }, function() {
//                            console.log('FAILURE to check email address');
                        });
                    }
                    else {
                        scope.emailUnique  = undefined;
                        scope.emailValid = undefined;
                        ctrl.$setValidity('email', false);
                    }
                });
            }
        };
    }
]);

'use strict';

//This directive is used to make sure both passwords match
angular.module('igl').directive('igCheckEmployer', [
    function () {
        return {
            require: 'ngModel',
            link: function (scope, elem, attrs, ctrl) {
                var employer = '#' + attrs.igCheckEmployer;
                elem.add(employer).on('keyup', function () {
                    scope.$apply(function () {
//                        console.log('Pass1=', elem.val(), ' Pass2=', $(firstPassword).val());
                        var v = elem.val()===$(firstPassword).val();
                        ctrl.$setValidity('noMatch', v);
                    });
                });
            }
        };
    }
]);
'use strict';

angular.module('igl').directive('igCheckFullName', [ '$resource',
    function ($resource) {
        return {
            restrict: 'AC',
            require: 'ngModel',
            link: function (scope, element, attrs, ctrl) {
                var FullName = $resource('api/sooa/fullnames/:fullName', {fullName: '@fullName'});

                element.on('keyup', function() {
                    if ( element.val().length >= 4) {
                        var fullNameToCheck = new FullName({fullName:element.val()});
                        fullNameToCheck.$get(function() {
                            scope.fullNameUnique  = ((fullNameToCheck.text === 'fullNameNotFound') ? 'valid' : undefined);
                            scope.fullNameValid = 'valid';
                            if(scope.fullNameUnique && scope.fullNameValid) {
                                ctrl.$setValidity('fullName', true);
                            } else {
                                ctrl.$setValidity('fullName', false);
                            }

                        }, function() {
//                            console.log('FAILURE to check email address');
                        });
                    }
                    else {
                        scope.fullNameUnique  = undefined;
                        scope.fullNameValid = undefined;
                        ctrl.$setValidity('fullName', false);
                    }
                });
            }
        };
    }
]);

'use strict';

//This directive is used to make sure both passwords match
angular.module('igl').directive('igCheckPassword', [
    function () {
        return {
            require: 'ngModel',
            link: function (scope, elem, attrs, ctrl) {
                var firstPassword = '#' + attrs.igCheckPassword;
                elem.add(firstPassword).on('keyup', function () {
                    scope.$apply(function () {
//                        console.log('Pass1=', elem.val(), ' Pass2=', $(firstPassword).val());
                        var v = elem.val()===$(firstPassword).val();
                        ctrl.$setValidity('noMatch', v);
                    });
                });
            }
        };
    }
]);
'use strict';

angular.module('igl').directive('igCheckPhone', [
    function () {
        return {
            restrict: 'AC',
            require: 'ngModel',
            link: function (scope, element, attrs, ctrl) {
                var NUMBER_REGEXP = /[0-9]*/;
                element.on('keyup', function() {
                     if ( element.val() &&  element.val() != null && element.val() != "") {
                             scope.phoneIsNumber  =  (NUMBER_REGEXP.test(element.val()))   && element.val() > 0 ? 'valid' : undefined;
                             scope.phoneValidLength  = element.val().length >= 7 ? 'valid' : undefined;
                             if(scope.phoneIsNumber && scope.phoneValidLength ) {
                                 ctrl.$setValidity('phone', true);
                             } else {
                                 ctrl.$setValidity('phone', false);
                             }
                     }
                     else {
                         scope.phoneIsNumber = undefined;
                         scope.phoneValidLength = undefined;
                         ctrl.$setValidity('phone', true);
                     }
                 });
            }
        };
    }
]);

'use strict';

angular.module('igl').directive('igCheckPoaDate', [
    function () {
        return {
            replace: true,
            link: function (scope, elem, attrs, ctrl) {
                var startElem = elem.find('#inputStartDate');
                var endElem = elem.find('#inputEndDate');

                var ctrlStart = startElem.inheritedData().$ngModelController;
                var ctrlEnd = endElem.inheritedData().$ngModelController;

                var checkDates = function() {
                    var sDate = new Date(startElem.val());
                    var eDate = new Date(endElem.val());
                    if ( sDate < eDate ) {
                        //console.log("Good!");
                        ctrlStart.$setValidity('datesOK', true);
                        ctrlEnd.$setValidity('datesOK', true);
                    }
                    else {
                        //console.log(":(");
                        ctrlStart.$setValidity('datesOK', false);
                        ctrlEnd.$setValidity('datesOK', false);
                    }
                };

                startElem.on('change', checkDates);
                endElem.on('change', checkDates);
            }
        };
    }
]);
'use strict';

//This directive is used to make sure the start hour of a timerange is < of the end hour 
angular.module('igl').directive('igCheckTimerange', [
    function () {
        return {
            replace: true,
            link: function (scope, elem, attrs, ctrl) {
                //elem is a div element containing all the select input
                //each one of them has a class for easy selection
                var myElem = elem.children();
                var sh = myElem.find('.shour');
                var sm = myElem.find('.sminute');
                var eh = myElem.find('.ehour');
                var em = myElem.find('.eminute');

                var ctrlSH, ctrlSM, ctrlEH, ctrlEM;
                ctrlSH = sh.inheritedData().$ngModelController;
                ctrlSM = sm.inheritedData().$ngModelController;
                ctrlEH = eh.inheritedData().$ngModelController;
                ctrlEM = em.inheritedData().$ngModelController;
               
                var newnew = true;

                var checkTimeRange = function() {
                    if ( newnew ) {
                        //We only do that once to set the $pristine field to false
                        //Because if $pristine==true, and $valid=false, the visual feedback 
                        //are not displayed
                        ctrlSH.$setViewValue(ctrlSH.$modelValue);
                        ctrlSM.$setViewValue(ctrlSM.$modelValue);
                        ctrlEH.$setViewValue(ctrlEH.$modelValue);
                        ctrlEM.$setViewValue(ctrlEM.$modelValue);
                        newnew = false;
                    }
                    //Getting a date object
                    var tmpDate = new Date();
                    //init the start time with the dummy date
                    var startTime = angular.copy(tmpDate);
                    //init the end time with the same dummy date
                    var endTime =  angular.copy(tmpDate);

                    startTime.setHours(sh.val());
                    startTime.setMinutes(sm.val());
                    endTime.setHours(eh.val());
                    endTime.setMinutes(em.val());
                    
                    if ( startTime < endTime ) {
                        //console.log("Excellent!");
                        ctrlSH.$setValidity('poaOK', true);
                        ctrlSM.$setValidity('poaOK', true);
                        ctrlEH.$setValidity('poaOK', true);
                        ctrlEM.$setValidity('poaOK', true);
                    }
                    else {
                        //console.log("Bad... :(");
                        ctrlSH.$setValidity('poaOK', false);
                        ctrlSM.$setValidity('poaOK', false);
                        ctrlEH.$setValidity('poaOK', false);
                        ctrlEM.$setValidity('poaOK', false);
                    }
                };

                sh.on('change', checkTimeRange);
                sm.on('change', checkTimeRange);
                eh.on('change', checkTimeRange);
                em.on('change', checkTimeRange);
            }
        };
    }
]);
'use strict';

angular.module('igl').directive('igCheckUsername', [ '$resource',
	function ($resource) {
	    return {
	        restrict: 'AC',
	        require: 'ngModel',
	        link: function (scope, element, attrs, ctrl) {
	            var Username = $resource('api/sooa/usernames/:username', {username: '@username'});

	            element.on('keyup', function() {
	                if ( element.val().length >= 4 ) {
	                    var usernameToCheck = new Username({username:element.val()});
	                    //var delay = $q.defer();
	                    usernameToCheck.$get(function() {
	                        scope.usernameValidLength  = (element.val() && element.val().length >= 4 && element.val().length <= 20 ? 'valid' : undefined);
	                        scope.usernameUnique  = ((usernameToCheck.text === 'usernameNotFound') ? 'valid' : undefined);

	                        if(scope.usernameValidLength && scope.usernameUnique ) {
	                            ctrl.$setValidity('username', true);
	                        } else {
	                            ctrl.$setValidity('username', false);
	                        }

	                    }, function() {
	                        //console.log("FAILURE", usernameToCheck);
	                    });
	                }
	                else {
	                    scope.usernameValidLength = undefined;
	                    scope.usernameUnique = undefined;
	                    ctrl.$setValidity('username', false);
	                }
	            });
	        }
	    };
	}
]);

'use strict';

//This directive is used to check password to make sure they meet the minimum requirements
angular.module('igl').directive('igPasswordValidate', [
	function () {
	    return {
	        require: 'ngModel',
	        link: function(scope, elm, attrs, ctrl) {
	            ctrl.$parsers.unshift(function(viewValue) {

	                scope.pwdValidLength = (viewValue && viewValue.length >= 7 ? 'valid' : undefined);
	                scope.pwdHasLowerCaseLetter = (viewValue && /[a-z]/.test(viewValue)) ? 'valid' : undefined;
	                scope.pwdHasUpperCaseLetter = (viewValue && /[A-Z]/.test(viewValue)) ? 'valid' : undefined;
	                scope.pwdHasNumber = (viewValue && /\d/.test(viewValue)) ? 'valid' : undefined;

	                if(scope.pwdValidLength && scope.pwdHasLowerCaseLetter && scope.pwdHasUpperCaseLetter && scope.pwdHasNumber) {
	                    ctrl.$setValidity('pwd', true);
	                    return viewValue;
	                } else {
	                    ctrl.$setValidity('pwd', false);
	                    return undefined;
	                }
	            });
	        }
	    };
	}
]);

'use strict';

//This directive is used to highlight the cehrt that is active
angular.module('igl').directive('ehrbold', [
    function () {
        return {
            restrict: 'C',
            link: function(scope, element, attrs) {
//                element.on('click', function() {
//                    element.siblings().removeClass('cehrtactive');
//                    element.siblings().children().removeClass('cehrtDeleteButtonActive');
//                    element.siblings().children().addClass('cehrtDeleteButtonNotActive');
//
//                    element.addClass('cehrtactive');
//                    element.children().removeClass('cehrtDeleteButtonNotActive');
//                    element.children().addClass('cehrtDeleteButtonActive');
//                });
            }
        };
    }
]);

'use strict';

angular.module('igl')
.directive('msg', [function () {
    return {
        restrict: 'EA',
        replace: true,
        link: function (scope, element, attrs) {
            //console.log("Dir");
            var key = attrs.key;
            if (attrs.keyExpr) {
                scope.$watch(attrs.keyExpr, function (value) {
                    key = value;
                    element.text($.i18n.prop(value));
                });
            }
            scope.$watch('language()', function (value) {
                element.text($.i18n.prop(key));
            });
        }
    };
}]);

angular.module('igl').directive('noDirtyCheck', function() {
    // Interacting with input elements having this directive won't cause the
    // form to be marked dirty.
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, elm, attrs, ctrl) {
            ctrl.$setDirty = angular.noop;
        }
    };
});
/**
 * Created by haffo on 2/13/15.
 */
angular.module('igl').directive('stRatio',function(){
    return {
        link:function(scope, element, attr){
            var ratio=+(attr.stRatio);
            element.css('width',ratio+'%');
        }
    };
});

/**
 * Created by haffo on 5/19/16.
 */


angular.module('igl').directive('validExtension', [ '$resource',
    function ($resource) {
        return {
            restrict: 'AC',
            require: 'ngModel',
            link: function (scope, element, attrs, ctrl) {

            }
        };
    }
]);

'use strict';

//Angular doesn't perform any validation on file input.
//We bridge the gap by linking the required directive to the
//presence of a value on the input.
angular.module('igl').directive('validTrustDocument', [
    function () {
        return {
            require:'ngModel',
            link:function(scope,el,attrs,ngModel){
                //change event is fired when file is selected
                el.bind('change', function() {
                    scope.$apply( function() {
                        ngModel.$setViewValue(el.val());
                        //console.log("validTrustDocument Val=", el.val());
                        //ngModel.$render();
                    });
                });
            }
        };
    }
]);

angular.module('igl').controller('ContextMenuCtl', function ($scope, $rootScope, ContextMenuSvc) {

    $scope.clicked = function (item) {
        ContextMenuSvc.put(item);
    };
});
// /**
//  * http://usejsdoc.org/
//  */
// angular.module('igl').controller('DatatypeLibraryCtl',
//     function($scope, $http, $rootScope, $q, $modal, $timeout, TableService, ngTreetableParams, DatatypeLibraryDocumentSvc, TableLibrarySvc, DatatypeService, DatatypeLibrarySvc, FormsSelectSvc, IGDocumentSvc, TableService, ViewSettings, userInfoService) {
//         $scope.filteringModeON = false;

//         $rootScope.readonly = false;
//         $rootScope.igdocument = null; // current igdocument
//         $rootScope.message = null; // current message
//         $rootScope.datatype = null; // current datatype
//         $rootScope.pages = ['list', 'edit', 'read'];
//         $rootScope.context = { page: $rootScope.pages[0] };
//         $rootScope.messagesMap = {}; // Map for Message;key:id, value:object
//         $rootScope.segmentsMap = {}; // Map for Segment;key:id, value:object
//         $rootScope.datatypesMap = {}; // Map for Datatype; key:id, value:object
//         $rootScope.tablesMap = {}; // Map for tables; key:id, value:object
//         $rootScope.segments = []; // list of segments of the selected messages
//         $rootScope.datatypes = []; // list of datatypes of the selected messages
//         $rootScope.segmentPredicates = []; // list of segment level predicates of
//         // the selected messages
//         $rootScope.segmentConformanceStatements = []; // list of segment level
//         // Conformance Statements of
//         // the selected messages
//         $rootScope.datatypePredicates = []; // list of segment level predicates of
//         // the selected messages
//         $rootScope.datatypeConformanceStatements = []; // list of segment level
//         // Conformance Statements of
//         // the selected messages
//         $rootScope.tables = []; // list of tables of the selected messages
//         $rootScope.postfixCloneTable = 'CA';
//         $rootScope.newCodeFakeId = 0;
//         $rootScope.newTableFakeId = 0;
//         $rootScope.newPredicateFakeId = 0;
//         $rootScope.newConformanceStatementFakeId = 0;
//         $rootScope.segment = null;
//         $rootScope.config = null;
//         $rootScope.messagesData = [];
//         $rootScope.messages = []; // list of messages
//         $rootScope.customIgs = [];
//         $rootScope.preloadedIgs = [];
//         $rootScope.changes = {};
//         $rootScope.generalInfo = { type: null, 'message': null };
//         $rootScope.references = []; // collection of element referencing a datatype
//         $rootScope.tmpReferences = [];
//         // to delete
//         $rootScope.section = {};
//         $rootScope.conformanceStatementIdList = [];
//         $rootScope.parentsMap = {};
//         $rootScope.igChanged = false;
//         $scope.selectedDT = null;


//         $rootScope.messageTree = null;

//         $scope.scrollbarWidth = 0;

//         $scope.datatypeLibsStruct = [];
//         $scope.editableDTInLib = '';
//         $scope.editableVS = '';
//         $scope.derivedDatatypes = [];
//         $scope.derivedTables = [];
//         $scope.toShow === "";
//         $rootScope.datatypesMap = {};
//         $scope.tablesMap = {};
//         $scope.tablesIds = [];
//         $scope.datatypeLibrary = null;
//         $scope.datatypeLibMetaDataCopy = null;
//         $scope.datatypeStruct = null;
//         $scope.datatype = null;
//         $scope.loadingSelection = true;
//         $scope.publishSelections = [];
//         $scope.datatypeDisplay = [];
//         $scope.selectedChildren = [];
//         $scope.viewSettings = ViewSettings;
//         $scope.editView = null;
//         $scope.datatypeListView = null;
//         $scope.added = [];
//         $scope.accordi = { metaData: false, definition: true, dtList: true, dtDetails: false };
//         $scope.forms = {};
//         $scope.DTLibList = true;
//         $scope.DTLibDetails = false;
//         //      $scope.forms.datatypeForm = {};
//         $scope.tableWidth = null;
//         // $scope.datatypeLibrary = "";
//         $scope.hl7Version = null;
//         $scope.scopes = [];
//         $scope.tableCollapsed = false;
//         $scope.datatypeLibrariesConfig = {};
//         //$scope.datatypeLibrariesConfig.selectedType
//         $scope.admin = true; // userInfoService.isAdmin();
//         $scope.toggle = function(param) {
//             $scope.toShow = param;

//         }
//         $scope.datatypeSource = null;
//         $scope.tableSource = null;


//         // $scope.datatypesParams = new ngTreetableParams({
//         //     getNodes: function(parent) {
//         //         return $scope.getNodes(parent, $scope.datatype);
//         //     },
//         //     getTemplate: function(node) {
//         //         return $scope.getEditTemplate(node, $scope.datatype);
//         //     }
//         // });
//         var cleanState = function() {
//             $scope.selectedChildren = [];
//             $rootScope.addedDatatypes = [];
//             $rootScope.addedTables = [];
//             if ($scope.editForm) {
//                 $scope.editForm.$setPristine();
//                 $scope.editForm.$dirty = false;
//             }
//             $rootScope.clearChanges();
//             if ($scope.datatypesParams)
//                 $scope.datatypesParams.refresh();
//         };


//         $scope.collapseTables = function() {
//             $scope.tableCollapsed = !$scope.tableCollapsed;

//         }


//         $scope.selectDTLibTab = function(value) {
//             if (value === 1) {
//                 $scope.DTLibList = false;
//                 $scope.DTLibDetails = true;
//             } else {
//                 $scope.DTLibList = true;
//                 $scope.DTLibDetails = false;
//             }
//         };
       

//         $scope.datatypeLibraryTypes = [{
//             name: "Browse Master data type libraries",
//             type: 'MASTER',
//             visible: $scope.admin,
            
//         },
//         	{name :"Browse User data type libraries",
//         	type: 'USER',
//         	visible: $scope.user
//         	}
//         ];




//         $scope.$watch(
//             function() {
//                 return $scope.editForm != undefined && $scope.editForm.$dirty;
//             },
//             function handleFormState(newValue) {
//                 if (newValue) {
//                     $rootScope.setDirty();
//                 } else {
//                     $rootScope.clearChanges();
//                 }
//             }
//         );

//         $scope.seq = function(idx) {
//             return idx + 1;
//         };

//         $scope.selectDTLibraryType = function(selectedType) {
//             $scope.datatypeLibrariesConfig.selectedType = selectedType;
//             getDataTypeLibraryByScope(selectedType);
//         };
        

//         $scope.getDatatypes = function(datatypeLibrary) {
//             $scope.datatypeListView = "DatatypeList.html";
//             $scope.loadingSelection = true;
//             $timeout(
//                 function() {
//                     $scope.loadingSelection = false;
//                 }, 100);
//         };

//         function getDataTypeLibraryByScope(scope) {
//             $scope.datatypeLibsStruct = [];
//             DatatypeLibraryDocumentSvc.getDataTypeLibraryDocumentByScope(scope).then(function(data) {
//                 $scope.datatypeLibsStruct = [];
//                 angular.forEach(data.data, function(lib) {
//                     $scope.datatypeLibsStruct.push(lib);
//                 });
//                 //$scope.datatypeLibsStruct=data.data;
//                 console.log($scope.datatypeLibsStruct);
//                 $scope.accordi.dtDetails = false;
//                 $rootScope.isEditing = false;
//                 $scope.DataTypeTree = [];
//                 $scope.datatypeLibCopy = {};
//                 //console.log("$scope.datatypeLibsStruct size=" + $scope.datatypeLibsStruct.length);
//             }).catch(function(error) {
//                 //console.log(error);
//             });
//         };

//         function getDataTypeLibraryByScopesAndVersion(scopes, hl7Version) {
//             DatatypeLibraryDocumentSvc.getDataTypeLibraryDocumentByScopesAndVersion(scopes, hl7Version).then(function(data) {
//                 $scope.datatypeStruct = data;
//                 if (!$scope.datatypeStruct.scope) {
//                     $scope.datatypeStruct.scope = scope;
//                 }
//                 //console.log("$scope.datatypeStruct.id=" + $scope.datatypeStruct.id + " $scope.datatypeStruct.scope=" + $scope.datatypeStruct.scope);
//             }).catch(function(error) {
//                 //console.log(error);
//             });
//         };

//         $scope.saveMetaData = function() {
//             $scope.datatypeLibrary.metaData = angular.copy($scope.datatypeLibMetaDataCopy);
//             DatatypeLibrarySvc.saveMetaData($scope.datatypeLibrary.id, $scope.datatypeLibMetaDataCopy);
//             $scope.forms.editForm.$setPristine();
//             cleanState();
//         };

//         $scope.resetMetaData = function() {
//             //console.log("b=" + $scope.datatypeLibMetaDataCopy.name);
//             //console.log("b=" + JSON.stringify($scope.datatypeLibrary.metaData.name));
//             $scope.datatypeLibMetaDataCopy = angular.copy($scope.datatypeLibrary.metaData);

//             $scope.DataTypeTree[0].metaData = $scope.datatypeLibMetaDataCopy;
//             //console.log("a=" + $scope.datatypeLibMetaDataCopy.name);
//             //console.log("a=" + JSON.stringify($scope.datatypeLibrary.metaData.name));
//             $scope.forms.editForm.$setPristine();
//             cleanState();
//         };

//         $scope.editMetadata = function() {
//             $scope.datatypeLibMetaDataCopy = $scope.DataTypeTree[0].metaData;
//             $scope.editView = "LibraryMetaData.html";
//         }

//         $scope.editLibrary = function(datatypeLibraryDocument) {
//             cleanState();
//             $scope.datatype = null;
//             $scope.filteringModeON = false;
//             $rootScope.initMaps();
//             $scope.selectDTLibTab(1);
//             //DTLibDetails=true;
//             $scope.datatypes = [];
//             $rootScope.datatypesMap = {};
//             $rootScope.tablesMap = {};
//             $rootScope.igdocument = null;

//             $scope.derivedTables = [];
//             console.log(datatypeLibraryDocument);
//             $scope.tablesIds = [];
//             $scope.datatypeLibrary = datatypeLibraryDocument.datatypeLibrary;
//             $scope.datatypesIds = [];
//             angular.forEach($scope.datatypeLibrary.children, function(datatypeLink) {
//                 $scope.datatypesIds.push(datatypeLink.id);
//             });

//             $scope.tableLibrary = datatypeLibraryDocument.tableLibrary;
//             angular.forEach($scope.tableLibrary.children, function(table) {
//                 $scope.tablesIds.push(table.id);
//             });

//             $scope.editView = "LibraryMetaData.html";
//             $scope.addedDatatypes = [];
//             $scope.datataypestoAdd = [];
//             $scope.hl7Version = datatypeLibraryDocument.metaData.hl7Version;
//             $rootScope.libEXT = $scope.datatypeLibrary.metaData.ext;

//             var scopes = ['HL7STANDARD'];
//             DatatypeService.getDataTypesByScopesAndVersion(scopes, $scope.hl7Version).then(function(result) {
//                 $scope.datataypestoAdd = result;
//             });

//             $scope.datatypeListView = "DatatypeList.html";
//             $scope.loadingSelection = true;
//             $rootScope.isEditing = true;
//             $scope.accordi.dtDetails = true;
//             $scope.hl7Version = $scope.datatypeLibrary.metaData.hl7Version;
//             $scope.datatypeLibraryId = $scope.datatypeLibrary.id;
//             $rootScope.currentLibVersion = $scope.hl7Version;
//             $scope.datatypeLibMetaDataCopy = angular.copy($scope.datatypeLibrary.metaData);
//             $scope.loadingSelection = false;
//             $scope.DataTypeTree = [];
//             $scope.datatypeLibCopy = angular.copy($scope.datatypeLibrary);
//             $scope.datatypeLibCopy.children = [];

//             $scope.loadDatatypes().then(function() {

//                 $scope.loadTables().then(function() {

//                 }, function() {});
//             }, function() {});



//             $scope.DataTypeTree.push($scope.datatypeLibCopy);

//         };


//         $scope.datatypesParams = new ngTreetableParams({
//             getNodes: function(parent) {
//                 return DatatypeService.getDatatypeNodesInLib(parent, $scope.datatype);
//             },
//             getTemplate: function(node) {
//                 return DatatypeService.getTemplateINLIB(node, $scope.datatype);
//             }
//         });
        
//         $scope.getDatatypesToAddByScope=function(scopes){
//             DatatypeService.getDataTypesByScopesAndVersion(scopes, $scope.hl7Version).then(function(result) {
//                 $scope.datataypestoAdd = result;
//             });
//         }
//         $scope.getLastExtensionForMaster= function(datatype,scope){
        	
//         }
        
//         $scope.startCallback = function(event, ui, title) {
//             $scope.draged = title;
//         };


//         $scope.dropCallback = function(event, ui) {
//             var index = $scope.addedDatatypes.indexOf($scope.draged);
//             if (index > -1) {
//                 $scope.addedDatatypes.splice(index, 1);
//             }
//             $scope.addedItem = angular.copy($scope.draged);
//             var randext = $scope.datatypeLibMetaDataCopy.ext + Math.floor(Math.random() * 100);
//             $scope.addedItem.id = new ObjectId().toString();
//             $scope.addedItem.ext = randext;
//             $scope.addedItem.scope = 'MASTER';
//             $scope.addedItem.status = 'UNPUBLISHED';
//             $scope.addedItem.libIds = [];
//             $scope.addedItem.libIds.push($scope.datatypeLibrary.id);
//             $scope.addedDatatypes.push($scope.addedItem);
//         };

//         $scope.selectOneToAdd = function(data) {
//             if (data.clone) {

//                 $scope.addedItem = angular.copy(data);
//                 //var randext = $scope.datatypeLibMetaDataCopy.ext + Math.floor(Math.random() * 100);
//                 //$scope.addedItem.id = new ObjectId().toString();
//                 //$scope.addedItem.ext = randext;
//                 //$scope.addedItem.scope = 'MASTER';
//                 //$scope.addedItem.status = 'UNPUBLISHED';
//                 $scope.addedItem.libIds = [];
//                 $scope.addedItem.libIds.push($scope.datatypeLibrary.id);
//                 $scope.addedDatatypes.push($scope.addedItem);
//                 data.clone = false;

//             }
//             if (data.flavor) {
//                 $scope.addedItem = angular.copy(data);
//                 var randext = $scope.datatypeLibMetaDataCopy.ext + Math.floor(Math.random() * 100);
//                 $scope.addedItem.id = new ObjectId().toString();
//                 $scope.addedItem.ext = randext;
//                 $scope.addedItem.scope = 'MASTER';
//                 $scope.addedItem.status = 'UNPUBLISHED';
//                 $scope.addedItem.libIds = [];
//                 $scope.addedItem.libIds.push($scope.datatypeLibrary.id);
//                 $scope.addedDatatypes.push($scope.addedItem);
//                 data.flavor = false;
//             }
//         };

//         $scope.AddAsFlavor = function(data) {


//             $scope.addedItem = angular.copy(data);
//             var randext = $scope.datatypeLibMetaDataCopy.ext + Math.floor(Math.random() * 100);
//             $scope.addedItem.id = new ObjectId().toString();
//             $scope.addedItem.ext = randext;
//             $scope.addedItem.scope = 'MASTER';
//             $scope.addedItem.status = 'UNPUBLISHED';
//             $scope.addedItem.libIds = [];
//             $scope.addedItem.libIds.push($scope.datatypeLibrary.id);
//             $scope.addedDatatypes.push($scope.addedItem);


//         };

//         $scope.AddAsIs = function(data) {
//             $scope.miniDTMap[data.id] = data;
//             $scope.addedItem = data;
//             $scope.addedItem.libIds = [];
//             $scope.addedItem.libIds.push($scope.datatypeLibrary.id);
//             $scope.addedDatatypes.push($scope.addedItem);

//         };


//         $scope.submitAsynch = function(datatype) {
//             var delay = $q.defer();
//             if (!$rootScope.datatypesMap[datatype.id]) {
//                 console.log("adding Datatype ")
//                 console.log(datatype);
//                 $scope.datatypes.push(datatype);
//                 $scope.getDerived(datatype);
//                 var newLink = angular.fromJson({
//                     id: datatype.id,
//                     name: datatype.name,
//                     ext: datatype.ext
//                 });
//                 DatatypeLibrarySvc.addChild($scope.datatypeLibrary.id, newLink).then(function(link) {
//                     if (datatype.status !== "PUBLISHED") {
//                         DatatypeService.save(datatype).then(function(result) {

//                             console.log("saving the child")
//                             console.log(datatype);
//                         }, function(error) {
//                             $rootScope.saving = false;
//                             $rootScope.msg().text = error.data.text;
//                             $rootScope.msg().type = error.data.type;
//                             $rootScope.msg().show = true;
//                             delay.resolve(true);
//                         });
//                     }
//                 }, function(error) {
//                     $rootScope.saving = false;
//                     $rootScope.msg().text = error.data.text;
//                     $rootScope.msg().type = error.data.type;
//                     $rootScope.msg().show = true;
//                 });
//             };
//             return delay.promise;

//         };
//         $scope.submitAdded = function() {
//             var delay = $q.defer();
//             var promises = [];
//             console.log("current Maps");
//             console.log($scope.addedDatatypes);
//             angular.forEach($scope.addedDatatypes, function(datatype) {
//             promises.push($scope.submitAsynch(datatype));
//             });
//             console.log("My datatypeLoibrary ");
//             console.log($scope.datatypeLibrary);
//             $scope.addedDatatypes = [];
//             $q.all(promises).then(function(fields) {
//                 delay.resolve(fields);
//             });
//             return delay.promise;


//         };
//         $scope.submit = function() {
//             $scope.submitAdded().then(function(result) {
//                 $scope.miniDTMap = [];
//             });

//         };


//         $scope.getDerived = function(element) {
//             try {
//                 if (element && element.type && element.type === "datatype") {

//                     angular.forEach(element.components, function(component) {
//                         $scope.getDerived(component);
//                     });
//                 } else if (element && element.type && element.type === "component") {

//                     if (element.table != null) {
//                         //add child to librar
//                         //$scope.tablesIds.push(element.table.id);
//                         //$scope.tablesIds=_.uniq($scope.tablesIds);
//                         $scope.addTable(element.table).then(function(result) {
//                             console.log("Added table succes");
//                         });

//                     }
//                     if (element.datatype !== null || element.datatype !== undefined) {
//                         var newLink = angular.fromJson({
//                             id: element.datatype.id,
//                             name: element.datatype.name,
//                             ext: element.datatype.ext
//                         });

//                         $scope.getDatatypeById(element.datatype.id).then(function(result) {

//                             DatatypeLibrarySvc.addChild($scope.datatypeLibrary.id, newLink).then(function(link) {
//                                 if (!$rootScope.datatypesMap[element.datatype.id] || $rootScope.datatypesMap[element.datatype.id] === undefined) {
//                                     $scope.datatypes.push(result);
//                                     $rootScope.datatypesMap[element.datatype.id] = result;
//                                     $scope.getDerived(result);


//                                 }

//                             }, function(error) {
//                                 $rootScope.saving = false;
//                                 $rootScope.msg().text = error.data.text;
//                                 $rootScope.msg().type = error.data.type;
//                                 $rootScope.msg().show = true;
//                             });

//                         });



//                     }

//                 }

//             } catch (e) {
//                 throw e;
//             }

//         };



//         $scope.filterByDatatype = function(datatype) {
//             $scope.filteringModeON = true;

//             $scope.tablesIds = [];
//             $scope.derivedTables = [];

//         }

//         $scope.deleteValueSetINLIB = function(table) {
//             $rootScope.references = [];
//             console.log($scope.datatypes);
//             angular.forEach($scope.datatypes, function(dt) {
//                 console.log("=======================dddddd")
//                 console.log(dt);
//                 console.log($rootScope.getDatatypeLabel(dt));
//                 $rootScope.findTableRefsINLIB(table, dt, $rootScope.getDatatypeLabel(dt));
//             });
//             console.log($rootScope.references);
//             if ($rootScope.references != null && $rootScope.references.length > 0) {
//                 abortValueSetDelete(table);
//             } else {
//                 confirmValueSetDelete(table);
//             }
//         }

//         function abortValueSetDelete(table) {
//             var modalInstance = $modal.open({
//                 templateUrl: 'ValueSetReferencesCtrl.html',
//                 controller: 'ValueSetReferencesCtrl',
//                 resolve: {
//                     tableToDelete: function() {
//                         return table;
//                     }
//                 }
//             });
//             modalInstance.result.then(function(table) {
//                 // $rootScope.tableToDelete = table;
//             }, function() {});
//         };

//         function confirmValueSetDelete(table) {
//             var modalInstance = $modal.open({
//                 templateUrl: 'ConfirmValueSetDeleteCtrl.html',
//                 controller: 'ConfirmTablesDeleteCtl',
//                 resolve: {
//                     tableToDelete: function() {
//                         return table;
//                     }
//                 }
//             });
//             modalInstance.result.then(function(table) {
//                 //                tableToDelete = table;
//                 var newLink = {};
//                 newLink.bindingIdentifier = table.bindingIdentifier;
//                 newLink.id = table.id;
//                 if ($scope.derivedTables && $scope.derivedTables != null) {
//                     console.log("dddddddddddddddddddddd");
//                     console.log(table);
//                     var index = $scope.derivedTables.indexOf(table);
//                     if (index >= 0)
//                         $scope.derivedTables.splice(index, 1);
//                 }

//                 TableLibrarySvc.deleteChild($scope.tableLibrary.id, newLink.id).then(function(link) {
//                     console.log("table deleted");

//                 }, function(error) {
//                     $rootScope.msg().text = error.data.text;
//                     $rootScope.msg().type = error.data.type;
//                     $rootScope.msg().show = true;
//                 });



//             }, function() {});
//         };


//         $scope.addDatatypetoLibrary = function(datatype) {
//             var newLink = angular.fromJson({
//                 id: datatype.id,
//                 name: datatype.name,
//                 ext: datatype.ext
//             });
//             $scope.datatypeLibrary.children.push(newLink);
//             DatatypeService.save(datatype).then(function(result) {
//                 DatatypeLibrarySvc.addChild($scope.datatypeLibrary.id, newLink).then(function(link) {}, function(error) {
//                     $rootScope.saving = false;
//                     $rootScope.msg().text = error.data.text;
//                     $rootScope.msg().type = error.data.type;
//                     $rootScope.msg().show = true;
//                 });
//             }, function(error) {
//                 $rootScope.saving = false;
//                 $rootScope.msg().text = error.data.text;
//                 $rootScope.msg().type = error.data.type;
//                 $rootScope.msg().show = true;
//             });
//         }

//         $scope.addHL7DatatypetoLibrary = function(datatype) {
//             var newLink = angular.fromJson({
//                 id: datatype.id,
//                 name: datatype.name,
//                 ext: datatype.ext
//             });
//             $scope.datatypeLibrary.children.push(newLink);

//             DatatypeLibrarySvc.addChild($scope.datatypeLibrary.id, newLink).then(function(link) {}, function(error) {
//                 $rootScope.saving = false;
//                 $rootScope.msg().text = error.data.text;
//                 $rootScope.msg().type = error.data.type;
//                 $rootScope.msg().show = true;
//             });
//         }

//         $rootScope.findTableRefsINLIB = function(table, obj, path) {
//             console.log(obj);
//             if (obj && angular.equals(obj.type, 'component')) {
//                 if (obj.table != undefined) {
//                     if (obj.table.id === table.id) {

//                         var found = angular.copy(obj);
//                         console.log(found);
//                         found.path = path;
//                         $rootScope.references.push(found);
//                     }
//                 }
//                 if (obj.datatype !== null) {
//                     console.log($rootScope.datatypesMap);
//                     console.log(" I AM HERE ")
//                     console.log(obj.datatype.id);
//                     console.log($rootScope.datatypesMap[obj.datatype.id]);
//                     $rootScope.findTableRefsINLIB(table, $rootScope.datatypesMap[obj.datatype.id], path);
//                 }
//                 //
//             } else if (obj && angular.equals(obj.type, 'datatype')) {
//                 if (obj.components != undefined && obj.components != null && obj.components.length > 0) {
//                     angular.forEach(obj.components, function(component) {
//                         $rootScope.findTableRefsINLIB(table, component, path + "." + component.position);
//                     });
//                 }
//             }
//         };

//         $scope.getReferencesInLIB = function(table, element, path) {
//             try {
//                 if (element && element.type && element.type === "datatype") {
//                     console.log()
//                     angular.forEach(element.components, function(component) {
//                         $scope.getReferencesInLIB(table, component, path);
//                     });
//                 } else if (element && element.type && element.type === "component") {
//                     if (element.table === table.id) {
//                         console.log("===================")
//                         var found = angular.copy(element);
//                         found.path = path;
//                         $scope.references.push(found);
//                     }
//                     if (element.datatype != null || element.datatype != undefined) {
//                         $scope.derivedDatatypes.push($rootScope.datatypesMap[element.datatype.id]);
//                         $scope.getDerived($rootScope.datatypesMap[element.datatype.id]);
//                         if ($rootScope.datatypesMap[element.datatype.id] === undefined) {}
//                     }
//                 }

//             } catch (e) {
//                 throw e;
//             }
//         };

//         $scope.loadDatatypes = function() {
//             var delay = $q.defer();
//             $scope.datatypeLibrary.type = "datatypes";
//             var dtIds = [];
//             for (var i = 0; i < $scope.datatypeLibrary.children.length; i++) {
//                 dtIds.push($scope.datatypeLibrary.children[i].id);
//             }
//             DatatypeService.get(dtIds).then(function(result) {
//                 console.log("==========Adding Datatypes from their IDS============");
//                 $scope.datatypes = result;
//                 console.log(result);
//                 angular.forEach(result, function(datatype) {
//                     $rootScope.datatypesMap[datatype.id] = datatype;
//                 });
//                 delay.resolve(true);

//             }, function(error) {
//                 $rootScope.msg().text = "DatatypesLoadFailed";
//                 $rootScope.msg().type = "danger";
//                 $rootScope.msg().show = true;
//                 delay.reject(false);

//             });
//             return delay.promise;
//         };

//         $scope.loadTables = function() {
//             var delay = $q.defer();
//             //$scope.tableLibrary.type = "tables";
//             var tableIds = [];
//             console.log($scope.tableLibrary);
//             for (var i = 0; i < $scope.tableLibrary.children.length; i++) {
//                 tableIds.push($scope.tableLibrary.children[i].id);
//             }
//             console.log("tablesIds====");

//             console.log(tableIds);
//             tableIds = _.uniq(tableIds);
//             console.log(tableIds);

//             TableService.findAllByIds(tableIds).then(function(tables) {
//                 $scope.derivedTables = tables;
//                 angular.forEach(tables, function(table) {
//                     $rootScope.tablesMap[table.id] = table;
//                 });
//             }, function(error) {
//                 $rootScope.msg().text = "TablesLoadFailed";
//                 $rootScope.msg().type = "danger";
//                 $rootScope.msg().show = true;
//                 delay.reject(false);
//             });




//             return delay.promise;

//         };


//         $scope.openRichTextDlg = function(obj, key, title, disabled) {
//             var modalInstance = $modal.open({
//                 templateUrl: 'RichTextCtrlLIB.html',
//                 controller: 'RichTextCtrlLIB',
//                 windowClass: 'app-modal-window',
//                 backdrop: true,
//                 keyboard: true,
//                 backdropClick: false,
//                 resolve: {
//                     editorTarget: function() {
//                         return {
//                             key: key,
//                             obj: obj,
//                             disabled: disabled,
//                             title: title
//                         };
//                     }
//                 }
//             });
//         };
//         $scope.addAllTables = function() {
//             console.log($scope.tablesIds);
//             var delay = $q.defer();
//             TableService.findAllByIds($scope.tablesIds).then(function(tables) {
//                 angular.forEach(tables, function(child) {
//                     this[child.id] = child;
//                 }, $scope.tablesMap);

//                 console.log($scope.derivedTables)
//                 $scope.derivedTables = tables;
//                 $scope.initialTables = angular.copy(tables);
//                 $scope.derivedTables.forEach(function(table, i) {
//                     var newLink = {};
//                     newLink.bindingIdentifier = table.bindingIdentifier;
//                     newLink.id = table.id;

//                     TableLibrarySvc.addChild($scope.tableLibrary.id, newLink).then(function(link) {
//                         $scope.tableLibrary.children.splice(0, 0, newLink);

//                     }, function(error) {
//                         $rootScope.msg().text = error.data.text;
//                         $rootScope.msg().type = error.data.type;
//                         $rootScope.msg().show = true;
//                     });
//                 });

//             }, function(error) {
//                 console.log(error);
//                 $rootScope.msg().text = "TablesLoadFailed";
//                 $rootScope.msg().type = "danger";
//                 $rootScope.msg().show = true;
//                 delay.reject(false);
//             });
//             return delay.promise;
//         };

//         $scope.addTables = function(igdocument) {
//             var modalInstance = $modal.open({
//                 templateUrl: 'AddTableOpenCtrlLIB.html',
//                 controller: 'AddTableOpenCtrlLIB',
//                 windowClass: 'conformance-profiles-modal',
//                 resolve: {
//                     tableLibrary: function() {
//                         return $scope.tableLibrary;
//                     },
//                     derivedTables: function() {
//                         return $scope.derivedTables;
//                     }
//                 }
//             });
//             modalInstance.result.then(function() {}, function() {});
//         };


//         $scope.addTable = function(tableLink) {
//             var delay = $q.defer();

//             var tableId = [];
//             tableId.push(tableLink.id);
//             TableService.getOne(tableLink.id).then(function(table) {
//                 console.log("table=========");
//                 console.log(table);
//                 console.log($scope.derivedTables);
//                 if ($scope.filteringModeON) {
//                     $scope.derivedTables.push(table);
//                 }
//                 if (!$rootScope.tablesMap[table.id] || $rootScope.tablesMap[table.id] === undefined) {
//                     console.log("HEEEEREEEEE=========");

//                     $scope.derivedTables.push(table);
//                     $rootScope.tablesMap[table.id] = table;
//                     console.log("PUSHED =============================");

//                     //$scope.derivedTables=_.unique($scope.derivedTables);
//                     // $scope.derivedTables.forEach(function(table, i) {
//                     var newLink = {};
//                     newLink.bindingIdentifier = table.bindingIdentifier;
//                     newLink.id = table.id;

//                     TableLibrarySvc.addChild($scope.tableLibrary.id, newLink).then(function(link) {
//                         $scope.tableLibrary.children.splice(0, 0, newLink);
//                     }, function(error) {
//                         $rootScope.msg().text = error.data.text;
//                         $rootScope.msg().type = error.data.type;
//                         $rootScope.msg().show = true;
//                     });

//                 }

//             }, function(error) {
//                 console.log(error);
//                 $rootScope.msg().text = "TablesLoadFailed";
//                 $rootScope.msg().type = "danger";
//                 $rootScope.msg().show = true;
//                 delay.reject(false);
//             });
//             return delay.promise;
//         };


//         $scope.editTableINLIB = function(table) {
//             $scope.table = table;
//             //$scope.Activate(table.id);
//             $scope.editView = "EditTablesINLIB.html";

//         }

//         $scope.createNewExtension = function(ext) {
//             if ($scope.datatypeLibrary != null) {
//                 var rand = (Math.floor(Math.random() * 10000000) + 1);
//                 if ($scope.datatypeLibrary.metaData.ext === null) {
//                     return ext != null && ext != "" ? ext + "_" + rand : rand;
//                 } else {
//                     return ext != null && ext != "" ? ext + "_" + $scope.datatypeLibrary.metaData.ext + "_" + rand + 1 : rand + 1;
//                 }
//             } else {
//                 return null;
//             }
//         };
//         $scope.copyTableINLIB = function(table) {
//             var newTable = angular.copy(table);
//             newTable.participants = [];
//             newTable.scope = 'MASTER';
//             newTable.id = null;
//             newTable.libIds = [];
//             newTable.libIds.push($scope.tableLibrary.id);
//             newTable.bindingIdentifier = $scope.createNewExtension(table.bindingIdentifier);


//             if (newTable.codes != undefined && newTable.codes != null && newTable.codes.length != 0) {
//                 for (var i = 0, len1 = newTable.codes.length; i < len1; i++) {
//                     newTable.codes[i].id = new ObjectId().toString();
//                 }
//             }

//             TableService.save(newTable).then(function(result) {
//                 newTable = result;
//                 console.log(result);
//                 $scope.tablesIds.push(result.id);
//                 var newLink = angular.copy(TableLibrarySvc.findOneChild(table.id, $scope.tableLibrary.children));
//                 newLink.bindingIdentifier = newTable.bindingIdentifier;
//                 newLink.id = newTable.id;

//                 TableLibrarySvc.addChild($scope.tableLibrary.id, newLink).then(function(link) {
//                     $scope.tableLibrary.children.splice(0, 0, newLink);
//                     $scope.derivedTables.splice(0, 0, newTable);
//                     $scope.table = newTable;
//                     $scope.tablesMap[newTable.id] = newTable;

//                     $scope.codeSystems = [];

//                     for (var i = 0; i < $scope.table.codes.length; i++) {
//                         if ($scope.codeSystems.indexOf($scope.table.codes[i].codeSystem) < 0) {
//                             if ($scope.table.codes[i].codeSystem && $scope.table.codes[i].codeSystem !== '') {
//                                 //$scope.s.push($scope.table.codes[i].codeSystem);
//                             }
//                         }
//                     }


//                 }, function(error) {
//                     $rootScope.msg().text = error.data.text;
//                     $rootScope.msg().type = error.data.type;
//                     $rootScope.msg().show = true;
//                 });


//             }, function(error) {
//                 $rootScope.msg().text = error.data.text;
//                 $rootScope.msg().type = error.data.type;
//                 $rootScope.msg().show = true;
//             });
//         };

//         $scope.redirectDTLIB = function(datatype) {
//             var modalInstance = $modal.open({
//                 templateUrl: 'ConfirmRedirect.html',
//                 controller: 'ConfirmRedirect',
//                 resolve: {
//                     datatypeTo: function() {
//                         return datatype;
//                     }
//                 }
//             });
//             modalInstance.result.then(function(datatype) {
//                 DatatypeService.getOne(datatype.id).then(function(datatype) {
//                     $scope.datatype = datatype;
//                     $scope.editDatatype($scope.datatype);

//                 });
//             });
//         };
        
//         $scope.getDatatypeById = function(id) {
//             var delay = $q.defer();
//             if ($rootScope.datatypesMap[id] === undefined || $rootScope.datatypesMap[id] === null) {
//                 $http.get('api/datatypes/' + id).then(function(response) {
//                     var datatype = angular.fromJson(response.data);
//                     //$rootScope.datatypesMap[id] = datatype;
//                     delay.resolve(datatype);
//                 }, function(error) {
//                     delay.reject(error);
//                 });
//             } else {
//                 delay.resolve($rootScope.datatypesMap[id]);
//             }
//             return delay.promise;
//         }






//         $scope.editDTLIB = function(field) {
//             console.log("looking for flavor");
//             //$scope.editableDTInLib = field.id;

//             $scope.loadLibrariesByFlavorName = function() {
//                 var delay = $q.defer();
//                 $scope.ext = null;
//                 $scope.results = [];
//                 $scope.tmpResults = [];
//                 $scope.results = $scope.results.concat(filterFlavors($scope.datatypeLibrary, field.datatype.name));
//                 $scope.tmpResults = [].concat($scope.results);
//                 DatatypeLibrarySvc.findLibrariesByFlavorName(field.datatype.name, 'HL7STANDARD', $scope.hl7Version).then(function(libraries) {
//                     if (libraries != null) {
//                         _.each(libraries, function(library) {
//                             $scope.results = $scope.results.concat(filterFlavors(library, field.datatype.name));
//                         });
//                     }

//                     $scope.results = _.uniq($scope.results, function(item, key, a) {
//                         return item.id;
//                     });
//                     $scope.tmpResults = [].concat($scope.results);

//                     delay.resolve(true);
//                 }, function(error) {
//                     $rootScope.msg().text = "Sorry could not load the data types";
//                     $rootScope.msg().type = error.data.type;
//                     $rootScope.msg().show = true;
//                     delay.reject(error);
//                 });
//                 return delay.promise;
//             };


//             var filterFlavors = function(library, name) {
//                 var results = [];
//                 _.each(library.children, function(link) {
//                     if (link.name === name) {
//                         link.libraryName = library.metaData.name;
//                         link.hl7Version = library.metaData.hl7Version;
//                         results.push(link);
//                     }
//                 });
//                 return results;
//             };




//             $scope.loadLibrariesByFlavorName().then(function(done) {
//                 console.log($scope.results);
//             });
//         };


//         $scope.backDT = function() {
//             $scope.editableDTInLib = '';
//         };


//         $scope.copyLibrary = function(datatypeLibrary) {
//             var newDatatypeLibrary = angular.copy(datatypeLibrary.datatypeLibrary);
//             newDatatypeLibrary.id = new ObjectId().toString();
//             newDatatypeLibrary.metaData.ext = newDatatypeLibrary.metaData.ext + "-" + (Math.floor(Math.random() * 10000000) + 1);
//             newDatatypeLibrary.accountId = userInfoService.getAccountID();
//             var newTableLibrary = angular.copy(datatypeLibrary.tableLibrary);
//             newTableLibrary.id = new ObjectId().toString();
//             newTableLibrary.metaData.ext = newDatatypeLibrary.metaData.ext + "-" + (Math.floor(Math.random() * 10000000) + 1);
//             newTableLibrary.accountId = userInfoService.getAccountID();

//             var newDatatypeLibraryDocument = angular.copy(datatypeLibrary);
//             newDatatypeLibraryDocument.id = null;
//             newDatatypeLibraryDocument.datatypeLibrary = newDatatypeLibrary;
//             newDatatypeLibraryDocument.tableLibrary = newTableLibrary;
//             newDatatypeLibraryDocument.metaData.ext = newDatatypeLibrary.metaData.ext + "-" + (Math.floor(Math.random() * 10000000) + 1);
//             newDatatypeLibraryDocument.accountId = userInfoService.getAccountID();
//             $scope.datatypeLibsStruct.push(newDatatypeLibrary);
//             DatatypeLibrarySvc.save(newDatatypeLibrary).then(function(response) {

//                 //newDatatypeLibraryDocument.datatypeLibrary=response;
//                 TableLibrarySvc.save(newTableLibrary).then(function(response) {
//                     //newDatatypeLibraryDocument.tableLibrary=response;
//                     DatatypeLibraryDocumentSvc.save(newDatatypeLibraryDocument).then(function(response) {



//                     });


//                 });
//             });

//         };

//         $scope.deleteLibrary = function(datatypeLibrary) {
//             $scope.confirmLibraryDelete(datatypeLibrary);
//         };

//         $scope.confirmLibraryDelete = function(datatypeLibrary) {
//             var modalInstance = $modal.open({
//                 templateUrl: 'ConfirmDatatypeLibraryDeleteCtrl.html',
//                 controller: 'ConfirmDatatypeLibraryDeleteCtrl',
//                 resolve: {
//                     datatypeLibraryToDelete: function() {
//                         return datatypeLibrary;
//                     }
//                 }
//             });
//             modalInstance.result.then(function(datatypeLibraryDocument) {
//                 DatatypeLibraryDocumentSvc.delete(datatypeLibraryDocument.id).then(function(result) {
//                     var idxP = _.findIndex($scope.datatypeLibsStruct, function(child) {
//                         return child.id === datatypeLibrary.id;
//                     });
//                     $scope.datatypeLibsStruct.splice(idxP, 1);
//                     $scope.DataTypeTree = [];
//                     $scope.datatypeLibCopy = {};
//                     $scope.datatypeLibMetaDataCopy = {};
//                     $scope.accordi.dtDetails = false;
//                     $rootScope.isEditing = false;
//                 });
//             });
//         };

//         $scope.toggleStatus = function(status) {
//             $scope.datatype.status = $scope.datatype.status === 'PUBLISHED' ? 'UNPUBLISHED' : 'PUBLISHED';
//         };

//         $scope.saveDatatype = function(datatypeCopy) {
//             //console.log("save datatypeForm=" + $scope.forms.editForm);
//             $scope.datatypeLibrary = angular.copy(datatypeCopy);
//             DatatypeService.save($scope.datatypeLibrary).then(function(result) {
//                 //$scope.selectedDT=$scope.datatype;
//                 $rootScope.msg().text = "datatypeSaved";
//                 $rootScope.msg().type = "success";
//                 $rootScope.msg().show = true;
//                 $scope.forms.editForm.$setPristine();
//                 cleanState();
//             });
//         };


//         $scope.resetDatatype = function(datatypeCopy) {
//             $scope.forms.editForm.$setPristine();
//             $scope.datatype = angular.copy($scope.datatypeLibrary);
//             $rootScope.clearChanges();
//             if ($scope.datatypesParams) {
//                 $scope.datatypesParams.refresh();
//             }
//             $scope.forms.editForm.$setPristine();
//         };

//         $scope.editDatatype = function(datatype) {
        	
//             $scope.datatype = datatype;
//             if ($scope.datatype) {
//             	console.log()
//                 $scope.datatypesParams.refresh();
//             }else {
//                 $scope.datatypesParams = new ngTreetableParams({
//                     getNodes: function(parent) {
//                         return DatatypeService.getDatatypeNodesInLib(parent, $scope.datatype);
//                     },
//                     getTemplate: function(node) {
//                         return DatatypeService.getTemplateINLIB(node, $scope.datatype);
//                     }
//                 });
//             }
//             console.log("$scope.datatype");
//             console.log($scope.datatype);

//             $scope.editView = "EditDatatypeLibraryDatatype.html";
//             $scope.loadingSelection = true;
//             $scope.added = [];




//             console.log($scope.datatype.components);
//             $scope.tableWidth = null;
//             $scope.scrollbarWidth = $scope.getScrollbarWidth();
//             $scope.csWidth = $scope.getDynamicWidth(1, 3, 890);
//             $scope.predWidth = $scope.getDynamicWidth(1, 3, 890);
//             $scope.commentWidth = $scope.getDynamicWidth(1, 3, 890);
//             console.log($scope.datatypesParams);
//             console.log($scope.datatype.components);



//             $scope.loadingSelection = false;
//             // if ($scope.datatypeStruct) {
//             //     $scope.datatypeLibrariesConfig.selectedType = 'USER';
//             // }
//         };

//         $scope.copyDatatype = function(datatypeCopy) {
//             var newDatatype = angular.copy(datatypeCopy);
//             if (newDatatype.ext !== null) {
//                 newDatatype.ext = newDatatype.ext + "-" + (Math.floor(Math.random() * 10000000) + 1);

//             } else {
//                 newDatatype.ext = (Math.floor(Math.random() * 10000000) + 1);

//             }
//             newDatatype.id = null;
//             newDatatype.status = 'UNPUBLISHED';
//             newDatatype.scope = 'MASTER';
//             DatatypeService.save(newDatatype).then(function(savedDatatype) {
//                 newDatatype = savedDatatype;
//                 $rootScope.datatypesMap[savedDatatype.id] = savedDatatype;
//                 $scope.datatypeLibrary.children.push(createLink(newDatatype));
//                 $scope.datatypes.push(newDatatype);
//                 $scope.datatypes = _.uniq($scope.datatypes);
//                 DatatypeLibrarySvc.save($scope.datatypeLibrary);

//             });
//         };

//         function createLink(datatype) {
//             return {
//                 "id": datatype.id,
//                 "name": datatype.name,
//                 "ext": datatype.ext
//             };
//         };

//         $scope.deleteDatatype = function(datatype) {
//             if (datatype.status === 'PUBLISHED') {
//                 $scope.preventDeletePublished(datatype);
//                 console.log("Published");

//             } else {
//                 $scope.confirmDelete(datatype);
//             }

//         };


//         $scope.isAvailableDTForTables = function(dt) {
//             if (dt != undefined) {
//                 if (dt.name === 'IS' || dt.name === 'ID' || dt.name === 'CWE' || dt.name === 'CNE' || dt.name === 'CE') return true;

//                 if (dt.components != undefined && dt.components.length > 0) return true;

//             }
//             return false;
//         };
//         $scope.preventDeletePublished = function(datatype) {
//             var modalInstance = $modal.open({
//                 templateUrl: 'PreventDatatypeDeleteCtl.html',
//                 controller: 'PreventDatatypeDeleteCtl',
//                 resolve: {
//                     datatypeToDelete: function() {
//                         return datatype;
//                     }
//                 }
//             });
//             modalInstance.result.then(function(datatype) {

//             });
//         };

//         $scope.confirmDelete = function(datatype) {
//             var modalInstance = $modal.open({
//                 templateUrl: 'ConfirmDatatypeDeleteCtl.html',
//                 controller: 'ConfirmDatatypeDeleteCtl',
//                 resolve: {
//                     datatypeToDelete: function() {
//                         return datatype;
//                     }
//                 }
//             });
//             modalInstance.result.then(function(datatype) {
//                 console.log(datatype);
//                 var newLink = angular.fromJson({
//                     id: datatype.id,
//                     name: datatype.name,
//                     ext: datatype.ext
//                 });
//                 //$scope.datatypeLibrary.children.push(newLink);
//                 var index = $scope.datatypes.indexOf(datatype);
//                 if (index > -1) {
//                     $scope.datatypes.splice(index, 1);
//                 }
//                 DatatypeService.delete(datatype);
//                 DatatypeLibrarySvc.deleteChild($scope.datatypeLibrary.id, newLink).then(function(link) {});
//             });
//         };

//         $scope.getTableWidth = function() {
//             if ($scope.tableWidth === null || $scope.tableWidth == 0) {
//                 $scope.tableWidth = $("#nodeDetailsPanel").width();
//             }
//             return $scope.tableWidth;
//         };

//         $scope.getDynamicWidth = function(a, b, otherColumsWidth) {
//             var tableWidth = $scope.getTableWidth();
//             if (tableWidth > 0) {
//                 var left = tableWidth - otherColumsWidth;
//                 return { "width": a * parseInt(left / b) + "px" };
//             }
//             return "";
//         };

//         $scope.isVisible = function(node) {
//             var isVis = DatatypeService.isVisible(node);
//             return isVis;
//         };

//         $scope.hasChildren = function(node) {
//             //console.log("hasChildren getDatatype=" + $scope.getDatatype(node.datatype.id));
//             console.log("node");
//             console.log(node);
//             return node && node != null && node.datatype && $scope.getDatatype(node.datatype.id) != undefined && $scope.getDatatype(node.datatype.id).components != null && $scope.getDatatype(node.datatype.id).components.length > 0;
//         };

//         $scope.isChildSelected = function(component) {
//             return $scope.selectedChildren.indexOf(component) >= 0;
//         };

//         $scope.isChildNew = function(component) {
//             return component && component != null && component.status === 'DRAFT';
//         };

//         $scope.recordDatatypeChange = function(type, command, id, valueType, value) {
//             var datatypeFromChanges = $rootScope.findObjectInChanges("datatype", "add", $Scope.datatype.id);
//             if (datatypeFromChanges === undefined) {
//                 $rootScope.recordChangeForEdit2(type, command, id, valueType, value);
//             }
//         };

//         $scope.countPredicate = function(position) {
//             if (selectedDatatype != null)
//                 for (var i = 0, len1 = selectedDatatype.predicates.length; i < len1; i++) {
//                     if (selectedDatatype.predicates[i].constraintTarget.indexOf(position + '[') === 0)
//                         return 1;
//                 }

//             return 0;
//         };

//         $scope.showSelectDatatypeFlavorDlg = function(component) {
//             var modalInstance = $modal.open({
//                 templateUrl: 'SelectDatatypeFlavor.html',
//                 controller: 'SelectDatatypeFlavorCtrl',
//                 windowClass: 'app-modal-window',
//                 resolve: {
//                     currentDatatype: function() {
//                         return selectedDatatypesMap[component.datatype.id];
//                     },
//                     hl7Version: function() {
//                         return $rootScope.igdocument.metaData.hl7Version;
//                     },
//                     datatypeLibrary: function() {
//                         return $rootScope.igdocument.profile.datatypeLibrary;
//                     }
//                 }
//             });
//             modalInstance.result.then(function(datatype, ext) {
//                 component.datatype.id = datatype.id;
//                 MastermapSvc.addDatatypeObject(datatype, [component.id, component.type]);
//                 if ($scope.datatypesParams)
//                     $scope.datatypesParams.refresh();
//             });

//         };


//         $scope.getDatatype = function(id) {
//             return $rootScope.datatypesMap && $rootScope.datatypesMap[id];
//         };

//         $scope.getNodes = function(parent, root) {
//             console.log(root);
//             var children = [];
//             if (parent && parent != null) {
//                 if (parent.datatype) {
//                     var dt = $rootScope.datatypesMap[parent.datatype.id];
//                     children = dt.components;
//                 } else {
//                     children = parent.components;
//                 }
//             } else {
//                 if (root != null) {
//                     children = root.components;
//                 } else {
//                     children = [];
//                 }
//             }
//             console.log(children);

//             return children;
//         };

//         $scope.getEditTemplate = function(node, root) {
//             return node.type === 'datatype' ? 'DatatypeLibraryEditTree.html' : node.type === 'component' && !DatatypeService.isDatatypeSubDT(node, root) ? 'DatatypeLibraryComponentEditTree.html' : node.type === 'component' && DatatypeService.isDatatypeSubDT(node, root) ? 'DatatypeLibrarySubComponentEditTree.html' : '';
//         };

//         $scope.isVisible = function(node) {
//             return DatatypeService.isVisible(node);
//         };

//         $scope.sort = {
//             label: function(dt) {
//                 return $rootScope.getLabel(dt.name, $scope.datatypeLibrary.metaData.ext)
//             }
//         };

//         $scope.openStandardDataypes = function(scope) {
//             var standardDatatypesInstance = $modal.open({
//                 templateUrl: 'standardDatatypeDlg.html',
//                 controller: 'StandardDatatypeLibraryInstanceDlgCtl',
//                 windowClass: 'app-modal-window',
//                 resolve: {
//                     hl7Versions: function() {
//                         return DatatypeLibrarySvc.getHL7Versions();
//                     }
//                 }
//             }).result.then(function(standard) {
//                 //console.log("hl7Version=" + standard.hl7Version + " name=" + standard.name + " ext=" + standard.ext);
//                 $scope.hl7Version = standard.hl7Version;
//                 DatatypeLibraryDocumentSvc.create(standard.hl7Version, scope, standard.name, standard.ext).then(function(result) {
//                     console.log(result.data);
//                     //getDataTypeLibraryByScope(scope);
//                     // DatatypeLibraryDocumentSvc.getDataTypeLibraryDocumentByScopesAndVersion([scope],standard.hl7Version).then(function(DTLib){
//                     //     console.log(DTLib);
//                     // });
//                     angular.forEach($scope.datatypeLibrariesConfig, function(lib) {
//                         if (lib.type === scope) {
//                             $scope.datatypeLibrariesConfig.selectedType = lib;
//                         }
//                     });
//                     $scope.editLibrary(result.data);
//                     //$scope.selectDTLibraryType('MASTER');
//                     $scope.addDatatypesFromTree();
//                 });
//                 //console.log("$scope.datatypeLibsStruct=" + $scope.datatypeLibsStruct.length);
//             });
//         };


//         $scope.addingToc = [];
//         $scope.addDatatypesFromTree = function() {
//             //$scope.openDataypeList();
//             $scope.miniDTMap = [];
//             $scope.datatypeLibList = [];
//             $scope.datatype = null;

//             $scope.editView = 'addingView.html';
//             DatatypeLibrarySvc.getDataTypeLibraryByScopesAndVersion(["MASTER", "HL7STANDARD"], $scope.hl7Version).then(function(result) {
//                 $scope.datatypeLibList = result;
//             });


//         }
//         $scope.setLibrary = function(library) {
//             DatatypeLibrarySvc.getDatatypesByLibrary(JSON.parse(library).id).then(function(result) {
//                 var dts = [];
//                 for (var i = 0; i < result.length; i++) {
//                     if (result[i].status === "PUBLISHED") {
//                         dts.push(result[i]);
//                     }
//                 }
//                 $scope.datataypestoAdd = dts;
//             });
//         };
//         $scope.openDataypeList = function(hl7Version) {

//             var scopes = ['HL7STANDARD'];
//             if ($scope.datatypeLibrariesConfig.selectedType === 'MASTER') {
//                 scopes.push('MASTER');
//             } else {
//                 scopes.push('USER');
//             }
//             //console.log("openDataypeList scopes=" + scopes.length);
//             var datatypesListInstance = $modal.open({
//                 templateUrl: 'datatypeListDlg.html',
//                 controller: 'DatatypeListInstanceDlgCtl',
//                 windowClass: 'app-modal-window',
//                 resolve: {
//                     hl7Version: function() {
//                         return $scope.hl7Version;
//                     },
//                     datatypeLibsStruct: function() {
//                         return DatatypeLibrarySvc.getDataTypeLibraryByScopesAndVersion(scopes, $scope.hl7Version);
//                     }
//                 }
//             }).result.then(function(results) {
//                 var ids = [];
//                 angular.forEach(results, function(result) {
//                     ids.push(result.id);
//                 });

//                 DatatypeLibrarySvc.bindDatatypes(ids, $scope.datatypeLibrary.id, $scope.datatypeLibrary.metaData.ext).then(function(datatypeLinks) {
//                     var ids = [];
//                     angular.forEach(datatypeLinks, function(datatypeLink) {
//                         $scope.datatypeLibrary.children.push(datatypeLink);
//                         ids.push(datatypeLink.id);
//                     });
//                     DatatypeService.get(ids).then(function(datatypes) {
//                         angular.forEach(datatypes, function(datatype) {
//                             datatype.status = "UNPUBLISHED";
//                             $scope.datatypeLibCopy.children.push(datatype);
//                             DatatypeService.collectDatatypes(datatype.id).then(function(datatypes) {
//                                 angular.forEach(datatypes, function(dt) {
//                                     if (!_.includes(dt.libIds, $scope.datatypeLibrary.id)) {
//                                         dt.libIds.push($scope.datatypeLibrary.id);
//                                     }
//                                     if ($rootScope.datatypesMap[dt.id] === null || $rootScope.datatypesMap[dt.id] === undefined) {
//                                         $rootScope.datatypesMap[dt.id] = dt;
//                                         $scope.added.push(dt.id);
//                                     };
//                                     var exists2 = _.find($scope.DataTypeTree[0].children, 'id', dt.id);
//                                     if (exists2 === undefined) {
//                                         $scope.DataTypeTree[0].children.push(dt);
//                                     }
//                                 });
//                                 //            //console.log("$scope.DataTypeTree=" + JSON.stringify($scope.DataTypeTree, null, 2));
//                                 DatatypeService.saveAll(datatypes);
//                             });
//                         });

//                     });
//                 });
//             });
//         };
//         $scope.confirmPublish = function(datatypeCopy) {
//             var modalInstance = $modal.open({
//                 templateUrl: 'ConfirmDatatypePublishCtl.html',
//                 controller: 'ConfirmDatatypePublishCtl',
//                 resolve: {
//                     datatypeToPublish: function() {
//                         return datatypeCopy;
//                     }
//                 }
//             });
//             modalInstance.result.then(function(datatypeCopy) {
//                 DatatypeService.save(datatypeCopy);
//             });
//         };
//     });
// angular.module('igl').controller('StandardDatatypeLibraryInstanceDlgCtl',
//     function($scope, $rootScope, $modalInstance, $timeout, hl7Versions, DatatypeLibrarySvc, DatatypeService) {

//         $scope.okDisabled = true;

//         $scope.scope = "HL7STANDARD";
//         $scope.hl7Versions = hl7Versions;
//         $scope.standard = {};
//         $scope.standard.hl7Version = null;
//         $scope.name = null;
//         $scope.standard.ext = null;

//         $scope.getDisplayLabel = function(dt) {
//             if (dt) {
//                 return dt.label;
//             }
//         }

//         $scope.ok = function() {
//             $modalInstance.close($scope.standard);
//         };

//         $scope.cancel = function() {
//             $modalInstance.dismiss('cancel');
//         };

//     });

// angular.module('igl').controller('DatatypeListInstanceDlgCtl',
//     function($scope, $rootScope, $modalInstance, hl7Version, datatypeLibsStruct, DatatypeLibrarySvc, DatatypeService) {

//         $scope.hl7Version = hl7Version;
//         $scope.datatypesLibStruct = datatypeLibsStruct;
//         $scope.selectedLib;
//         $scope.dtSelections = [];

//         $scope.trackSelections = function(bool, event) {
//             if (bool) {
//                 $scope.dtSelections.push(event);
//             } else {
//                 for (var i = 0; i < $scope.dtSelections.length; i++) {
//                     if ($scope.dtSelections[i].id === event.id) {
//                         $scope.dtSelections.splice(i, 1);
//                     }
//                 }
//             }
//             $scope.okDisabled = $scope.dtSelections.length === 0;
//         };

//         $scope.libSelected = function(datatypeLib) {
//             $scope.selectedLib = datatypeLib;
//         };

//         $scope.ok = function() {
//             $modalInstance.close($scope.dtSelections);
//         };

//         $scope.cancel = function() {
//             $modalInstance.dismiss('cancel');
//         };
//     });

// angular.module('igl').controller('ConfirmDatatypeLibraryDeleteCtrl', function($scope, $rootScope, $http, $modalInstance, datatypeLibraryToDelete) {

//     $scope.datatypeLibraryToDelete = datatypeLibraryToDelete;
//     $scope.loading = false;

//     $scope.delete = function() {
//         $modalInstance.close($scope.datatypeLibraryToDelete);
//     };

//     $scope.cancel = function() {
//         $modalInstance.dismiss('cancel');
//     };
// });

// angular.module('igl').controller('ConfirmDatatypeDeleteCtl', function($scope, $rootScope, $http, $modalInstance, datatypeToDelete) {

//     $scope.datatypeToDelete = datatypeToDelete;
//     $scope.loading = false;

//     $scope.delete = function() {
//         $modalInstance.close($scope.datatypeToDelete);
//     };

//     $scope.cancel = function() {
//         $modalInstance.dismiss('cancel');
//     };
// });


// angular.module('igl').controller('ConfirmTablesDeleteCtl', function($scope, $rootScope, $http, $modalInstance, tableToDelete) {

//     $scope.tableToDelete = tableToDelete;
//     $scope.loading = false;

//     $scope.delete = function() {
//         $modalInstance.close($scope.tableToDelete);
//     };

//     $scope.cancel = function() {
//         $modalInstance.dismiss('cancel');
//     };
// });


// angular.module('igl').controller('PreventDatatypeDeleteCtl', function($scope, $rootScope, $http, $modalInstance, datatypeToDelete) {

//     $scope.datatypeToDelete = datatypeToDelete;
//     $scope.loading = false;

//     $scope.delete = function() {
//         $modalInstance.close($scope.datatypeToDelete);
//     };

//     $scope.cancel = function() {
//         $modalInstance.dismiss('cancel');
//     };
// });

// angular.module('igl').controller('ConfirmDatatypePublishCtl', function($scope, $rootScope, $http, $modalInstance, datatypeToPublish) {

//     $scope.datatypeToPublish = datatypeToPublish;
//     $scope.loading = false;

//     $scope.delete = function() {
//         $modalInstance.close($scope.datatypeToPublish);
//     };

//     $scope.cancel = function() {
//         $scope.datatypeToPublish.status = "'UNPUBLISHED'";
//         $modalInstance.dismiss('cancel');
//     };
// });



// angular.module('igl').controller('ConfirmRedirect', function($scope, $rootScope, $http, $modalInstance, datatypeTo) {

//     $scope.datatypeTo = datatypeTo;
//     $scope.loading = false;

//     $scope.delete = function() {
//         $modalInstance.close($scope.datatypeTo);
//     };

//     $scope.cancel = function() {
//         //$scope.datatypeToPublish.status = "'UNPUBLISHED'";
//         $modalInstance.dismiss('cancel');
//     };
// });



// angular.module('igl').controller('PredicateDatatypeLibraryCtrl', function($scope, $modalInstance, selectedNode, selectedDatatype, $rootScope) {
//     $scope.constraintType = 'Plain';
//     $scope.selectedNode = selectedNode;

//     $scope.firstConstraint = null;
//     $scope.secondConstraint = null;
//     $scope.compositeType = null;
//     $scope.complexConstraint = null;
//     $scope.complexConstraintTrueUsage = null;
//     $scope.complexConstraintFalseUsage = null;

//     $scope.changed = false;
//     $scope.tempPredicates = [];
//     angular.copy(selectedDatatype.predicates, $scope.tempPredicates);


//     $scope.setChanged = function() {
//         $scope.changed = true;
//     }

//     $scope.initPredicate = function() {
//         $scope.newConstraint = angular.fromJson({
//             position_1: null,
//             position_2: null,
//             location_1: null,
//             location_2: null,
//             datatype: '',
//             component_1: null,
//             subComponent_1: null,
//             component_2: null,
//             subComponent_2: null,
//             verb: null,
//             contraintType: null,
//             value: null,
//             value2: null,
//             trueUsage: null,
//             falseUsage: null,
//             valueSetId: null,
//             bindingStrength: 'R',
//             bindingLocation: '1'
//         });
//         $scope.newConstraint.datatype = selectedDatatype.name;
//     }

//     $scope.initComplexPredicate = function() {
//         $scope.firstConstraint = null;
//         $scope.secondConstraint = null;
//         $scope.compositeType = null;
//         $scope.complexConstraintTrueUsage = null;
//         $scope.complexConstraintFalseUsage = null;
//     }

//     $scope.initPredicate();


//     $scope.deletePredicate = function(predicate) {
//         $scope.tempPredicates.splice($scope.tempPredicates.indexOf(predicate), 1);
//         $scope.changed = true;
//     };

//     $scope.updateComponent_1 = function() {
//         $scope.newConstraint.subComponent_1 = null;
//     };

//     $scope.updateComponent_2 = function() {
//         $scope.newConstraint.subComponent_2 = null;
//     };


//     $scope.genLocation = function(datatype, component, subComponent) {
//         var location = null;
//         if (component != null && subComponent == null) {
//             location = datatype + '.' + component.position + "(" + component.name + ")";
//         } else if (component != null && subComponent != null) {
//             location = datatype + '.' + component.position + '.' + subComponent.position + "(" + subComponent.name + ")";
//         }

//         return location;
//     };

//     $scope.genPosition = function(component, subComponent) {
//         var position = null;
//         if (component != null && subComponent == null) {
//             position = component.position + '[1]';
//         } else if (component != null && subComponent != null) {
//             position = component.position + '[1]' + '.' + subComponent.position + '[1]';
//         }

//         return position;
//     };


//     $scope.deletePredicateByTarget = function() {
//         for (var i = 0, len1 = $scope.tempPredicates.length; i < len1; i++) {
//             if ($scope.tempPredicates[i].constraintTarget.indexOf($scope.selectedNode.position + '[') === 0) {
//                 $scope.deletePredicate($scope.tempPredicates[i]);
//                 return true;
//             }
//         }
//         return false;
//     };

//     $scope.addComplexPredicate = function() {
//         $scope.complexConstraint = $rootScope.generateCompositePredicate($scope.compositeType, $scope.firstConstraint, $scope.secondConstraint);
//         $scope.complexConstraint.trueUsage = $scope.complexConstraintTrueUsage;
//         $scope.complexConstraint.falseUsage = $scope.complexConstraintFalseUsage;

//         if ($scope.selectedNode === null) {
//             $scope.complexConstraint.constraintId = '.';
//         } else {
//             $scope.complexConstraint.constraintId = $scope.newConstraint.datatype + '-' + $scope.selectedNode.position;
//         }

//         $scope.tempPredicates.push($scope.complexConstraint);
//         $scope.initComplexPredicate();
//         $scope.changed = true;
//     };

//     $scope.addPredicate = function() {

//         $rootScope.newPredicateFakeId = $rootScope.newPredicateFakeId - 1;

//         $scope.newConstraint.position_1 = $scope.genPosition($scope.newConstraint.component_1, $scope.newConstraint.subComponent_1);
//         $scope.newConstraint.position_2 = $scope.genPosition($scope.newConstraint.component_2, $scope.newConstraint.subComponent_2);
//         $scope.newConstraint.location_1 = $scope.genLocation($scope.newConstraint.datatype, $scope.newConstraint.component_1, $scope.newConstraint.subComponent_1);
//         $scope.newConstraint.location_2 = $scope.genLocation($scope.newConstraint.datatype, $scope.newConstraint.component_2, $scope.newConstraint.subComponent_2);

//         if ($scope.newConstraint.position_1 != null) {
//             var cp = null;
//             if ($scope.selectedNode === null) {
//                 var cp = $rootScope.generatePredicate(".", $scope.newConstraint);
//             } else {
//                 var cp = $rootScope.generatePredicate($scope.selectedNode.position + '[1]', $scope.newConstraint);
//             }

//             $scope.tempPredicates.push(cp);
//             $scope.changed = true;
//         }
//         $scope.initPredicate();
//     };

//     $scope.ok = function() {
//         $modalInstance.close($scope.selectedNode);
//     };

//     $scope.saveclose = function() {
//         angular.copy($scope.tempPredicates, selectedDatatype.predicates);
//         $rootScope.recordChanged();
//         $modalInstance.close($scope.selectedNode);
//     };
// });
// angular.module('igl').controller('AddTableOpenCtrlLIB', function($scope, $modalInstance, tableLibrary, derivedTables, $rootScope, $http, $cookies, TableLibrarySvc, TableService) {
//     $scope.loading = false;
//     //$scope.igdocumentToSelect = igdocumentToSelect;
//     $scope.source = '';
//     $scope.selectedHL7Version = '';
//     $scope.searchText = '';
//     $scope.hl7Versions = [];
//     $scope.hl7Tables = null;
//     $scope.phinvadsTables = null;
//     $scope.selectedTables = [];

//     $scope.cancel = function() {
//         $modalInstance.dismiss('cancel');
//     };

//     $scope.listHL7Versions = function() {
//         return $http.get('api/igdocuments/findVersions', {
//             timeout: 60000
//         }).then(function(response) {
//             var hl7Versions = [];
//             var length = response.data.length;
//             for (var i = 0; i < length; i++) {
//                 hl7Versions.push(response.data[i]);
//             }
//             $scope.hl7Versions = hl7Versions;
//         });
//     };

//     $scope.loadTablesByVersion = function(hl7Version) {
//         $scope.loading = true;
//         $scope.selectedHL7Version = hl7Version;
//         return $http.get('api/igdocuments/' + hl7Version + "/tables", {
//             timeout: 60000
//         }).then(function(response) {
//             $scope.hl7Tables = response.data;
//             $scope.loading = false;
//         });
//     };

//     $scope.searchPhinvads = function(searchText) {
//         $scope.loading = true;
//         $scope.searchText = searchText;
//         return $http.get('api/igdocuments/' + searchText + "/PHINVADS/tables", {
//             timeout: 600000
//         }).then(function(response) {
//             $scope.phinvadsTables = response.data;
//             $scope.loading = false;
//         });
//     }
//     $scope.createNewExtension = function(ext) {
//         if (tableLibrary != null) {
//             var rand = (Math.floor(Math.random() * 10000000) + 1);
//             if (tableLibrary.metaData.ext === null) {
//                 return ext != null && ext != "" ? ext + "_" + rand : rand;
//             } else {
//                 return ext != null && ext != "" ? ext + "_" + tableLibrary.metaData.ext + "_" + rand + 1 : rand + 1;
//             }
//         } else {
//             return null;
//         }
//     };

//     $scope.addTable = function(table) {
//         var newTable = angular.copy(table);
//         newTable.participants = [];
//         newTable.bindingIdentifier = $scope.createNewExtension(table.bindingIdentifier);
//         newTable.scope = 'MASTER';

//         if (newTable.codes != undefined && newTable.codes != null && newTable.codes.length != 0) {
//             for (var i = 0, len1 = newTable.codes.length; i < len1; i++) {
//                 newTable.codes[i].id = new ObjectId().toString();
//             }
//         }
//         console.log(JSON.stringify(newTable));
//         $scope.selectedTables.push(newTable);
//     };

//     $scope.deleteTable = function(table) {
//         var index = $scope.selectedTables.indexOf(table);
//         if (index > -1) $scope.selectedTables.splice(index, 1);
//     };

//     $scope.save = function() {
//         for (var i = 0; i < $scope.selectedTables.length; i++) {
//             var newTable = $scope.selectedTables[i];
//             console.log(JSON.stringify(newTable));
//             newTable.libIds.push(tableLibrary.id);

//             TableService.save(newTable).then(function(result) {
//                 newTable = result;
//                 derivedTables.push(newTable);
//                 $rootScope.tablesMap[newTable.id] = newTable;
//                 var newLink = angular.fromJson({
//                     id: newTable.id,
//                     bindingIdentifier: newTable.bindingIdentifier
//                 });

//                 TableLibrarySvc.addChild(tableLibrary.id, newLink).then(function(link) {
//                     tableLibrary.children.splice(0, 0, newLink);
//                     //$rootScope.tables.splice(0, 0, newTable);

//                     //                    MastermapSvc.addValueSetObject(newTable, []);

//                     if ($scope.editForm) {
//                         $scope.editForm.$setPristine();
//                         $scope.editForm.$dirty = false;
//                     }
//                     $rootScope.clearChanges();
//                     $rootScope.msg().text = "tableSaved";
//                     $rootScope.msg().type = "success";
//                     $rootScope.msg().show = true;

//                 }, function(error) {
//                     $scope.saving = false;
//                     $rootScope.msg().text = error.data.text;
//                     $rootScope.msg().type = error.data.type;
//                     $rootScope.msg().show = true;
//                 });


//             }, function(error) {
//                 $scope.saving = false;
//                 $rootScope.msg().text = error.data.text;
//                 $rootScope.msg().type = error.data.type;
//                 $rootScope.msg().show = true;
//             });
//         }

//         $modalInstance.dismiss('cancel');
//     };

//     function positionElements(chidren) {
//         var sorted = _.sortBy(chidren, "sectionPosition");
//         var start = sorted[0].sectionPosition;
//         _.each(sorted, function(sortee) {
//             sortee.sectionPosition = start++;
//         });
//         return sorted;
//     }
// });

// angular.module('igl').controller('RichTextCtrlLIB', ['$scope', '$modalInstance', 'editorTarget', function($scope, $modalInstance, editorTarget) {
//     $scope.editorTarget = editorTarget;

//     $scope.cancel = function() {
//         $modalInstance.dismiss('cancel');
//     };

//     $scope.close = function() {
//         $modalInstance.close($scope.editorTarget);
//     };
// }]);

angular.module('igl')
    .controller('EditAreaCtrl', function ($scope, $rootScope, CloneDeleteSvc,SectionSvc,ElementUtils) {

        $scope.init = function() {
            if ($scope.editForm) {
                $rootScope.clearChanges();
                $scope.editForm.$setPristine();
                $scope.editForm.$dirty = false;
                console.log("=====> set $dirty to false")
            }
        };
        
        $rootScope.$on("event:initEditArea", function (event) {

            $scope.init();
        });

        $scope.$watch(
            function() {
                return $scope.editForm != undefined && $scope.editForm.$dirty;
            },
            function handleFormState(newValue) {
                if (newValue) {
                    $rootScope.recordChanged();
                } else {
                    $rootScope.clearChanges();
                }
            }
        );

        $scope.setDirty = function() {
            $scope.editForm.$dirty = true;
        };

        $scope.setUsage = function(node) {
            ElementUtils.setUsage(node);
            $scope.setDirty();
        };
        $scope.clearDirty = function() {
            if ($scope.editForm) {
                $scope.editForm.$setPristine();
                $scope.editForm.$dirty = false;
            }
        }



        $scope.openRichTextDlg = function (obj, key, title, disabled) {
            var original = obj[key];
            var modalInstance = $rootScope.openRichTextDlg(obj, key, title, disabled);
            modalInstance.result.then(function () {
                if(!disabled && original !== obj[key]){
                    $scope.setDirty();
                }
            }, function () {
                if(!disabled && original !== obj[key]){
                    $scope.setDirty();
                }
            });
        };

        $scope.openInputTextDlg = function (obj, key, title, disabled) {
            var original = obj[key];
            var modalInstance = $rootScope.openInputTextDlg(obj, key, title, disabled);
            modalInstance.result.then(function () {
                if(!disabled && original !== obj[key]){
                    $scope.setDirty();
                }
            }, function () {
                if(!disabled && original !== obj[key]){
                    $scope.setDirty();
                }
            });
        };

        $scope.clearComments = function (obj, key) {
            obj[key] = '';
            $scope.setDirty();
        };







    });

angular.module('igl')
    .controller('SectionsListCtrl', function ($scope, $rootScope, CloneDeleteSvc, ToCSvc,SectionSvc) {
        $scope.saving = false;
        $scope.saved = false;

        $scope.fixedSectionTitles = [
            'Message Infrastructure','Metadata','Introduction','Conformance Profiles','Segments and Field Descriptions','Datatypes','Value Sets'
        ];
//
//	    	$scope.copy = function(section) {
//	    		var tocSection = ToCSvc.findEntryFromRefId(section.id, $rootScope.tocData);
//        		CloneDeleteSvc.copySection(tocSection);
//	    	};
//

        $scope.close = function () {
            $rootScope.section = null;
            $scope.refreshTree();
            $scope.loadingSelection = false;
        };
        
//        $scope.delete = function(section) {
//    		var tocSection = ToCSvc.findEntryFromRefId(section.id, $rootScope.tocData);
//            SectionSvc.delete($rootScope.igdocument.id,tocSection.id).then(function (result) {
//                $scope.saving = false;
//                $scope.saved = true;
//                CloneDeleteSvc.deleteSection(tocSection);
//                $rootScope.$broadcast('event:SetToC');
//            }, function (error) {
//                $rootScope.msg().text = error.data.text;
//                $rootScope.msg().type = error.data.type;
//                $rootScope.msg().show = true;
//                $scope.saved = false;
//                $scope.saving = false;
//            });
//        };

        $scope.isFixedSectionTitle = function(section){
            return $scope.fixedSectionTitles.indexOf(section.sectionTitle) >= 0;
        };

        $scope.save = function () {
            if($rootScope.igdocument != null && $rootScope.section != null) {
                SectionSvc.update($rootScope.igdocument.id, $rootScope.section).then(function (dateUpdated) {
                    $scope.saving = false;
                    $scope.saved = true;
                    $rootScope.section.dateUpdated = dateUpdated;
                    $rootScope.igdocument.dateUpdated = dateUpdated;
                    SectionSvc.merge($rootScope.originalSection,$rootScope.section);
                    if($scope.editForm) {
                        $scope.editForm.$setPristine();
                        $scope.editForm.$dirty = false;
                    }
                    $rootScope.clearChanges();
                    $rootScope.msg().text = "sectionSaved";
                    $rootScope.msg().type = "success";
                    $rootScope.msg().show = true;
                 }, function (error) {
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                    $scope.saved = false;
                    $scope.saving = false;
                });
            }
        };

        $scope.reset = function () {
            $scope.editForm.$setPristine();
            $scope.editForm.$dirty = false;
            $rootScope.clearChanges();
            $rootScope.section = angular.copy($rootScope.originalSection);
        };


//        $scope.$watch(
//            function(){
//              return $scope.editForm.$dirty;
//            },
//            function handleFormState( newValue) {
//                if(newValue){
//                    $rootScope.recordChanged();
//                }else{
//                    $rootScope.clearChanges();
//                }
//            }
//        );



});
/**
 * Created by haffo on 3/3/16.
 */
angular.module('igl').controller('ErrorDetailsCtrl', function ($scope, $modalInstance, error) {
    $scope.error = error;
    $scope.ok = function () {
        $modalInstance.close($scope.error);
    };

    $scope.cancel = function () {
        $modalInstance.dismiss('cancel');
    };
});

app.controller('ErrorCtrl', [ '$scope', '$modalInstance', 'StorageService', '$window',
    function ($scope, $modalInstance, StorageService, $window) {
        $scope.refresh = function () {
            $modalInstance.close($window.location.reload());
        };
    }
]);

app.controller('FailureCtrl', [ '$scope', '$modalInstance', 'StorageService', '$window', 'error',
    function ($scope, $modalInstance, StorageService, $window, error) {
        $scope.error = error;
        $scope.close = function () {
            $modalInstance.close();
        };
    }
]);
angular
  .module('igl')
  .controller(
      'FilteringCtl',
          function ($scope, $rootScope) {
            var ctl = this;

           // $scope.filtermsgmodel = $rootScope.igdocument.profile.messages.children;
          
          $scope.selectAll= function(){

            $rootScope.selectedMessages=$rootScope.igdocument.profile.messages.children;
            $rootScope.selectedSegments=$rootScope.segments;
            $rootScope.selectedDataTypes=$rootScope.datatypes;
            $rootScope.selectedTables=$rootScope.tables;

          } 
          $scope.addToSelection  =function(item) {
                if($rootScope.selectedMessages.length===$rootScope.igdocument.profile.messages.children.length){
                      $rootScope.selectedMessages=[];
                      $rootScope.selectedSegments=[];
                      $rootScope.selectedDataTypes=[];
                      $rootScope.selectedTables=[]
                        }

                for(var j=0; j< $rootScope.igdocument.profile.messages.children.length; j++){
                  
                    if(item.id===$rootScope.igdocument.profile.messages.children[j].id){
                      $rootScope.selectedMessages.push($rootScope.igdocument.profile.messages.children[j]);
                      for(var i=0; i<$rootScope.igdocument.profile.messages.children[j].children.length; i++){
                      console.log($rootScope.igdocument.profile.messages.children[j].children[i]);
                      var child=$rootScope.igdocument.profile.messages.children[j].children[i];
                      if( child.type==="segmentRef"){
                        var seg = $rootScope.segmentsMap[child.ref.id];
                        console.log(seg);
                        var temp=[];
                        temp.push(seg);
                        $rootScope.selectedSegments=_.union($rootScope.selectedSegments,temp);
                        $rootScope.selectedDataTypes=_.union($rootScope.selectedDataTypes, $scope.getDatataypeFromSegment(seg));
                        $scope.getTablesFromSegment(seg);


                        console.log($rootScope.selectedSegments);
                        }else if(child.type==="group"){
                            console.log($rootScope.selectedSegments)
                            $scope.getSegmentsFromgroup(child);
                            console.log($rootScope.selectedSegments)
                        }
                      }
                   }
              }
            }




            $scope.getSegmentsFromgroup= function(group){

              //_.union($rootScope.selectedSegments,temp);
              for( var i=0; i<group.children.length; i++){
                if(group.children[i].type === "segmentRef"){
                        console.log("IN IF ");
                        var segment = $rootScope.segmentsMap[group.children[i].ref.id];
                        var temp2=[];
                        temp2.push(segment);
                        $rootScope.selectedSegments=_.union($rootScope.selectedSegments,temp2);
                        $rootScope.selectedDataTypes=_.union($rootScope.selectedDataTypes, $scope.getDatataypeFromSegment(segment));
                        $scope.getTablesFromSegment(segment);

                    
              }else if(group.children[i].type==="group"){
                        console.log("group case ");
                        $scope.getSegmentsFromgroup(group.children[i]);
              }
            }

          }
            $scope.getDatataypeFromSegment=function(seg){
              var data=[];
              for(var i=0; i<seg.fields.length; i++){
                console.log(seg.fields[i].datatype.id);
                var datatype = $rootScope.datatypesMap[seg.fields[i].datatype.id];
                console.log(datatype);
                $scope.getTablesFromDatatype(datatype);
                var temp=[];
                temp.push(datatype);
                temp=_.union(temp, $scope.getDatatypeFromDatatype(datatype));
                data=_.union(data,temp);

              }
              return data;
            }

              $scope.getTablesFromSegment=function(seg){
              var tables=[];
              for(var i=0; i<seg.fields.length; i++){
                if(seg.fields[i].table!=null){
                var table = $rootScope.tablesMap[seg.fields[i].table.id];
                //console.log(datatype);
                var temp=[];
                
                temp.push(table);
                tables=_.union(tables,temp);
                $rootScope.selectedTables=_.union($rootScope.selectedTables,tables);
                }

              }
            
            }


            $scope.getDatatypeFromDatatype = function(datatype){
              var data=[];
              if(datatype.components.length===0){
                $scope.getTablesFromDatatype(datatype);
                return 0;
              }
              else {

                for(var i=0; i<datatype.components.length; i++){

                  var temp= [];
                  temp.push($rootScope.datatypesMap[datatype.components[i].datatype.id]);
                  console.log($rootScope.tablesMap[datatype.components[i].datatype.id]);
                  $scope.getTablesFromDatatype($rootScope.datatypesMap[datatype.components[i].datatype.id]);
                  data=_.union(data,temp);
                }
              }
              return data;
            }

            $scope.getTablesFromDatatype = function (datatype){
             // var tables=[];
             console.log(datatype);
             if(datatype===undefined){
             }
              if(datatype.components&&datatype.components.length>0){
               for (var i = datatype.components.length - 1; i >= 0; i--) {
                  if(datatype.components[i].table && datatype.components[i].table!=null){
                        var table =$rootScope.tablesMap[datatype.components[i].table.id];
                        var tmp=[];
                        tmp.push(table);
                        $rootScope.selectedTables=_.union($rootScope.selectedTables,tmp);
                  }                 
               }
              }
            }





            $scope.removeFromSelection= function(item){
              console.log(item.id);
              console.log($rootScope.selectedMessages);

                    for(var j=0; j< $rootScope.selectedMessages.length; j++){
                  
                    if(item.id===$rootScope.selectedMessages[j].id){
                                    console.log("true");

                      $rootScope.selectedMessages.splice(1,j); 

                   }
              }

            }
            $scope.getRelatedSegments= function(message){


            }
         
            $scope.filtermsgdata = function(){
                return FilteringSvc.getMsgdata();
            };
            
            $scope.filtermsgsettings = function(){
                return FilteringSvc.getMsgsettings();
            };

            $scope.filtermsgsettings = function(){
                return FilteringSvc.getMsgsettings();
            };

            $scope.filterusagesmodel = function(){
                return FilteringSvc.getUsagesmodel();
            };

            $scope.filterusagesdata = function(){
                return FilteringSvc.getUsagesdata();
            };

            $scope.filterusagessettings = function(){
                return FilteringSvc.getUsagessettings();
            };

            $scope.filterusagetexts = function(){
                return FilteringSvc.getUsagestexts();
            };



//            $rootScope.$on('event:loadFilter', function (event, igdocument) {
//         //       FilteringSvc.loadMessages(igdocument);
//  //              FilteringSvc.loadUsages();
//            });

//            $rootScope.$on('event:loadMastermap', function (event, igdocument) {
//              MastermapSvc.parseIg(igdocument);
//            });
            
            
  }
);

/**
 * Created by haffo on 2/13/15.
 */
angular.module('igl')
    .controller('DatatypesInLib', function($scope, $rootScope, Restangular, ngTreetableParams, $filter, $http, $q, $modal, $timeout, CloneDeleteSvc, ViewSettings, DatatypeService, ComponentService, MastermapSvc, FilteringSvc, DatatypeLibrarySvc, TableLibrarySvc, MessageService, TableService, blockUI) {
        $scope.accordStatus = {
            isCustomHeaderOpen: false,
            isFirstOpen: true,
            isSecondOpen: true,
            isThirdOpen: true,
            isFirstDisabled: false
        };
        $scope.editableDT = '';
        $scope.editableVS = '';
        $scope.readonly = false;
        $scope.saved = false;
        $scope.message = false;
        $scope.datatypeCopy = null;
        $scope.viewSettings = ViewSettings;
        $scope.selectedChildren = [];
        $scope.saving = false;
        $scope.init = function() {};
        $scope.deleteComponent = function(componentToDelete, datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'DeleteComponent.html',
                controller: 'DeleteComponentCtrl',
                size: 'md',
                resolve: {
                    componentToDelete: function() {
                        return componentToDelete;
                    },
                    datatype: function() {
                        return datatype;
                    }


                }
            });
            modalInstance.result.then(function() {

                $scope.setDirty();
                try {
                    if ($scope.datatypesParams)
                        $scope.datatypesParams.refresh();
                } catch (e) {

                }
            });
        };

        $scope.deletePredicate = function(position, datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'DeleteDatatypePredicate.html',
                controller: 'DeleteDatatypePredicateCtrl',
                size: 'md',
                resolve: {
                    position: function() {
                        return position;
                    },
                    datatype: function() {
                        return datatype;
                    }
                }
            });
            modalInstance.result.then(function() {
                $scope.setDirty();
            });
        };

        $scope.openPredicateDialog = function(node) {
            if (node.usage == 'C') $scope.managePredicate(node);
        };
        
        $scope.save = function() {
            var datatype = $rootScope.datatype;
            
            console.log(datatype);
            var ext = datatype.ext;

            DatatypeService.save(datatype).then(function(result) {
                var oldLink = DatatypeLibrarySvc.findOneChild(result.id,$scope.datatypeLibrary.children);
                var newLink = DatatypeService.getDatatypeLink(result);
                newLink.ext = ext;
                DatatypeLibrarySvc.updateChild($scope.datatypeLibrary.id, newLink).then(function(link) {
                    $scope.saving = false;
                    //$rootScope.datatypesMap[result.id] = result;
                    console.log("before the merge")
                    console.log($rootScope.datatypesMap[result.id]);
                    console.log("After the merge")
                    console.log($rootScope.datatypesMap[result.id]);

                    DatatypeService.merge($rootScope.datatypesMap[result.id], result);
                    DatatypeService.merge($rootScope.datatypesMap[result.id], result);

                    cleanState();
                }, function(error) {
                    $scope.saving = false;
                    $rootScope.msg().text = "Sorry an error occured. Please try again";
                    $rootScope.msg().type = "danger";
                    $rootScope.msg().show = true;
                });

            }, function(error) {
                $scope.saving = false;
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        };
        $scope.confirmPublish = function(datatypeCopy) {
            var modalInstance = $modal.open({
                templateUrl: 'ConfirmDatatypePublishCtl.html',
                controller: 'ConfirmDatatypePublishCtl',
                resolve: {
                    datatypeToPublish: function() {
                        return datatypeCopy;
                    }
                }
            });
            modalInstance.result.then(function(datatypeCopy) {
                if ($rootScope.datatypesParams) {
                    $rootScope.datatypesParams.refresh();
                }
                $scope.save();
            });
        };
        

        $scope.abortPublish = function(datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'AbortPublishCtl.html',
                controller: 'AbortPublishCtl',
                resolve: {
                    datatypeToPublish: function() {
                        return datatype;
                    },
                    unpublishedDatatypes: function() {
                        return $scope.unpublishedDatatypes;
                    },
                    unpublishedTables: function() {
                        return $scope.unpublishedTables;
                    }

                }
            });

        };
        
        
        
        $scope.OtoX = function(message) {
            console.log(message);
            var modalInstance = $modal.open({
                templateUrl: 'OtoX.html',
                controller: 'OtoXCtrl',
                size: 'md',
                resolve: {
                    message: function() {
                        return message;
                    }
                }
            });
            modalInstance.result.then(function() {
                $scope.setDirty();
                try {
                    if ($scope.datatypesParams)
                        $scope.datatypesParams.refresh();
                } catch (e) {

                }
            });
        };

        $scope.editableComp = '';
        $scope.editComponent = function(component) {
            $scope.editableComp = component.id;
            $scope.compName = component.name;

        };

        $scope.backComp = function() {
            $scope.editableComp = '';
        };
        $scope.applyComp = function(datatype, component, name, position) {
            blockUI.start();
            $scope.editableComp = '';
            if (component) {
                component.name = name;


            }
            if (position) {
                MessageService.updatePosition(datatype.components, component.position - 1, position - 1);
            }
            $scope.setDirty();

            if ($scope.datatypesParams)
                $scope.datatypesParams.refresh();
            $scope.Posselected = false;
            blockUI.stop();

        };
        $scope.selectPos = function() {

            $scope.Posselected = true;
        };
        
                $scope.dtmSliderOptions = {
                   ceil: 7,
                    floor: 0,
                    showSelectionBar: true,
                    onChange: function(id) {
                       $scope.setDirty();
                   },
                    showTicks: true,
                    getTickColor: function (value) {
                        if (value < 3)
                            return 'red';
                        if (value < 6)
                            return 'orange';
                       if (value < 8)
                           return 'yellow';
                        return '#2AE02A';
                    }
                };
                
               $scope.refreshSlider = function(){
                    setTimeout(function(){
                        $scope.$broadcast('reCalcViewDimensions');
                        console.log("refreshed Slider!!");
                   }, 1000);
               };
        
        
        
        
        
        $scope.initDatatypes = function() {
            // if($rootScope.datatypesParams!==undefined){
            //     $rootScope.datatypesParams.refresh();

            // }
            console.log("$rootScope.datatype");
            // else{
            $rootScope.datatypesParams = new ngTreetableParams({
                getNodes: function(parent) {
                    return DatatypeService.getDatatypeNodesInLib(parent, $rootScope.datatype);
                },
                getTemplate: function(node) {
                    return DatatypeService.getTemplateINLIB(node, $rootScope.datatype);
                }
            });
            console.log($rootScope.datatype);
            if ($rootScope.datatypesParams) {

                $rootScope.datatypesParams.refresh();
            }


            //}
        };



        $scope.selectDT = function(field, datatype) {
            $scope.DTselected = true;
            blockUI.start();
            field.datatype.ext = JSON.parse(datatype).ext;
            field.datatype.id = JSON.parse(datatype).id;
            field.datatype.label = JSON.parse(datatype).label;
            field.datatype.name = JSON.parse(datatype).name;
            console.log(field);
            $scope.setDirty();
            // $rootScope.processElement(field);

            if ($scope.datatypesParams)
                $scope.datatypesParams.refresh();
            $scope.editableDT = '';
            $scope.DTselected = false;
            blockUI.stop();


        };
        // $scope.applyDT = function(field, datatype) {
        //     blockUI.start();
        //     field.datatype.ext = JSON.parse(datatype).ext;
        //     field.datatype.id = JSON.parse(datatype).id;
        //     field.datatype.label = JSON.parse(datatype).label;
        //     field.datatype.name = JSON.parse(datatype).name;
        //     console.log(field);
        //     $scope.setDirty();
        //     // $rootScope.processElement(field);

        //     if ($scope.datatypesParams)
        //         $scope.datatypesParams.refresh();
        //     $scope.editableDT = '';
        //     $scope.DTselected = false;
        //     blockUI.stop();

        // };
        $scope.redirectDT = function(datatype) {
            DatatypeService.getOne(datatype.id).then(function(datatype) {
                var modalInstance = $modal.open({
                    templateUrl: 'redirectCtrl.html',
                    controller: 'redirectCtrl',
                    size: 'md',
                    resolve: {
                        destination: function() {
                            return datatype;
                        }
                    }



                });
                modalInstance.result.then(function() {
                	console.log("EDITING")
                    $scope.editDataType(datatype);
                });



            });
        };


//        $scope.editDT = function(field) {
//            $scope.editableDT = field.id;
//            $scope.loadLibrariesByFlavorName = function() {
//                var delay = $q.defer();
//                $scope.ext = null;
//                $scope.results = [];
//                $scope.tmpResults = [];
//                $scope.results = $scope.results.concat(filterFlavors($scope.datatypeLibrary, field.datatype.name));
//                $scope.tmpResults = [].concat($scope.results);
//                DatatypeLibrarySvc.findLibrariesByFlavorName(field.datatype.name, 'HL7STANDARD', $scope.datatypeLibrary.metaData.hl7Version).then(function(libraries) {
//                    if (libraries != null) {
//                        _.each(libraries, function(library) {
//                            $scope.results = $scope.results.concat(filterFlavors(library, field.datatype.name));
//                        });
//                    }
//
//                    $scope.results = _.uniq($scope.results, function(item, key, a) {
//                        return item.id;
//                    });
//                    $scope.tmpResults = [].concat($scope.results);
//
//                    delay.resolve(true);
//                }, function(error) {
//                    $rootScope.msg().text = "Sorry could not load the data types";
//                    $rootScope.msg().type = error.data.type;
//                    $rootScope.msg().show = true;
//                    delay.reject(error);
//                });
//                return delay.promise;
//            };
//
//
//            var filterFlavors = function(library, name) {
//                var results = [];
//                _.each(library.children, function(link) {
//                    if (link.name === name) {
//                        link.libraryName = library.metaData.name;
//                        link.hl7Version = $rootScope.datatypesMap[link.id].hl7Version;
//                        //link.hl7Version = library.metaData.hl7Version;
//                        results.push(link);
//                    }
//                });
//                return results;
//            };
//
//
//
//
//            $scope.loadLibrariesByFlavorName().then(function(done) {
//                console.log($scope.results);
//                // $scope.selection.selected = $scope.currentDatatype.id;
//                // $scope.showSelectedDetails($scope.currentDatatype);
//            });
//        };
        $scope.results = [];
        $scope.editDT = function(field) {
            $scope.editableDT = field.id;

                $scope.results = [];
                angular.forEach($scope.datatypeLibrary.children ,function(dtLink){
                	if(dtLink.name&&dtLink.name===field.datatype.name&&field.datatype.id!==dtLink.id){
                		$scope.results.push(dtLink);
                	}
                });
            };
        
        $scope.backDT = function() {
            $scope.editableDT = '';
        };



        $scope.editVSModal = function(component) {
            var modalInstance = $modal.open({
                templateUrl: 'editVSModal.html',
                controller: 'EditVSCtrlForLib',
                windowClass: 'edit-VS-modal',
                resolve: {

                    valueSets: function() {
                        return $rootScope.tables;
                    },

                    component: function() {
                        return component;
                    }

                }
            });
            modalInstance.result.then(function(datatype) {
                $scope.setDirty();
                if ($scope.datatypesParams) {
                    $scope.datatypesParams.refresh();
                }
            });

        };

        $scope.editVS = function(field) {
            $scope.editableVS = field.id;
            if (field.table !== null) {
                $scope.VSselected = true;
                $scope.selectedValueSet = field.table;
                console.log($scope.selectedValueSet);

            } else {
                $scope.VSselected = false;

            }
        };
        $scope.backVS = function() {
            $scope.editableVS = '';
        };

        $scope.selectVS = function(field, valueSet) {
            $scope.selectedValueSet = valueSet;
            $scope.VSselected = true;
            $scope.editableVS = '';
            if (field.table === null) {
                field.table = {
                    id: '',
                    bindingIdentifier: ''

                };
                console.log(field);

            }

            field.table.id = $scope.selectedValueSet.id;
            field.table.bindingIdentifier = $scope.selectedValueSet.bindingIdentifier;
            $scope.setDirty();
            $scope.VSselected = false;



        };
        // $scope.applyVS = function(field) {
        //     $scope.editableVS = '';
        //     if (field.table === null) {
        //         field.table = {
        //             id: '',
        //             bindingIdentifier: ''

        //         };
        //         console.log(field);

        //     }

        //     field.table.id = $scope.selectedValueSet.id;
        //     field.table.bindingIdentifier = $scope.selectedValueSet.bindingIdentifier;
        //     $scope.setDirty();
        //     $scope.VSselected = false;

        // };

        $scope.redirectVS = function(valueSet) {
            TableService.getOne(valueSet.id).then(function(valueSet) {
                var modalInstance = $modal.open({
                    templateUrl: 'redirectCtrl.html',
                    controller: 'redirectCtrl',
                    size: 'md',
                    resolve: {
                        destination: function() {
                            return valueSet;
                        }
                    }



                });
                modalInstance.result.then(function() {
                    $rootScope.editTable(valueSet);
                });



            });
        };


        $scope.selectedVS = function() {
            return ($scope.selectedValueSet !== undefined);
        };
        $scope.unselectVS = function() {
            $scope.selectedValueSet = undefined;
            $scope.VSselected = false;

            //$scope.newSeg = undefined;
        };
        $scope.isVSActive = function(id) {
            if ($scope.selectedValueSet) {
                return $scope.selectedValueSet.id === id;
            } else {
                return false;
            }

        };





        $scope.addComponentModal = function(datatype) {
            console.log(datatype);
            var modalInstance = $modal.open({
                templateUrl: 'AddComponentModal.html',
                controller: 'AddComponentCtrl',
                windowClass: 'app-modal-window',
                resolve: {

                    valueSets: function() {
                        return $rootScope.tables;
                    },
                    datatypes: function() {
                        return $rootScope.datatypes;
                    },
                    datatype: function() {
                        return datatype;
                    },
                    messageTree: function() {
                        return $rootScope.messageTree;
                    }

                }
            });
            modalInstance.result.then(function(datatype) {
                $scope.setDirty();

                if ($scope.datatypesParams)
                    $scope.datatypesParams.refresh();
            });
        };

        $scope.copy = function(datatype) {
            CloneDeleteSvc.copyDatatype(datatype);
        };

        $scope.reset = function() {
        	console.log("Called reset");
            blockUI.start();
            $rootScope.datatype = angular.copy($rootScope.datatypesMap[$scope.datatype.id]);
            cleanState();
            blockUI.stop();
        };

        $scope.recordDatatypeChange = function(type, command, id, valueType, value) {
            var datatypeFromChanges = $rootScope.findObjectInChanges("datatype", "add", $rootScope.datatype.id);
            if (datatypeFromChanges === undefined) {
                $rootScope.recordChangeForEdit2(type, command, id, valueType, value);
            }
        };

        $scope.close = function() {
            $rootScope.datatype = null;
            $scope.refreshTree();
            $scope.loadingSelection = false;
        };

        $scope.delete = function(datatype) {
            CloneDeleteSvc.deleteDatatype(datatype);
        };

        $scope.hasChildren = function(node) {
            return node && node != null && node.datatype && $rootScope.getDatatype(node.datatype.id) != undefined && $rootScope.getDatatype(node.datatype.id).components != null && $rootScope.getDatatype(node.datatype.id).components.length > 0;
        };

        $scope.validateLabel = function(label, name) {
            if (label && !label.startsWith(name)) {
                return false;
            }
            return true;
        };

        $scope.onDatatypeChange = function(node) {
            $rootScope.recordChangeForEdit2('component', 'edit', node.id, 'datatype', node.datatype);
            $scope.refreshTree(); // TODO: Refresh only the node
        };

        $scope.refreshTree = function() {
            if ($scope.datatypesParams)
                $scope.datatypesParams.refresh();
        };

        $scope.goToTable = function(table) {
            $scope.$emit('event:openTable', table);
        };

        $scope.deleteTable = function(node) {
            node.table = null;
            $rootScope.recordChangeForEdit2('component', 'edit', node.id, 'table', null);
        };

        $scope.mapTable = function(node) {
            var modalInstance = $modal.open({
                templateUrl: 'TableMappingDatatypeCtrl.html',
                controller: 'TableMappingDatatypeCtrl',
                windowClass: 'app-modal-window',
                resolve: {
                    selectedNode: function() {
                        return node;
                    }
                }
            });
            modalInstance.result.then(function(node) {
                $scope.selectedNode = node;
                $scope.setDirty();
            }, function() {});
        };

        $scope.managePredicate = function(node) {
            var modalInstance = $modal.open({
                templateUrl: 'PredicateDatatypeCtrl.html',
                controller: 'PredicateDatatypeCtrlForLib',
                windowClass: 'app-modal-window',
                resolve: {
                    selectedNode: function() {
                        return node;
                    }
                }
            });
            modalInstance.result.then(function(node) {
                $scope.selectedNode = node;
                $scope.setDirty();
            }, function() {});
        };

        $scope.manageConformanceStatement = function(node) {
            var modalInstance = $modal.open({
                templateUrl: 'ConformanceStatementDatatypeCtrl.html',
                controller: 'ConformanceStatementDatatypeCtrlForLib',
                windowClass: 'app-modal-window',
                resolve: {
                    selectedNode: function() {
                        return node;
                    }
                }
            });
            modalInstance.result.then(function(node) {
                $scope.selectedNode = node;
                $scope.setDirty();
            }, function() {});
        };

        $scope.isSubDT = function(component) {
            if ($rootScope.datatype != null) {
                for (var i = 0, len = $rootScope.datatype.components.length; i < len; i++) {
                    if ($rootScope.datatype.components[i].id === component.id)
                        return false;
                }
            }
            return true;
        };

        $scope.findDTByComponentId = function(componentId) {
            return $rootScope.parentsMap[componentId] ? $rootScope.parentsMap[componentId] : null;
        };

        $scope.countConformanceStatements = function(position) {
            var count = 0;
            if ($rootScope.datatype != null)
                for (var i = 0, len1 = $rootScope.datatype.conformanceStatements.length; i < len1; i++) {
                    if ($rootScope.datatype.conformanceStatements[i].constraintTarget.indexOf(position + '[') === 0)
                        count = count + 1;
                }

            return count;
        };

        $scope.countPredicate = function(position) {
            var count = 0;
            if ($rootScope.datatype != null)
                for (var i = 0, len1 = $rootScope.datatype.predicates.length; i < len1; i++) {
                    if ($rootScope.datatype.predicates[i].constraintTarget.indexOf(position + '[') === 0)
                        count = count + 1;
                }

            return count;
        };

        $scope.countPredicateOnSubComponent = function(position, componentId) {
            var dt = $scope.findDTByComponentId(componentId);
            if (dt != null)
                for (var i = 0, len1 = dt.predicates.length; i < len1; i++) {
                    if (dt.predicates[i].constraintTarget.indexOf(position + '[') === 0)
                        return 1;
                }

            return 0;
        };


        $scope.isRelevant = function(node) {
            return DatatypeService.isRelevant(node);
        };

        $scope.isBranch = function(node) {
            return DatatypeService.isBranch(node);
        };


        $scope.isVisible = function(node) {
            return DatatypeService.isVisible(node);
        };

        $scope.children = function(node) {
            return DatatypeService.getNodes(node);
        };

        $scope.getParent = function(node) {
            return DatatypeService.getParent(node);
        };

        $scope.getDatatypeLevelConfStatements = function(element) {
            return DatatypeService.getDatatypeLevelConfStatements(element);
        };

        $scope.getDatatypeLevelPredicates = function(element) {
            return DatatypeService.getDatatypeLevelPredicates(element);
        };

        $scope.isChildSelected = function(component) {
            return $scope.selectedChildren.indexOf(component) >= 0;
        };

        $scope.isChildNew = function(component) {
            return component && component != null && component.status === 'DRAFT';
        };


        $scope.selectChild = function($event, child) {
            var checkbox = $event.target;
            var action = (checkbox.checked ? 'add' : 'remove');
            updateSelected(action, child);
        };


        $scope.selectAllChildren = function($event) {
            var checkbox = $event.target;
            var action = (checkbox.checked ? 'add' : 'remove');
            for (var i = 0; i < $rootScope.datatype.components.length; i++) {
                var component = $rootScope.datatype.components[i];
                updateSelected(action, component);
            }
        };

        var updateSelected = function(action, child) {
            if (action === 'add' && !$scope.isChildSelected(child)) {
                $scope.selectedChildren.push(child);
            }
            if (action === 'remove' && $scope.isChildSelected(child)) {
                $scope.selectedChildren.splice($scope.selectedChildren.indexOf(child), 1);
            }
        };

        //something extra I couldn't resist adding :)
        $scope.isSelectedAllChildren = function() {
            return $rootScope.datatype && $rootScope.datatype != null && $rootScope.datatype.components && $scope.selectedChildren.length === $rootScope.datatype.components.length;
        };


        /**
         * TODO: update master map
         */
        $scope.createNewComponent = function() {
            if ($rootScope.datatype != null) {
                if (!$rootScope.datatype.components || $rootScope.datatype.components === null)
                    $rootScope.datatype.components = [];
                var child = ComponentService.create($rootScope.datatype.components.length + 1);
                $rootScope.datatype.components.push(child);
                //TODO update master map
                //MastermapSvc.addDatatypeObject($rootScope.datatype, [[$rootScope.igdocument.id, "ig"], [$scope.datatypeLibrary.id, "profile"]]);
                //TODO:remove as legacy code
                $rootScope.parentsMap[child.id] = $rootScope.datatype;
                if ($scope.datatypesParams)
                    $scope.datatypesParams.refresh();
            }
        };

        /**
         * TODO: update master map
         */
        $scope.deleteComponents = function() {
            if ($rootScope.datatype != null && $scope.selectedChildren != null && $scope.selectedChildren.length > 0) {
                ComponentService.deleteList($scope.selectedChildren, $rootScope.datatype);
                //TODO update master map
                //TODO:remove as legacy code
                angular.forEach($scope.selectedChildren, function(child) {
                    delete $rootScope.parentsMap[child.id];
                });
                $scope.selectedChildren = [];
                if ($scope.datatypesParams)
                    $scope.datatypesParams.refresh();
            }
        };


        var cleanState = function() {
            $scope.selectedChildren = [];
            $rootScope.addedDatatypes = [];
            $rootScope.addedTables = [];
            if ($scope.editForm) {
                $scope.editForm.$setPristine();
                $scope.editForm.$dirty = false;
            }
            $rootScope.clearChanges();
            if ($scope.datatypesParams)
                $scope.datatypesParams.refresh();
        };
        $scope.callDTDelta = function() {

            $rootScope.$emit("event:openDTDelta");
        };
        
        
        $rootScope.$on('event:initDatatypeInLib', function(event) {

                $scope.initt();
            
        });
        
        $scope.initt = function() {       
                if ($scope.dynamicDt_params) {
                    $scope.dynamicDt_params.refresh();
                }

        };
        $scope.cancel = function() {
            //TODO: remove changes from master ma
            angular.forEach($rootScope.datatype.components, function(child) {
                if ($scope.isChildNew(child.status)) {
                    delete $rootScope.parentsMap[child.id];
                }
            });
            $rootScope.datatype = null;
            $scope.selectedChildren = [];
            $rootScope.clearChanges();
        };

        var searchById = function(id) {
            var children = $scope.datatypeLibrary.children;
            for (var i = 0; i < $scope.datatypeLibrary.children; i++) {
                if (children[i].id === id) {
                    return children[i];
                }
            }
            return null;
        };

        var indexIn = function(id, collection) {
            for (var i = 0; i < collection.length; i++) {
                if (collection[i].id === id) {
                    return i;
                }
            }
            return -1;
        };


        $scope.showSelectDatatypeFlavorDlg = function(component) {
            var modalInstance = $modal.open({
                templateUrl: 'SelectDatatypeFlavor.html',
                controller: 'SelectDatatypeFlavorCtrl',
                windowClass: 'app-modal-window',
                resolve: {
                    currentDatatype: function() {
                        return $rootScope.datatypesMap[component.datatype.id];
                    },

                    hl7Version: function() {
                        return $scope.datatypeLibrary.metaData.hl7Version;
                    },
                    datatypeLibrary: function() {
                        return $scope.datatypeLibrary;
                    }
                }
            });
            modalInstance.result.then(function(datatype, ext) {
                //                MastermapSvc.deleteElementChildren(component.datatype.id, "datatype", component.id, component.type);
                //                MastermapSvc.addDatatypeObject(datatype, [[component.id, component.type]]);
                component.datatype.id = datatype.id;
                component.datatype.name = datatype.name;
                component.datatype.ext = datatype.ext;
                $rootScope.processElement(component);
                $scope.setDirty();
                if ($scope.datatypesParams)
                    $scope.datatypesParams.refresh();

            });

        };

    });



angular.module('igl').controller('ConformanceStatementDatatypeCtrlForLib', function($scope, $modalInstance, selectedNode, $rootScope) {
    $scope.constraintType = 'Plain';
    $scope.selectedNode = selectedNode;
    $scope.firstConstraint = null;
    $scope.secondConstraint = null;
    $scope.compositeType = null;
    $scope.complexConstraint = null;
    $scope.newComplexConstraintId = $rootScope.calNextCSID($rootScope.libEXT, $scope.datatype.name + "_" + $scope.datatype.ext);
    $scope.newComplexConstraint = [];
    $scope.constraints = [];

    $scope.changed = false;
    $scope.tempComformanceStatements = [];
    angular.copy($scope.datatype.conformanceStatements, $scope.tempComformanceStatements);


    $scope.setChanged = function() {
        $scope.changed = true;
    }

    $scope.initConformanceStatement = function() {
        $scope.newConstraint = angular.fromJson({
            position_1: null,
            position_2: null,
            location_1: null,
            location_2: null,
            datatype: '',
            component_1: null,
            subComponent_1: null,
            component_2: null,
            subComponent_2: null,
            freeText: null,
            verb: null,
            ignoreCase: false,
            constraintId: $rootScope.calNextCSID($rootScope.libEXT, $scope.datatype.name + "_" + $scope.datatype.ext),
            contraintType: null,
            value: null,
            value2: null,
            valueSetId: null,
            bindingStrength: 'R',
            bindingLocation: '1'
        });
        $scope.newConstraint.datatype = $rootScope.datatype.name;
    }

    $scope.initComplexStatement = function() {
        $scope.constraints = [];
        $scope.firstConstraint = null;
        $scope.secondConstraint = null;
        $scope.compositeType = null;
        $scope.newComplexConstraintId = $rootScope.calNextCSID($rootScope.libEXT, $scope.datatype.name + "_" + $scope.datatype.ext);
    }

    $scope.initConformanceStatement();

    $scope.deleteConformanceStatement = function(conformanceStatement) {
        $rootScope.conformanceStatementIdList.splice($rootScope.conformanceStatementIdList.indexOf($scope.tempComformanceStatements.constraintId), 1);
        $scope.tempComformanceStatements.splice($scope.tempComformanceStatements.indexOf(conformanceStatement), 1);
        $scope.changed = true;
    };

    $scope.updateComponent_1 = function() {
        $scope.newConstraint.subComponent_1 = null;
    };

    $scope.updateComponent_2 = function() {
        $scope.newConstraint.subComponent_2 = null;
    };

    $scope.genLocation = function(datatype, component, subComponent) {
        var location = null;
        if (component != null && subComponent == null) {
            location = datatype + '.' + component.position + "(" + component.name + ")";
        } else if (component != null && subComponent != null) {
            location = datatype + '.' + component.position + '.' + subComponent.position + "(" + subComponent.name + ")";
        }

        return location;
    };

    $scope.genPosition = function(component, subComponent) {
        var position = null;
        if (component != null && subComponent == null) {
            position = component.position + '[1]';
        } else if (component != null && subComponent != null) {
            position = component.position + '[1]' + '.' + subComponent.position + '[1]';
        }

        return position;
    };

    $scope.addComplexConformanceStatement = function() {
        $scope.complexConstraint = $rootScope.generateCompositeConformanceStatement($scope.compositeType, $scope.firstConstraint, $scope.secondConstraint, $scope.constraints);
        $scope.complexConstraint.constraintId = $scope.newComplexConstraintId;
        if ($rootScope.conformanceStatementIdList.indexOf($scope.complexConstraint.constraintId) == -1) $rootScope.conformanceStatementIdList.push($scope.complexConstraint.constraintId);
        $scope.tempComformanceStatements.push($scope.complexConstraint);
        $scope.initComplexStatement();
        $scope.changed = true;
    };

    $scope.addFreeTextConformanceStatement = function() {
        $rootScope.newConformanceStatementFakeId = $rootScope.newConformanceStatementFakeId - 1;
        var cs = null;
        if ($scope.selectedNode === null) {
            var cs = $rootScope.generateFreeTextConformanceStatement(".", $scope.newConstraint);
        } else {
            var cs = $rootScope.generateFreeTextConformanceStatement($scope.selectedNode.position + '[1]', $scope.newConstraint);
        }
        $scope.tempComformanceStatements.push(cs);
        $scope.changed = true;
        if ($rootScope.conformanceStatementIdList.indexOf(cs.constraintId) == -1) $rootScope.conformanceStatementIdList.push(cs.constraintId);
        $scope.initConformanceStatement();
    };

    $scope.addConformanceStatement = function() {
        $scope.newConstraint.position_1 = $scope.genPosition($scope.newConstraint.component_1, $scope.newConstraint.subComponent_1);
        $scope.newConstraint.position_2 = $scope.genPosition($scope.newConstraint.component_2, $scope.newConstraint.subComponent_2);
        $scope.newConstraint.location_1 = $scope.genLocation($scope.newConstraint.datatype, $scope.newConstraint.component_1, $scope.newConstraint.subComponent_1);
        $scope.newConstraint.location_2 = $scope.genLocation($scope.newConstraint.datatype, $scope.newConstraint.component_2, $scope.newConstraint.subComponent_2);

        if ($scope.newConstraint.position_1 != null) {
            $rootScope.newConformanceStatementFakeId = $rootScope.newConformanceStatementFakeId - 1;
            var cs = $rootScope.generateConformanceStatement($scope.selectedNode.position + '[1]', $scope.newConstraint);
            $scope.tempComformanceStatements.push(cs);
            $scope.changed = true;
            if ($rootScope.conformanceStatementIdList.indexOf(cs.constraintId) == -1) $rootScope.conformanceStatementIdList.push(cs.constraintId);
        }
        $scope.initConformanceStatement();
    };

    $scope.ok = function() {
        angular.forEach($scope.tempComformanceStatements, function(cs) {
            $rootScope.conformanceStatementIdList.splice($rootScope.conformanceStatementIdList.indexOf(cs.constraintId), 1);
        });

        angular.forEach($rootScope.datatype.conformanceStatements, function(cs) {
            if ($rootScope.conformanceStatementIdList.indexOf(cs.constraintId) == -1) $rootScope.conformanceStatementIdList.push(cs.constraintId);
        });

        $modalInstance.close($scope.selectedNode);
    };

    $scope.saveclose = function() {
        angular.forEach($scope.tempComformanceStatements, function(cs) {
            if ($rootScope.conformanceStatementIdList.indexOf(cs.constraintId) == -1) $rootScope.conformanceStatementIdList.push(cs.constraintId);
        });
        angular.copy($scope.tempComformanceStatements, $rootScope.datatype.conformanceStatements);
        $rootScope.recordChanged();
        $modalInstance.close($scope.selectedNode);
    };
});

angular.module('igl').controller('PredicateDatatypeCtrlForLib', function($scope, $modalInstance, selectedNode, $rootScope) {
    $scope.constraintType = 'Plain';
    $scope.selectedNode = selectedNode;
    $scope.constraints = [];
    $scope.firstConstraint = null;
    $scope.secondConstraint = null;
    $scope.compositeType = null;
    $scope.complexConstraint = null;
    $scope.complexConstraintTrueUsage = null;
    $scope.complexConstraintFalseUsage = null;

    $scope.changed = false;
    $scope.tempPredicates = [];
    angular.copy($rootScope.datatype.predicates, $scope.tempPredicates);


    $scope.countPredicateForTemp = function() {
        var count = 0;

        for (var i = 0, len1 = $scope.tempPredicates.length; i < len1; i++) {
            if ($scope.tempPredicates[i].constraintTarget.indexOf($scope.selectedNode.position + '[') === 0)
                count = count + 1;
        }
        return count;
    };


    $scope.setChanged = function() {
        $scope.changed = true;
    }

    $scope.initPredicate = function() {
        $scope.newConstraint = angular.fromJson({
            position_1: null,
            position_2: null,
            location_1: null,
            location_2: null,
            datatype: '',
            component_1: null,
            subComponent_1: null,
            component_2: null,
            subComponent_2: null,
            verb: null,
            freeText: null,
            contraintType: null,
            value: null,
            ignoreCase: false,
            value2: null,
            trueUsage: null,
            falseUsage: null,
            valueSetId: null,
            bindingStrength: 'R',
            bindingLocation: '1'
        });
        $scope.newConstraint.datatype = $rootScope.datatype.name;
    }

    $scope.initComplexPredicate = function() {
        $scope.constraints = [];
        $scope.firstConstraint = null;
        $scope.secondConstraint = null;
        $scope.compositeType = null;
        $scope.complexConstraintTrueUsage = null;
        $scope.complexConstraintFalseUsage = null;
    }

    $scope.initPredicate();


    $scope.deletePredicate = function(predicate) {
        $scope.tempPredicates.splice($scope.tempPredicates.indexOf(predicate), 1);
        $scope.changed = true;
    };

    $scope.updateComponent_1 = function() {
        $scope.newConstraint.subComponent_1 = null;
    };

    $scope.updateComponent_2 = function() {
        $scope.newConstraint.subComponent_2 = null;
    };


    $scope.genLocation = function(datatype, component, subComponent) {
        var location = null;
        if (component != null && subComponent == null) {
            location = datatype + '.' + component.position + "(" + component.name + ")";
        } else if (component != null && subComponent != null) {
            location = datatype + '.' + component.position + '.' + subComponent.position + "(" + subComponent.name + ")";
        }

        return location;
    };

    $scope.genPosition = function(component, subComponent) {
        var position = null;
        if (component != null && subComponent == null) {
            position = component.position + '[1]';
        } else if (component != null && subComponent != null) {
            position = component.position + '[1]' + '.' + subComponent.position + '[1]';
        }

        return position;
    };


    $scope.deletePredicateByTarget = function() {
        for (var i = 0, len1 = $scope.tempPredicates.length; i < len1; i++) {
            if ($scope.tempPredicates[i].constraintTarget.indexOf($scope.selectedNode.position + '[') === 0) {
                $scope.deletePredicate($scope.tempPredicates[i]);
                return true;
            }
        }
        return false;
    };

    $scope.addComplexPredicate = function() {
        $scope.complexConstraint = $rootScope.generateCompositePredicate($scope.compositeType, $scope.firstConstraint, $scope.secondConstraint, $scope.constraints);
        $scope.complexConstraint.trueUsage = $scope.complexConstraintTrueUsage;
        $scope.complexConstraint.falseUsage = $scope.complexConstraintFalseUsage;

        if ($scope.selectedNode === null) {
            $scope.complexConstraint.constraintId = '.';
        } else {
            $scope.complexConstraint.constraintId = $scope.newConstraint.datatype + '-' + $scope.selectedNode.position;
        }

        $scope.tempPredicates.push($scope.complexConstraint);
        $scope.initComplexPredicate();
        $scope.changed = true;
    };

    $scope.addFreeTextPredicate = function() {
        $rootScope.newPredicateFakeId = $rootScope.newPredicateFakeId - 1;
        var cp = null;
        if ($scope.selectedNode === null) {
            var cp = $rootScope.generateFreeTextPredicate(".", $scope.newConstraint);
        } else {
            var cp = $rootScope.generateFreeTextPredicate($scope.selectedNode.position + '[1]', $scope.newConstraint);
        }

        $scope.tempPredicates.push(cp);
        $scope.changed = true;
        $scope.initPredicate();
    };

    $scope.addPredicate = function() {

        $rootScope.newPredicateFakeId = $rootScope.newPredicateFakeId - 1;

        $scope.newConstraint.position_1 = $scope.genPosition($scope.newConstraint.component_1, $scope.newConstraint.subComponent_1);
        $scope.newConstraint.position_2 = $scope.genPosition($scope.newConstraint.component_2, $scope.newConstraint.subComponent_2);
        $scope.newConstraint.location_1 = $scope.genLocation($scope.newConstraint.datatype, $scope.newConstraint.component_1, $scope.newConstraint.subComponent_1);
        $scope.newConstraint.location_2 = $scope.genLocation($scope.newConstraint.datatype, $scope.newConstraint.component_2, $scope.newConstraint.subComponent_2);

        if ($scope.newConstraint.position_1 != null) {
            var cp = $rootScope.generatePredicate($scope.selectedNode.position + '[1]', $scope.newConstraint);
            $scope.tempPredicates.push(cp);
            $scope.changed = true;
        }
        $scope.initPredicate();
    };

    $scope.ok = function() {
        $modalInstance.close($scope.selectedNode);
    };

    $scope.saveclose = function() {
        angular.copy($scope.tempPredicates, $rootScope.datatype.predicates);
        $rootScope.recordChanged();
        $modalInstance.close($scope.selectedNode);
    };
});

angular.module('igl').controller('AddComponentCtrl', function($scope, $modalInstance, datatypes, datatype, valueSets, $rootScope, $http, ngTreetableParams, SegmentService, DatatypeLibrarySvc, MessageService, blockUI) {

    $scope.valueSets = valueSets;
    $scope.datatypes = datatypes;


    $scope.newComponent = {
        comment: "",
        confLength: "",
        datatype: {
            ext: null,
            id: "",
            label: "",
            name: "",
        },
        hide: false,
        id: "",
        maxLength: "",
        minLength: "",
        name: "",
        position: "",
        table: {
            bindingIdentifier: "",
            bindingLocation: null,
            bindingStrength: null,
            id: ""
        },
        text: "",
        type: "component",
        usage: ""


    };

    $scope.$watch('DT', function() {
        if ($scope.DT) {
            $scope.newComponent.datatype.ext = $scope.DT.ext;
            $scope.newComponent.datatype.id = $scope.DT.id;
            $scope.newComponent.datatype.name = $scope.DT.name;
            $scope.newComponent.datatype.label = $scope.DT.label;


        }
        console.log($scope.DT);

    }, true);

    $scope.$watch('VS', function() {
        if ($scope.VS) {
            $scope.newComponent.table.bindingIdentifier = $scope.VS.bindingIdentifier;
            $scope.newComponent.table.id = $scope.VS.id;


        }

    }, true);


    $scope.selectDT = function(datatype) {
        $scope.DT = datatype;
    };
    $scope.selectedDT = function() {
        return ($scope.DT !== undefined);
    };
    $scope.unselectDT = function() {
        $scope.DT = undefined;
    };
    $scope.isDTActive = function(id) {
        if ($scope.DT) {
            return $scope.DT.id === id;
        } else {
            return false;
        }

    };
    $scope.selectUsage = function(usage) {
        console.log(usage);
        if (usage === 'X' || usage === 'W') {
            $scope.newComponent.max = 0;
            $scope.newComponent.min = 0;
            $scope.disableMin = true;
            $scope.disableMax = true;

        } else if (usage === 'R') {
            $scope.newComponent.min = 1;

            $scope.disableMin = true;
            $scope.disableMax = false;
        } else if (usage === 'RE' || usage === 'O') {
            $scope.newComponent.min = 0;

            $scope.disableMin = true;
            $scope.disableMax = false;

        } else {
            $scope.disableMin = false;
            $scope.disableMax = false;

        }

    };


    $scope.selectVS = function(valueSet) {
        $scope.VS = valueSet;
    };
    $scope.selectedVS = function() {
        return ($scope.VS !== undefined);
    };
    $scope.unselectVS = function() {
        $scope.VS = undefined;
    };
    $scope.isVSActive = function(id) {
        if ($scope.VS) {
            return $scope.VS.id === id;
        } else {
            return false;
        }

    };


    $scope.addComponent = function() {
        blockUI.start();
        if ($rootScope.datatype.components.length !== 0) {
            $scope.newComponent.position = $rootScope.datatype.components[$rootScope.datatype.components.length - 1].position + 1;

        } else {
            $scope.newComponent.position = 1;
        }

        $scope.newComponent.id = new ObjectId().toString();

        if ($rootScope.datatype != null) {
            if (!$rootScope.datatype.components || $rootScope.datatype.components === null)
                $rootScope.datatype.components = [];
            $rootScope.datatype.components.push($scope.newComponent);
            MessageService.updatePosition(datatype.components, $scope.newComponent.position - 1, $scope.position - 1);





        }
        blockUI.stop();
        $modalInstance.close();

    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


});

angular.module('igl').controller('DeleteComponentCtrl', function($scope, $modalInstance, componentToDelete, datatype, $rootScope, SegmentService, blockUI) {
    $scope.componentToDelete = componentToDelete;
    $scope.loading = false;
    console.log(datatype);
    console.log($scope.componentToDelete);
    $scope.updatePosition = function(node) {
        angular.forEach(node.components, function(component) {
            component.position = node.components.indexOf(component) + 1;

        })

    };
    $scope.delete = function() {
        blockUI.start();
        $scope.loading = true;
        datatype.components.splice(componentToDelete.position - 1, 1);


        $rootScope.msg().text = "ComponentDeleteSuccess";

        $rootScope.msg().type = "success";
        $rootScope.msg().show = true;
        $rootScope.manualHandle = true;
        $scope.loading = false;
        $scope.updatePosition(datatype);
        $modalInstance.close($scope.componentToDelete);
        blockUI.stop();

    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };

});

angular.module('igl').controller('EditVSCtrlForLib', function($scope, $modalInstance, valueSets, component, $rootScope, SegmentService, blockUI) {

    $scope.vsChanged = false;
    $scope.component = component;
    $scope.vs = angular.copy(component.tables);
    $scope.tableList = angular.copy(component.tables);;
    $scope.loadVS = function($query) {


        return valueSets;
        
//        filter(function(table) {
//            return table.bindingIdentifier.toLowerCase().indexOf($query.toLowerCase()) != -1;
//        });

    };
    $scope.tagAdded = function(tag) {
        $scope.vsChanged = true;
        $scope.tableList.push({
            id: tag.id,
            bindingIdentifier: tag.bindingIdentifier,
            bindingLocation: null,
            bindingStrength: null
        });


        //$scope.log.push('Added: ' + tag.text);
    };

    $scope.tagRemoved = function(tag) {
        $scope.vsChanged = true;

        for (var i = 0; i < $scope.tableList.length; i++) {
            if ($scope.tableList[i].id === tag.id) {
                $scope.tableList.splice(i, 1);
            }
        };


    };

    $scope.addVS = function() {
        blockUI.start();

        $scope.vsChanged = false;
        component.tables = $scope.tableList;

        blockUI.stop();

        $modalInstance.close();


    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


});



angular
  .module('igl')
  .controller(
      'MastermapCtl',
          function ($scope, $rootScope, MastermapSvc) {
            var ctl = this;

            $scope.mastermap = function(){
              return MastermapSvc.getMastermap();
            }

            $rootScope.$on('event:loadMastermap', function (event, igdocument) {
              MastermapSvc.parseIg(igdocument);
            });


  }
);

angular
    .module('igl')
    .controller(
    'ToCCtl',
    [
        '$scope',
        '$rootScope',
        '$timeout',
        'ToCSvc',
        'ContextMenuSvc',
        'CloneDeleteSvc',
        'FilteringSvc',
        'MastermapSvc',
        function ($scope, $rootScope, $timeout, ToCSvc, ContextMenuSvc, CloneDeleteSvc, FilteringSvc, MastermapSvc) {
            var ctl = this;
            $scope.collapsed = [];
            $scope.yesDrop = false;
            $scope.noDrop = true;
//							$scope.$watch('tocData', function(newValue,
//									oldValue) {
//								if (!oldValue && newValue) {
//									_.each($scope.tocData, function(head) {
//										$scope.collapsed[head] = false;
//									});
//								}
//							});

            $scope.moved = function (index, leaf) {
                var idx = _.findLastIndex($scope.$parent.drop, function (leaf1) {
                    return leaf.id === leaf1.id;
                });

                if (index === idx) {
                    $scope.$parent.drop.splice(index + 1, 1);
                } else {
                    $scope.$parent.drop.splice(index, 1);
                }
                $timeout(function () {
                    var pos = 0;
                    _.each($scope.$parent.drop, function (child) {
                        pos++;
                        var igdMsg = _.find($rootScope.igdocument.profile.messages.children, function (msg) {
                            return msg.id === child.reference.id;
                        })
                        igdMsg.position = pos;
                    });
                }, 100);
            };

            $scope.calcOffset = function (level) {
                return "margin-left : " + level + "em";
            };

            $scope.trackBy = function () {
                return new ObjectId().toString();
            };

            $scope.tocSelection = function (entry) {
                // TODO gcr: See about refactoring this to
                // eliminate the switch.
                // One could use entry.reference.type to assemble
                // the $emit string.
                // Doing so would require maintaining a sync
                // with the ProfileListController.

                entry.highlight = true;
                ToCSvc.currentLeaf.highlight = false;
                ToCSvc.currentLeaf = entry;
//								console.log("entry=" + entry.reference.sectionTitle);
                switch (entry.type) {
                    case "documentMetadata":
                    {
                        $scope.$emit('event:openDocumentMetadata',
                            entry.reference);
                        break;
                    }
                    case "profileMetadata":
                    {
                        $scope.$emit('event:openProfileMetadata',
                            entry.reference);
                        break;
                    }
                    case "message":
                    {
                        $scope.$emit('event:openMessage',
                            entry.reference);
                        break;
                    }
                    case "segment":
                    {
                        $scope.$emit('event:openSegment',
                            entry.reference);
                        break;
                    }
                    case "datatype":
                    {
                        $scope.$emit('event:openDatatype',
                            entry.reference);
                        break;
                    }
                    case "table":
                    {
                        $scope.$emit('event:openTable',
                            entry.reference);
                        break;
                    }
                    default:
                    {
                        $scope.$emit('event:openSection',
                            entry.reference, entry);
                        break;
                    }
                }
                return $scope.subview;
            };

            $scope.closedCtxSubMenu = function (node, $index) {
                var ctxMenuSelection = ContextMenuSvc.get();
//								console.log("ctxMenuSelection=" + ctxMenuSelection);
                switch (ctxMenuSelection) {
                    case "Add":
                        console.log("Add==> node=" + node);
                        break;
                    case "Copy":
                        console.log("Copy==> node=" + node + " node.reference.type=" + node.reference.type);
                        if (node.reference.type === 'section') {
                            CloneDeleteSvc.copySection(node);
                        } else if (node.reference.type === 'segment') {
                            CloneDeleteSvc.copySegment(node.reference);
                        } else if (node.reference.type === 'datatype') {
                            CloneDeleteSvc.copyDatatype(node.reference);
                        } else if (node.reference.type === 'table') {
                            CloneDeleteSvc.copyTable(node.reference);
                        } else if (node.reference.type === 'message') {
                            CloneDeleteSvc.copyMessage(node.reference);
                        }
                        break;
                    case "Delete":
                        console.log("Copy==> node=" + node);
                        if (node.reference.type === 'section') {
                            CloneDeleteSvc.deleteSection(node);
                        } else if (node.reference.type === 'segment') {
                            CloneDeleteSvc.deleteSegment(node.reference);
                        } else if (node.reference.type === 'datatype') {
                            CloneDeleteSvc.deleteDatatype(node.reference);
                        } else if (node.reference.type === 'table') {
                            CloneDeleteSvc.deleteValueSet(node.reference);
                        } else if (node.reference.type === 'message') {
                            CloneDeleteSvc.deleteMessage(node.reference);
                        }
                        break;
                    case "Export":
                        if (node.reference.type === 'message') {
                            console.log("Export==> node=" + node);
                            console.log("IG document ID  : " + $rootScope.igdocument.id);
                            console.log("Selected Message ID  : " + node.reference.id);
                            CloneDeleteSvc.exportDisplayXML(node.reference.id);
                        }
                        break;
                    default:
                        console
                            .log("Context menu defaulted with "
                                + ctxMenuSelection
                                + " Should be Add, Copy, or Delete.");
                }
                $rootScope.$broadcast('event:SetToC');
            };

            $scope.show = function (leaf) {
                return FilteringSvc.showToC(leaf);
            };

        }])

angular
    .module('igl')
    .controller(
    'TreeCtrl', ['$scope',
        '$rootScope',
        '$http',
        'SectionSvc',
        'CloneDeleteSvc',
        'FilteringSvc',
        '$cookies',
        'DatatypeLibrarySvc',
        '$modal',
        'CompositeMessageService',
        'PcService',

        function ($scope, $rootScope, $http, SectionSvc, CloneDeleteSvc, FilteringSvc, $cookies,DatatypeLibrarySvc,$modal,CompositeMessageService,PcService) {

            $scope.collapsedata = false;
            $scope.collapsePcs = true;
            $scope.collapseprofilecomponent = false;
            $scope.collapsemessage = false;
            $scope.collapsesegment = false;
            $scope.collapsetable = false;
            $scope.collapsevalueSet = false;
            $scope.profilecollapsed = false;
            $scope.openMetadata = false;
            $scope.ordredMessages = [];
            $scope.dataTypeLibraryCollapsed = false;
            $rootScope.activeModel = "";
            $scope.segmentsChecked = false;
            $rootScope.filteringMode = false;
            $rootScope.loadingSegments = false;
            $rootScope.loadingDataTypes = false;
            $rootScope.loadingTables = false;
            $scope.Activate = function (param) {
                $rootScope.activeModel = param;
            }
            $scope.getDeleteLabl = function () {
                // if($rootScope.references.length===0){
                return "Delete"
                // }else return "Show References"
            };

            $scope.exportCSVForTable = function (table) {
                console.log(table);

                var form = document.createElement("form");

                form.action = $rootScope.api('api/tables/exportCSV/' + table.id);
                form.method = "POST";
                form.target = "_target";
                var csrfInput = document.createElement("input");
                csrfInput.name = "X-XSRF-TOKEN";
                csrfInput.value = $cookies['XSRF-TOKEN'];
                form.appendChild(csrfInput);
                form.style.display = 'none';
                document.body.appendChild(form);
                form.submit();
            };

            $rootScope.switcherDatatypeLibrary = function () {

                $scope.dataTypeLibraryCollapsed = !$scope.dataTypeLibraryCollapsed;

            };
            $rootScope.openMetadata = function () {

                $scope.openMetadata = !$scope.openMetadata;

            };

            $rootScope.switcherprofile = function () {
                $scope.profilecollapsed = !$scope.profilecollapsed;

            };
            $rootScope.switcherpcs = function () {
                $scope.collapsePcs = !$scope.collapsePcs;
            }


            $rootScope.updateSectionContent = function (section) {
                if (section.childSections) {
                    section.childSections = section.childSections;
                }

            };
            $rootScope.switchervalueSet = function () {
                $scope.collapsevalueSet = !$scope.collapsevalueSet;
            };
            $rootScope.switchertable = function () {
                $scope.collapsetable = !$scope.collapsetable;

            };

            $rootScope.switcherseg = function () {
                $scope.collapsesegment = !$scope.collapsesegment;

            };
            
            $rootScope.switchermsg = function () {
                $scope.collapsemessage = !$scope.collapsemessage;
            };
            $rootScope.switcherpc = function() {
                $scope.collapseprofilecomponent = !$scope.collapseprofilecomponent;
            };

            $rootScope.switcherdata = function () {
                $scope.collapsedata = !$scope.collapsedata;

            };
            $scope.DatattypeTreeOption = {
                accept: function (sourceNodeScope, destNodesScope, destIndex) {
                    var dataTypeSource = sourceNodeScope.$element
                        .attr('data-type');
                    var dataTypeDest = destNodesScope.$element
                        .attr('data-type');

                    return true;


                },


                dropped: function (event) {

                    var sourceNode = event.source.nodeScope;
                    var destNodes = event.dest.nodesScope;
                    var sortBefore = event.source.index;
                    var sortAfter = event.dest.index;
                    var source = sourceNode.$parentNodeScope.$modelValue;
                    var dest = destNodes.$parent.$modelValue;
                    var dataTypeDest = destNodes.$element.attr('data-type');
                    var dataTypeSource = sourceNode.$element.attr('data-type');
                    event.source.nodeScope.$modelValue.sectionPosition = sortAfter + 1;

                    var parentSource = sourceNode.$parentNodeScope.$modelValue;
                    var parentDest = event.dest.nodesScope.$nodeScope.$modelValue;


                }
            };


            $scope.treeOptions = {

                accept: function (sourceNodeScope, destNodesScope, destIndex) {
                    var dataTypeSource = sourceNodeScope.$element
                        .attr('data-type');
                    var dataTypeDest = destNodesScope.$element
                        .attr('data-type');


                    if (!dataTypeDest) {

                        return false;
                    } else if (dataTypeSource === "sections" && dataTypeDest === "sections") {

                        return true;


                    } else if (dataTypeDest === dataTypeSource + "s") {
                        return true;

                    } else
                        return false;
                },


                dragStart: function (event) {
                    if ($rootScope.hasChanges()) {

                        $rootScope.openConfirmLeaveDlg().result.then(function () {

                        });
                    }

                },


                dropped: function (event) {

                    var sourceNode = event.source.nodeScope;
                    var destNodes = event.dest.nodesScope;
                    var sortBefore = event.source.index;
                    var sortAfter = event.dest.index;
                    var source = sourceNode.$parentNodeScope.$modelValue;
                    var dest = destNodes.$parent.$modelValue;
                    var dataTypeDest = destNodes.$element.attr('data-type');
                    var dataTypeSource = sourceNode.$element.attr('data-type');
                    // event.source.nodeScope.$modelValue.sectionPosition =
                    // sortAfter + 1;

                    var parentSource = sourceNode.$parentNodeScope.$modelValue;
                    var parentDest = event.dest.nodesScope.$nodeScope.$modelValue;
                    if (dataTypeDest === "messages") {
                        console.log("========ordering messages");
                        $scope.updateMessagePositions($rootScope.igdocument.profile.messages.children);
                        $scope.reOrderMessages();
                        return "";
                    } else if (parentSource.type === "document" && parentDest.type === "section") {
                        console.log("putting root into child");
                        $scope.updatePositions($rootScope.igdocument.childSections);
                        $scope.updatePositions(parentDest.childSections);
                        $scope.updateChildeSections($rootScope.igdocument.childSections);
                        return "";
                    } else if (parentSource.type === "document" && parentDest.type === "document") {
                        console.log("========updating childSection of ig");
                        $scope.updatePositions($rootScope.igdocument.childSections);
                        $scope.reOrderChildSections();
                        return "";

                    } else if (parentSource.type === "section" && parentDest.type === "document") {
                        console.log($rootScope.igdocument.childSections);
                        $scope.updatePositions($rootScope.igdocument.childSections);
                        $scope.updatePositions(parentSource.childSections);
                        $scope.updateChildeSections($rootScope.igdocument.childSections);

                        return "";

                    } else if (dataTypeDest && dataTypeDest === "sections" && dataTypeSource === "sections") {

                        if (parentDest.id === parentSource.id) {
                            $scope.updatePositions(parentSource.childSections);
                            console.log("=========ordering the same section");
                            console.log(parentSource);
                            SectionSvc.update($rootScope.igdocument.id, parentSource).then(function () {
                                return "";
                            });
                        } else {
                            console.log(" ordering 2 sections ");
                            $scope.updatePositions(parentSource.childSections);
                            $scope.updatePositions(parentDest.childSections);
                            SectionSvc.update($rootScope.igdocument.id, parentSource).then(function () {
                                SectionSvc.update($rootScope.igdocument.id, parentDest).then(function () {
                                    return "";
                                });
                            });

                        }

                    }
                }

            };

            $scope.updatePositions = function (arr) {
                if (arr !== undefined) {
                    for (var i = 0; i <= arr.length - 1; i++) {
                        arr[i].sectionPosition = i + 1;

                    }
                }
                return "";
            };


            $scope.updateMessagePositions = function (arr) {


                if (arr !== undefined && arr != null) {
                    for (var i = 0; i <= arr.length - 1; i++) {
                        if (arr[i] != null) // wierd but happened
                            arr[i].position = i + 1;
                    }
                }
                return "";
            };


            $scope.getLastPosition = function (arr) {
                var position = arr.length;
                for (var i = arr.length - 1; i >= 0; i--) {
                    var position = arr.length;

                    if (arr[i].sectionPosition && arr[i].sectionPosition >= position) {
                        return arr[i].sectionPosition + 1;
                    } else return position;
                }

            };

            $scope.getLastcloneIndex = function (arr, name) {
                var index = 0;
                var cutIndex = name.length - 1;
                for (var i = arr.length - 1; i >= 0; i--) {
                    if (arr[i].sectionTitle.substring(0, cutIndex) === name && arr[i].sectionTitle.length > cutIndex + 1) {
                        index = parseInt(arr[i].sectionTitle.substring(cutIndex + 1)) + 1;

                        return index;
                    } else return 1;
                }

            };


            $scope.getLabel = function ($itemScope) {
                if ($itemScope.$parentNodeScope) {
                    var p = $scope.getLabel($itemScope.$parentNodeScope);
                    if (p === "")
                        return $itemScope.$modelValue.sectionPosition;
                    else
                        return p + "." + $itemScope.$modelValue.sectionPosition;
                } else {
                    return "";
                }
            };


            $scope.cloneSectionTree = function (section) {
                var clone = {};
                if (section.childSections === undefined) {
                    clone.id = new ObjectId().toString();
                    clone.type = section.type;
                    clone.sectionContents = section.sectionContents;
                    clone.sectionDescription = section.sectionDescription;
                    clone.sectionTitle = section.sectionTitle + Math.floor((Math.random() * 50000) + 1);
                    console.log(clone);
                    return clone;
                } else {
                    clone.type = section.type;
                    clone.childSections = [];
                    clone.sectionTitle = section.sectionTitle + Math.floor((Math.random() * 50000) + 1);

                    clone.id = new ObjectId().toString();
                    clone.sectionContents = section.sectionContents;
                    clone.sectionDescription = section.sectionDescription;
                    for (var i = 0; i <= section.childSections.length - 1; i++) {
                        var child = $scope.cloneSectionTree(section.childSections[i]);
                        child.sectionTitle = section.childSections[i].sectionTitle;
                        child.sectionPosition = section.childSections[i].sectionPosition;
                        clone.childSections.push(child);
                    }
                    return clone;
                }
            };

            $scope.cloneSection = function (section) {

                var clone = angular.copy(section);
                clone.id = new ObjectId().toString();
                clone.childSections = [];
                clone.sectionTitle = section.sectionTitle + Math.floor((Math.random() * 50000) + 1);
                if (section.childSections && section.childSections.length > 0) {
                    angular.forEach(section.childSections, function (sect) {
                        clone.childSections.push($scope.cloneInside(sect));

                    });
                }
                return clone;


            };

            $scope.cloneInside = function (sectionInside) {
                var clone = angular.copy(sectionInside);
                clone.id = new ObjectId().toString();
                clone.childSections = [];
                if (sectionInside.childSections && sectionInside.childSections.length > 0) {

                    angular.forEach(sectionInside.childSections, function (sect) {
                        clone.childSections.push($scope.cloneInside(sect));

                    });

                }
                return clone;
            }


            $scope.debug = function (childSections) {
                console.log("DEBUG FNCT");
                console.log(childSections);
            }

            $scope.recharge = false;

            $scope.sectionOption = [

                ['Add Section',
                    function ($itemScope) {
                        var newSection = {};
                        newSection.type = "section";
                        newSection.id = new ObjectId().toString();
                        newSection.childSections = [];
                        newSection.sectionContents = "";
                        newSection.sectionDescription = "";
                        newSection.sectionTitle = "new Section" + Math.floor((Math.random() * 50000) + 1);


                        if (!$itemScope.section.childSections.length) {
                            newSection.sectionPosition = 1;
                            $itemScope.section.childSections = [];
                            $itemScope.section.childSections.push(newSection);

                        } else {
                            $itemScope.section.childSections.push(newSection);
                            newSection.sectionPosition = $itemScope.section.childSections.length;
                        }
                        console.log($itemScope.section);
                        SectionSvc.update($rootScope.igdocument.id, $itemScope.section);
                        $scope.editSection(newSection);
                        $rootScope.activeModel = newSection.id;


                    }
                ],
                null,


                ['Copy',
                    function ($itemScope) {

                        function process() {
                            var cloneModel = $scope.cloneSection($itemScope.$nodeScope.$modelValue);
                            cloneModel.sectionPosition = $scope.getLastPosition($itemScope.$nodeScope.$parentNodesScope.$modelValue);
                            $itemScope.$nodeScope.$parentNodesScope.$modelValue.push(cloneModel);
                            $scope.editSection(cloneModel);
                            if ($itemScope.$nodeScope.$parentNodeScope.$modelValue.type === "document") {
                                $scope.updateChildeSections($rootScope.igdocument.childSections);
                            } else if ($itemScope.$nodeScope.$parentNodeScope.$modelValue.type === "section") {
                                SectionSvc.update($rootScope.igdocument.id, $itemScope.$nodeScope.$parentNodeScope.$modelValue);

                            }
                        };

                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                process();
                            });
                        } else {
                            process();
                        }


                    }
                ],
                null, [
                    'Delete',
                    function ($itemScope) {

                        var section = $itemScope.section;
                        var index = $itemScope.$nodeScope.$parentNodesScope.$modelValue.indexOf($itemScope.$nodeScope.$modelValue);
                        if (index > -1) {
                            $itemScope.$nodeScope.$parentNodesScope.$modelValue
                                .splice(index, 1);
                        }
                        $scope.updatePositions($itemScope.$nodeScope.$parentNodesScope.$modelValue);


                        SectionSvc.delete($rootScope.igdocument.id, $itemScope.section.id).then(function () {


                            if ($itemScope.section.id === $rootScope.activeModel) {
                                $scope.displayNullView();
                            }
                            if ($itemScope.$nodeScope.$parentNodeScope.$modelValue.type === 'section') {
                                SectionSvc.update($rootScope.igdocument.id, $itemScope.$nodeScope.$parentNodeScope.$modelValue);
                            } else if ($itemScope.$nodeScope.$parentNodeScope.$modelValue.type === 'document') {
                                $scope.updateChildeSections($rootScope.igdocument.childSections);


                            }
                        });





                    }
                ]

            ];

            function processAddSection() {
                var newSection = {};
                newSection.id = new ObjectId().toString();
                newSection.childSections = [];

                var rand = Math.floor(Math.random() * 100);
                if (!$rootScope.igdocument.profile.metaData.ext) {
                    $rootScope.igdocument.profile.metaData.ext = "";
                }
                newSection.sectionTitle = "New Section" + "-" +
                    $rootScope.igdocument.profile.metaData.ext + "-" +
                    rand;
                newSection.label = newSection.sectionTitle;
                $rootScope.igdocument.childSections.push(newSection);

                newSection.sectionPosition = $rootScope.igdocument.childSections.length;
                $scope.updateChildeSections($rootScope.igdocument.childSections);
                $scope.Activate(newSection.id);
            };

            $scope.igOptions = [

                ['Add Section',
                    function ($itemScope) {


                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                processAddSection();
                            });
                        } else {
                            processAddSection();
                        }


                    }
                ]

            ];


            $scope.SegmentOptions = [

                ['Create Flavor',
                    function ($itemScope) {


                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                CloneDeleteSvc.copySegment($itemScope.segment);
                            });
                        } else {
                            console.log($itemScope.segment);
                            CloneDeleteSvc.copySegment($itemScope.segment);
                        }

                    }
                ],
                null, [$scope.getDeleteLabl(),
                function ($itemScope) {
                    CloneDeleteSvc.deleteSegment($itemScope.segment);
                }
                ]

            ];

            $scope.DataTypeOptions = [

                ['Create Flavor',
                    function ($itemScope) {


                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                CloneDeleteSvc.copyDatatype($itemScope.data);
                            });
                        } else {
                            CloneDeleteSvc.copyDatatype($itemScope.data);
                        }
                    }
                ],
                null, ['Delete',
                    function ($itemScope) {
                        CloneDeleteSvc.deleteDatatype($itemScope.data);

                    }
                ]
            ];



            $scope.DataTypeOptionsForPublished = [
                ['Create New Version',
                    function ($itemScope) {
                        console.log($rootScope.versionAndUseMap[$itemScope.data.id]);
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                if ($rootScope.readyForNewVersion($itemScope.data)) {
                                    CloneDeleteSvc.upgradeDatatype($itemScope.data);
                                } else {
                                    $scope.showCannotPublish($itemScope.data);
                                }

                            });
                        } else {

                            if ($rootScope.readyForNewVersion($rootScope.versionAndUseMap[$itemScope.data.id])) {
                                CloneDeleteSvc.upgradeDatatype($itemScope.data);
                            } else {

                                $scope.showCannotPublish($itemScope.data);
                            }
                        }
                    }
                ],
                ['Create Flavor',
                    function ($itemScope) {


                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                CloneDeleteSvc.copyDatatype($itemScope.data);
                            });
                        } else {
                            CloneDeleteSvc.copyDatatype($itemScope.data);
                        }
                    }
                ],
                ['Delete',
                    function ($itemScope) {
                        CloneDeleteSvc.deleteDatatype($itemScope.data);

                    }
                ]
            ];


            $scope.TableOptionsForPublished = [
                                                  ['Create New Version',
                                                      function ($itemScope) {
                                                          console.log($rootScope.versionAndUseMap[$itemScope.table.id]);
                                                          if ($rootScope.hasChanges()) {

                                                              $rootScope.openConfirmLeaveDlg().result.then(function () {
                                                                  if ($rootScope.readyForNewVersion($rootScope.versionAndUseMap[$itemScope.table.id])) {
                                                                      CloneDeleteSvc.upgradeTable($itemScope.table);
                                                                  } else {
                                                                      $scope.showCannotPublish($itemScope.table);
                                                                  }

                                                              });
                                                          } else {

                                                              if ($rootScope.readyForNewVersion($rootScope.versionAndUseMap[$itemScope.table.id])) {
                                                                  CloneDeleteSvc.upgradeTable($itemScope.table);
                                                              } else {

                                                                  $scope.showCannotPublish($itemScope.table);
                                                              }
                                                          }
                                                      }
                                                  ],

                                                  ['Export CSV',
                                                         function ($itemScope) {
                                                             $scope.exportCSVForTable($itemScope.table);

                                                         }
                                                     ],


                                                  ['Create Flavor',
                                                      function ($itemScope) {


                                                          if ($rootScope.hasChanges()) {

                                                              $rootScope.openConfirmLeaveDlg().result.then(function () {
                                                                  CloneDeleteSvc.copyTable($itemScope.table);
                                                              });
                                                          } else {
                                                              CloneDeleteSvc.copyTable($itemScope.table);
                                                          }
                                                      }
                                                  ],
                                                  ['Delete',
                                                      function ($itemScope) {
                                                	  CloneDeleteSvc.deleteValueSet($itemScope.table);

                                                      }
                                                  ]
                                              ];





            $rootScope.readyForNewVersion = function (element) {
                var ready = true;
                var obj=$rootScope.versionAndUseMap[element.id];
                if (obj.derived && obj.derived.length > 0) {
                    angular.forEach(obj.derived, function (derived) {

                        console.log(derived);
                        console.log($rootScope.datatypesMap[derived]);
                        if(element.type==='datatype'){
                        if ($rootScope.datatypesMap[derived].status !== "PUBLISHED") {
                            console.log("here");
                            ready = false;
                        }}
                        else{
                        	if(element.type==='table'){
                                if ($rootScope.tablesMap[derived].status !== "PUBLISHED") {
                                    console.log("here");
                                    ready = false;
                                }
                        	}
                        }
                    });
                }
                return ready;
            };

            $scope.ValueSetOptions = [

                ['Create Flavor',
                    function ($itemScope) {
                        if ($rootScope.hasChanges()) {
                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                CloneDeleteSvc.copyTable($itemScope.table);
                            });
                        } else {
                            CloneDeleteSvc.copyTable($itemScope.table);
                        }
                    }
                ],
                null, ['Export CSV',
                    function ($itemScope) {
                        $scope.exportCSVForTable($itemScope.table);

                    }
                ],
                null, ['Delete',
                    function ($itemScope) {
                        CloneDeleteSvc.deleteValueSet($itemScope.table);

                    }
                ]

            ];

            $scope.ValueSetOptionsINLIB = [

                ['Create Flavor',
                    function ($itemScope) {
                        if ($rootScope.hasChanges()) {
                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                console.log($scope.tableLibrary);
                                console.log("table in lib");
                                CloneDeleteSvc.copyTableINLIB($itemScope.table, $rootScope.tableLibrary);
                            });
                        } else {
                            console.log("table in lib");
                            CloneDeleteSvc.copyTableINLIB($itemScope.table, $rootScope.tableLibrary);
                        }
                    }
                ],
                null, ['Delete',
                    function ($itemScope) {
                        CloneDeleteSvc.deleteValueSet($itemScope.table);

                    }
                ]

            ];


            $scope.MessagesOption = [

                [
                    'Copy',
                    function ($itemScope) {

                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                CloneDeleteSvc.copyMessage($itemScope.msg);
                            });
                        } else {
                            CloneDeleteSvc.copyMessage($itemScope.msg);
                        }
                    }
                ],
                null, [
                    'Delete',
                    function ($itemScope) {
                        CloneDeleteSvc.deleteMessage($itemScope.msg);
                    }
                ]
            ];


            $scope.MessagesRootOption = [

                ['Add Profile', function ($itemScope) {
                    if ($rootScope.hasChanges()) {

                        $rootScope.openConfirmLeaveDlg().result.then(function () {
                            $scope.hl7Versions('ctx');
                        });
                    } else {
                        $scope.hl7Versions('ctx');
                    }

                }],
                null, ['Export Profile', function ($itemScope) {


                    if ($rootScope.hasChanges()) {

                        $rootScope.openConfirmLeaveDlg().result.then(function () {
                            $scope.selectMessages($rootScope.igdocument);
                        });
                    } else {
                        $scope.selectMessages($rootScope.igdocument);
                    }



                }]
            ];

            $scope.ProfileComponentsRootOption = [

                                                  ['Create Profile Component', function($itemScope) {
                                                      if ($rootScope.hasChanges()) {

                                                          $rootScope.openConfirmLeaveDlg().result.then(function() {
                                                              $scope.createProfileComponent();
                                                          });
                                                      } else {
                                                          $scope.createProfileComponent();
                                                      }

                                                  }]
                                              ];
                                              $scope.CompositeMessagesRootOption = [
                                                  ['Create Composite Profile', function($itemScope) {
                                                      if ($rootScope.hasChanges()) {

                                                          $rootScope.openConfirmLeaveDlg().result.then(function() {
                                                              $scope.createCompositeMessage();
                                                          });
                                                      } else {
                                                          $scope.createCompositeMessage();
                                                      }

                                                  }]
                                              ];

                                              $scope.ProfileComponentsOption = [

                                                  ['Delete', function($itemScope) {

                                                      PcService.getPc($itemScope.pc.id).then(function(profileComponent) {
                                                          console.log(profileComponent);
                                                          if (profileComponent.appliedTo === null || (profileComponent.appliedTo && profileComponent.appliedTo.length === 0)) {
                                                              if ($rootScope.hasChanges()) {
                                                                  $rootScope.openConfirmLeaveDlg().result.then(function() {
                                                                      $rootScope.deleteProfileComponent($rootScope.igdocument.profile.profileComponentLibrary.id, profileComponent);
                                                                  });
                                                              } else {
                                                                  $rootScope.deleteProfileComponent($rootScope.igdocument.profile.profileComponentLibrary.id, profileComponent);
                                                              }
                                                          } else {
                                                              //can't delete because it's used
                                                              console.log("notHEEEEEEEREEEE");
                                                              $rootScope.cantDeletePc(profileComponent);

                                                          }

                                                      });



                                                  }]
                                              ];


            $scope.ValueSetRootOptions = [
                ['Add Value Sets', function ($itemScope) {
                    if ($rootScope.hasChanges()) {

                        $rootScope.openConfirmLeaveDlg().result.then(function () {
                            $scope.addTable($rootScope.igdocument);
                        });
                    } else {
                        $scope.addTable($rootScope.igdocument);

                    }


                }]
            ];

            $scope.DataTypeOptionsInLib = [
                ['Copy',
                    function ($itemScope) {

                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                $scope.copyDatatype($itemScope.data);
                            });
                        } else {
                            $scope.copyDatatype($itemScope.data);

                        }
                    }
                ],
                null, ['Delete',
                    function ($itemScope) {
                        console.log("delete=" + $itemScope);
                        console.log($itemScope.data);
                        $scope.deleteDatatype($itemScope.data);
                    }
                ]
            ];

            $scope.addSegment = [
                ['Add HL7 Segment',
                    function ($itemScope) {

                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {

                                $scope.addSegments($rootScope.igdocument.profile.metaData.hl7Version);
                            });
                        } else {

                            $scope.addSegments($rootScope.igdocument.profile.metaData.hl7Version);
                        }

                    }
                ]
            ];

            $scope.addDatatype = [
                ['Add HL7 Data Type',
                    function ($itemScope) {

                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                $scope.addDatatypes($rootScope.igdocument.profile.metaData.hl7Version);

                            });
                        } else {
                            $scope.addDatatypes($rootScope.igdocument.profile.metaData.hl7Version);
                        }
                    }
                ],
                ['Add USER Datatypes',
                    function ($itemScope) {
                        console.log("adding datatype");
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {

                                     $rootScope.addDatatypesFromUserLib("2.1");



                            });

                        } else {

                                     $rootScope.addDatatypesFromUserLib("2.1");

                        }
                    }
                ],
                ['Add Master Datatypes',
                    function ($itemScope) {
                        console.log("adding datatype");
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {

                                    $rootScope.addDatatypeFromMasterLib("2.1");



                            });

                        } else {

                                     $rootScope.addDatatypeFromMasterLib("2.1");

                        }
                    }
                ],
                ['Add Shared Datatypes',
                    function ($itemScope) {
                        console.log("adding datatype");
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {

                                    $rootScope.addSharedDatatypes();



                            });

                        } else {

                                     $rootScope.addSharedDatatypes();

                        }
                    }
                ]
            ];

            $scope.MasterDataTypeLibraryOptions = [
                [' Add Datatypes',
                    function ($itemScope) {
                        console.log("adding datatype");
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                    $scope.addMasterDt();



                            });

                        } else {
                                    $scope.addMasterDt();

                        }
                    }
                ]
            ];

            $scope.UserDataTypeLibraryOptions = [
                ['Add HL7 Datatypes',
                    function ($itemScope) {
                        console.log("adding datatype");
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {

                                     $scope.addDatatypeForUser("2.1");



                            });

                        } else {

                                     $scope.addDatatypeForUser("2.1");

                        }
                    }
                ],
                ['Add USER Datatypes',
                    function ($itemScope) {
                        console.log("adding datatype");
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {

                                     $rootScope.addDatatypesFromUserLib("2.1");



                            });

                        } else {

                                     $rootScope.addDatatypesFromUserLib("2.1");

                        }
                    }
                ],
                ['Add Master Datatypes',
                    function ($itemScope) {
                        console.log("adding datatype");
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {

                                    $rootScope.addDatatypeFromMasterLib("2.1");



                            });

                        } else {

                                     $rootScope.addDatatypeFromMasterLib("2.1");

                        }
                    }
                ],['Add Shared Datatypes',
                    function ($itemScope) {
                        console.log("adding datatype");
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {

                                    $rootScope.addSharedDatatypes();



                            });

                        } else {

                                     $rootScope.addSharedDatatypes();

                        }
                    }
                ]








            ];


            $scope.addValueSets = [


                ['Add New Value Set',
                    function ($itemScope) {
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                CloneDeleteSvc.createNewTable('USER', $rootScope.igdocument.profile.tableLibrary);

                            });
                        } else {

                            CloneDeleteSvc.createNewTable('USER', $rootScope.igdocument.profile.tableLibrary);

                        }

                    }
                ],
                ['Add HL7 Value Sets',

                    function ($itemScope) {
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                $rootScope.addHL7Table($rootScope.igdocument.profile.tableLibrary, $rootScope.igdocument.metaData.hl7Version);

                            });
                        } else {

                            $rootScope.addHL7Table($rootScope.igdocument.profile.tableLibrary, $rootScope.igdocument.metaData.hl7Version);

                        }

                    }
                ],

                ['Add from PHINVADs',
                    function ($itemScope) {
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                $rootScope.addPHINVADSTables($rootScope.igdocument.profile.tableLibrary);

                            });
                        } else {

                            $rootScope.addPHINVADSTables($rootScope.igdocument.profile.tableLibrary);

                        }
                    }
                ],

                ['Add from CSV file',
                    function ($itemScope) {
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                $rootScope.addCSVTables($rootScope.igdocument.profile.tableLibrary);

                            });
                        } else {

                            $rootScope.addCSVTables($rootScope.igdocument.profile.tableLibrary);

                        }

                    }
                ]

            ];


            $scope.addValueSetsInTableLibrary = [

                ['Import New Value Set',
                    function ($itemScope) {
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                CloneDeleteSvc.createNewTable($rootScope.tableLibrary.scope, $scope.tableLibrary);
                                $scope.editTableINLIB($rootScope.table);
                            });
                        } else {

                            CloneDeleteSvc.createNewTable($rootScope.tableLibrary.scope, $scope.tableLibrary);
                            $scope.editTableINLIB($rootScope.table);
                        }

                    }
                ],
                ['Import HL7 Value Sets',

                    function ($itemScope) {
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                $rootScope.addHL7Table($rootScope.tableLibrary, "2.1");
                            });
                        } else {

                            $rootScope.addHL7Table($rootScope.tableLibrary, "2.1");
                        }



                    }
                ],

                ['Import from PHINVADs',
                    function ($itemScope) {


                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                $rootScope.addPHINVADSTables($rootScope.tableLibrary);
                            });
                        } else {

                            $rootScope.addPHINVADSTables($rootScope.tableLibrary);
                        }
                    }
                ],

                ['Import CSV file',
                    function ($itemScope) {
                        if ($rootScope.hasChanges()) {

                            $rootScope.openConfirmLeaveDlg().result.then(function () {
                                $rootScope.addCSVTables($$rootScope.tableLibrary);
                            });
                        } else {

                            $rootScope.addCSVTables($rootScope.tableLibrary);
                        }
                    }
                ]

            ];

            function processEditSeg(seg) {
                $scope.Activate(seg.id);
                // $rootScope.activeSegment = seg;
                $scope.$emit('event:openSegment', seg);
            };

            $rootScope.editSeg = function (seg) {

                if ($rootScope.hasChanges()) {

                    $rootScope.openConfirmLeaveDlg().result.then(function () {

                        processEditSeg(seg);
                    });
                } else {
                    processEditSeg(seg);
                }


            };

            function processEditIg(ig) {
                $scope.Activate(ig.id);
                $rootScope.igdocument = ig;
                $scope.$emit('event:openDocumentMetadata',
                    $rootScope.igdocument);
            };


            $scope.editIg = function (ig) {

                if ($rootScope.hasChanges()) {

                    $rootScope.openConfirmLeaveDlg().result.then(function () {
                        processEditIg(ig);
                    });
                } else {
                    processEditIg(ig);
                }


            };

            function processEditSection(section) {
                $scope.Activate(section.id);
                $rootScope.section = section;
                $scope.$emit('event:openSection', $rootScope.section);
            };


            $scope.editSection = function (section) {
                if (section.sectionContents === null) {
                    section.sectionContents = "";
                }
                if ($rootScope.hasChanges()) {

                    $rootScope.openConfirmLeaveDlg().result.then(function () {
                        processEditSection(section);
                    });
                } else {
                    processEditSection(section);
                }

            }

            function processEditRoutSection(param) {

                $scope.Activate(param.id);
                $rootScope.section = $scope.getRoutSectionByname(param);
                // $rootScope.currentData=section;

                if ($rootScope.section.sectionContents === null) {
                    $rootScope.section.sectionContents = "";
                }
                $scope.$emit('event:openSection', $rootScope.section);
            };

            $scope.editRoutSection = function (param) {
                if ($rootScope.hasChanges()) {

                    $rootScope.openConfirmLeaveDlg().result.then(function () {
                        processEditRoutSection(param);
                    });
                } else {
                    processEditRoutSection(param);
                }
            };

            $scope.getRoutSectionByname = function (name) {
                $rootScope.currentData = {};
                $scope.Activate(name);
                if (name.toLowerCase() === 'conformance profiles') {
                    $rootScope.currentData = $rootScope.igdocument.profile.messages;

                } else if (name.toLowerCase() === 'segments and field descriptions') {
                    $rootScope.currentData = $rootScope.igdocument.profile.segmentLibrary;

                } else if (name.toLowerCase() === 'value sets') {
                    $rootScope.currentData = $rootScope.igdocument.profile.tableLibrary;
                } else if (name.toLowerCase() === 'datatypes') {
                    $rootScope.currentData = $rootScope.igdocument.profile.datatypeLibrary;
                }
                if ($rootScope.currentData.sectionContents === null || $rootScope.currentData.sectionContents === undefined) {
                    $rootScope.currentData.sectionContents = "";
                }
                return $rootScope.currentData;
            };

            function processEditDataType(data) {

                console.log("dialog not opened");
                $scope.Activate(data.id);
                $rootScope.datatype = data;
                $scope.$emit('event:openDatatype', $rootScope.datatype);
            };

            $rootScope.editDatatype = function(data) {
            	console.log(data);
              // Find share participants
              if (data.shareParticipantIds && data.shareParticipantIds.length > 0) {
            	  
            	  console.log(data.shareParticipantIds);
            	  var listOfIds= _.map(data.shareParticipantIds, function(element){ 
            		  if(element.id){
            		  return element.id;}
            		  else if(element.accountId){
            			 return element.accountId;
            		  }
            	  
            	  
            	  
            	  });
            	  console.log(listOfIds);
                      $http.get('api/shareparticipants', { params: { ids: listOfIds} })
                          .then(
                          function (response) {
                        	  data.shareParticipantIds=angular.fromJson(response.data);
                              //Proceed with next
                          editDatatypeNext(data);
                          },
                          function (error) {
                              console.log(error);
                          }
                          );
                  
              } else {
              editDatatypeNext(data);
              }

            };

            function editDatatypeNext(data) {
              if ($rootScope.hasChanges()) {
                console.log("found changes");

                $rootScope.openConfirmLeaveDlg().result.then(function() {
                  console.log("dialog opened");
                  processEditDataType(data);
                });
              } else {
                processEditDataType(data);
              }
            };

            function processEditTable(table) {
                $scope.Activate(table.id);
                $rootScope.table = table;
                $scope.$emit('event:openTable', $rootScope.table);
            };

            $rootScope.editTable = function (table) {
                if ($rootScope.hasChanges()) {
                    $rootScope.openConfirmLeaveDlg().result.then(function () {
                        processEditTable(table);
                    });
                } else {
                    processEditTable(table);
                }
            };


            function processEditTableInLib(table) {
                $scope.Activate(table.id);
                $rootScope.table = table;
                $scope.$emit('event:openTable', $rootScope.table);
            };

            $scope.editTableINLIB = function (table) {
                if ($rootScope.hasChanges()) {
                    $rootScope.openConfirmLeaveDlg().result.then(function () {
                        processEditTableInLib(table);
                    });
                } else {
                    processEditTableInLib(table);
                }
            };



            function processEditMessage(message) {
                $scope.Activate(message.id);
                $rootScope.message = message;
                console.log("three");
                console.log(message);
                $scope.$emit('event:openMessage', message);
            };


            $scope.editMessage = function (message) {

                if ($rootScope.hasChanges()) {
                    $rootScope.openConfirmLeaveDlg().result.then(function () {
                        processEditMessage(message);
                    });
                } else {
                    processEditMessage(message);
                }

            };
            
            function processEditPC(pc) {
                console.log("================================");
                console.log(pc);
                PcService.getPc(pc.id).then(function(profileC) {
                    console.log("HEEEERE");
                    console.log(profileC);
                    $scope.Activate(pc.id);
                    $rootScope.profileComponent = profileC;
                    $scope.$emit('event:openPc');
                });

            };
            function processEditCM(cm) {
                console.log("================================");
                console.log(cm);
                CompositeMessageService.getCm(cm.id).then(function(compositeM) {
                    console.log("HEEEERE");
                    console.log(compositeM);
                    $scope.Activate(cm.id);
                    $rootScope.compositeMessage = compositeM;
                    $scope.$emit('event:openCm');
                });

            };
            $rootScope.editPC = function(pc) {

                if ($rootScope.hasChanges()) {
                    $rootScope.openConfirmLeaveDlg().result.then(function() {
                        processEditPC(pc);
                    });
                } else {
                    processEditPC(pc);
                }

            };
            $rootScope.editCM = function(cm) {

                if ($rootScope.hasChanges()) {
                    $rootScope.openConfirmLeaveDlg().result.then(function() {
                        processEditCM(cm);
                    });
                } else {
                    processEditCM(cm);
                }

            };
            

            function processEditProfile() {
                $scope.Activate("Message Infrastructure");
                $scope.$emit('event:openProfileMetadata',
                    $rootScope.igdocument);
            };

            $scope.editProfile = function () {

                if ($rootScope.hasChanges()) {

                    $rootScope.openConfirmLeaveDlg().result.then(function () {
                        processEditProfile();
                    });
                } else {
                    processEditProfile();
                }

            };

            $scope.updateChildeSections = function (childSections) {

                var id = $rootScope.igdocument.id;
                var req = {
                    method: 'POST',
                    url: "api/igdocuments/" + id + "/updateChildSections",
                    headers: {
                        'Content-Type': "application/json"
                    },
                    data: childSections
                }

                var promise = $http(req)
                    .success(function (data, status, headers, config) {
                        // //console.log(data);
                        return data;
                    })
                    .error(function (data, status, headers, config) {
                        if (status === 404) {
                            console.log("Could not reach the server");
                        } else if (status === 403) {
                            console.log("limited access");
                        }
                    });
                return promise;
            }

            $scope.reOrderChildSections = function () {
                var childSections = $rootScope.igdocument.childSections;
                var sections = [];
                for (var i = 0; i <= childSections.length - 1; i++) {
                    var sectionMap = {};
                    sectionMap.id = childSections[i].id;
                    sectionMap.sectionPosition = childSections[i].sectionPosition;
                    sections.push(sectionMap);
                }
                var id = $rootScope.igdocument.id;
                var req = {
                    method: 'POST',
                    url: "api/igdocuments/" + id + "/reorderChildSections",
                    headers: {
                        'Content-Type': "application/json"
                    },
                    data: sections
                }

                var childSections = $rootScope.igdocument.childSections;
                var sections = [];
                for (var i = 0; i <= childSections.length - 1; i++) {
                    var sectionMap = {};
                    sectionMap.id = childSections[i].id;
                    sectionMap.sectionPosition = childSections[i].sectionPosition;
                    sections.push(sectionMap);
                }
                var id = $rootScope.igdocument.id;
                var req = {
                    method: 'POST',
                    url: "api/igdocuments/" + id + "/reorderChildSections",
                    headers: {
                        'Content-Type': "application/json"
                    },
                    data: sections
                }


                var promise = $http(req)
                    .success(function (data, status, headers, config) {

                        return data;
                    })
                    .error(function (data, status, headers, config) {
                        if (status === 404) {
                            console.log("Could not reach the server");
                        } else if (status === 403) {
                            console.log("limited access");
                        }
                    });
                return promise;
            };

            $scope.reOrderMessages = function () {
                var messagesMap = [];

                var messages = $rootScope.igdocument.profile.messages.children;
                for (var i = 0; i <= messages.length - 1; i++) {
                    var messageMap = {};
                    messageMap.id = messages[i].id;
                    messageMap.position = messages[i].position;
                    messagesMap.push(messageMap);
                }
                console.log(messagesMap);
                var id = $rootScope.igdocument.id;
                var req = {
                    method: 'POST',
                    url: "api/igdocuments/" + id + "/reorderMessages",
                    headers: {
                        'Content-Type': "application/json"
                    },
                    data: messagesMap
                }
                var promise = $http(req)
                    .success(function (data, status, headers, config) {

                        return data;
                    })
                    .error(function (data, status, headers, config) {
                        if (status === 404) {
                            console.log("Could not reach the server");
                        } else if (status === 403) {
                            console.log("limited access");
                        }
                    });
                return promise;
            };

            $scope.showUnused = function (node) {
                if (node.id === null) {
                    return true;
                }
                return FilteringSvc.isUnused(node);
            };

            $scope.showToC = function (leaf) {
                return leaf.id === null || FilteringSvc.isUnused(leaf) || FilteringSvc.showToC(leaf);
            };

            $scope.getScopeLabel = function (leaf) {
                if (leaf) {


                    if (leaf.scope === 'HL7STANDARD') {
                        return 'HL7';
                    } else if (leaf.scope === 'USER') {
                        return 'USR';

                    } else if (leaf.scope === 'MASTER') {
                        return 'MAS';
                    } else if (leaf.scope === 'PRELOADED') {
                        return 'PRL';
                    } else if (leaf.scope === 'PHINVADS') {
                        return 'PVS';
                    } else {
                        return "";

                    }
                }
            };
            $rootScope.addCSVTables = function (selectedTableLibary) {
                var modalInstance = $modal.open({
                    templateUrl: 'AddCSVTableOpenCtrl.html',
                    controller: 'AddCSVTableOpenCtrl',
                    windowClass: 'conformance-profiles-modal',
                    resolve: {
                        selectedTableLibary: function () {
                            return selectedTableLibary;
                        }
                    }
                });
                modalInstance.result.then(function () { }, function () { });
            };

            $rootScope.addPHINVADSTables = function (selectedTableLibary) {
                var modalInstance = $modal.open({
                    templateUrl: 'AddPHINVADSTableOpenCtrl.html',
                    controller: 'AddPHINVADSTableOpenCtrl',
                    windowClass: 'conformance-profiles-modal',
                    resolve: {
                        selectedTableLibary: function () {
                            return selectedTableLibary;
                        }
                    }
                });
                modalInstance.result.then(function () { }, function () { });
            };

            $rootScope.getLabelOfData = function (name, ext) {

                var label = "";


                if (ext && ext !== null && ext !== "") {
                    label = name + "_" + ext;

                } else {
                    label = name;
                }
                return label;
            };

        $scope.getDatatypeLabel = function(datatype) {
            if (datatype && datatype != null) {
                // var ext = $rootScope.getDatatypeExtension(datatype);
                return $rootScope.getLabel(datatype.name, datatype.ext);
            }
            return "";
        };


            $scope.getSegmentsFromgroup = function (group) {
                // _.union($rootScope.selectedSegments,temp);
                for (var i = 0; i < group.children.length; i++) {
                    if (group.children[i].type === "segmentRef") {
                        console.log("IN IF ");
                        var segment = $rootScope.segmentsMap[group.children[i].ref.id];
                        var temp2 = [];
                        temp2.push(segment);
                        $rootScope.FilteredSegments.push(segment);
                        // $rootScope.FilteredSegments=_.union($rootScope.FilteredSegments,temp2);


                    } else if (group.children[i].type === "group") {
                        console.log("group case ");
                        $scope.getSegmentsFromgroup(group.children[i]);
                    }
                }

            }


            $scope.getDatatypeFromDatatype = function (datatype) {
                var data = [];
                if (datatype.components.length === 0) {
                    $scope.getTablesFromDatatype(datatype);
                    return 0;
                } else {

                    for (var i = 0; i < datatype.components.length; i++) {
                        var temp = [];
                        temp.push($rootScope.datatypesMap[datatype.components[i].datatype.id]);
                        $scope.getTablesFromDatatype($rootScope.datatypesMap[datatype.components[i].datatype.id]);
                        data = _.union(data, temp);
                    }
                }
                return data;
            }

            $scope.FilterbyConformance = function (msg) {

                $rootScope.FilteredSegments = [];
                $rootScope.filteredDatatypes = [];
                $rootScope.filterdTables = [];
                for (var i = msg.children.length - 1; i >= 0; i--) {


                    if (msg.children[i].type === "segmentRef") {
                        var seg = $rootScope.segmentsMap[msg.children[i].ref.id];
                        console.log(seg);
                        $rootScope.FilteredSegments.push(seg);
                        var temp = [];
                        temp.push(seg);
                        $rootScope.filteredDatatype = _.union($rootScope.selectedDataTypes, $scope.getDatataypeFromSegment(segment));
                        $scope.getTablesFromSegment(segment);

                    } else if (msg.children[i].type === "group") {
                        $scope.getSegmentsFromgroup(msg.children[i]);
                    }
                }


            }

            $scope.getDatataypeFromSegment = function (seg) {
                var data = [];
                for (var i = 0; i < seg.fields.length; i++) {
                    console.log(seg.fields[i].datatype.id);
                    var datatype = $rootScope.datatypesMap[seg.fields[i].datatype.id];
                    console.log(datatype);
                    $scope.getTablesFromDatatype(datatype);
                    var temp = [];
                    temp.push(datatype);
                    temp = _.union(temp, $scope.getDatatypeFromDatatype(datatype));
                    data = _.union(data, temp);
                }
                return data;
            }

            $scope.getTablesFromSegment = function (seg) {
                var tables = [];
                for (var i = 0; i < seg.fields.length; i++) {
                    if (seg.fields[i].table != null) {
                        var table = $rootScope.tablesMap[seg.fields[i].table.id];
                        // console.log(datatype);
                        var temp = [];
                        temp.push(table);
                        tables = _.union(tables, temp);
                        $rootScope.filtererTables = _.union($rootScope.selectedTables, tables);
                    }
                }

            }
            $scope.resetSegments = function () {
                $rootScope.selectedSegment = null;
                console.log("called");
                $rootScope.filteredDatatypesList = angular.copy($rootScope.datatypes);
                $rootScope.filteredTablesList = angular.copy($rootScope.tables);
                if ($rootScope.selectedMessage != null) {
                    $rootScope.processMessageTree($rootScope.selectedMessage, null);
                }
                $rootScope.filteredSegmentsList.forEach(function (segment, i) {
                    segment.checked = false;
                });
            }

            $scope.resetLibFilter = function () {
                console.log("called");
                $rootScope.filteringModeON = false;

                $scope.datatypes.forEach(function (data, i) {

                    data.checked = false;
                });
                $scope.loadTables().then(function () { });
            };

            $scope.resetDatatypes = function () {
                console.log("called");
                if ($rootScope.selectedSegment != null) {
                    $rootScope.processSegmentsTree($rootScope.selectedSegment, null);
                } else if ($rootScope.selectedMessage != null) {
                    $rootScope.processMessageTree($rootScope.selectedMessage, null);
                }
                $rootScope.filteredDatatypesList.forEach(function (data, i) {
                    data.checked = false;
                });
            }


            $scope.resetMessages = function () {
                $rootScope.selectedMessage = null;
                $rootScope.filteredDatatypesList = angular.copy($rootScope.datatypes);
                $rootScope.filteredSegmentsList = angular.copy($rootScope.segments);
                $rootScope.filteredTablesList = angular.copy($rootScope.tables);

                $rootScope.igdocument.profile.messages.children.forEach(function (msg, i) {
                    msg.checked = false;
                });
            }

            $scope.showCannotPublish=function(datatype){

        	$scope.unpublishedChild=[];
        	angular.forEach($rootScope.versionAndUseMap[datatype.id].derived, function(derived){
        		if($rootScope.datatypesMap[derived].status=="UNPUBLISHED"){
        			$scope.unpublishedChild.push($rootScope.datatypesMap[derived]);

        		}

        	});
        	 var addDatatypeInstance = $modal.open({
                 templateUrl: 'cannotPublish.html',
                 controller: 'cannotPublish',
                 size: 'lg',
                 windowClass: 'conformance-profiles-modal',
                 resolve: {

                     datatype: function() {

                         return datatype;
                     },
                    derived: function() {


                         return $scope.unpublishedChild;
                     }

                 }
             }).result.then(function(results) {

             });
        };
            $rootScope.addDatatypesFromUserLib=function(){
                var scopes = ['HL7STANDARD'];


                    DatatypeLibrarySvc.getDataTypeLibraryByScope('USER').then(function(userDtLib) {
                    	var dtlibs=[];
                    	angular.forEach(userDtLib, function(dtLib){
                    		if(dtLib.id!==$rootScope.datatypeLibrary.id){
                    			dtlibs.push(dtLib);
                    		}
                    	});
                    	console.log(dtlibs);
                        console.log("userDtLib");
                        console.log(userDtLib);

                        console.log("addDatatype scopes=" + scopes.length);
                        var addDatatypeInstance = $modal.open({
                            templateUrl: 'AddUserDatatype.html',
                            controller: 'AddDatatypeCtrlFromUserLib',
                            size: 'lg',
                            windowClass: 'addDatatype',
                            resolve: {
                                hl7Version: function() {
                                    return $scope.hl7Version;
                                },
                                userDtLib: function() {
                                    return dtlibs;
                                },
                                datatypeLibrary: function(){
                                	return $rootScope.datatypeLibrary;
                                },
                                tableLibrary :function(){
                                	return $rootScope.tableLibrary;
                                },
                                versionAndUseMap:function(){
                                	return $rootScope.versionAndUseMap;
                                }
                            }
                        }).result.then(function(results) {
                            var ids = [];
                            angular.forEach(results, function(result) {
                                ids.push(result.id);
                            });
                        });

            });

            }

                    $rootScope.addSharedDatatypes=function(){
                    var scopes = ['HL7STANDARD'];


                        var addDatatypeInstance = $modal.open({
                            templateUrl: 'AddSharedDatatype.html',
                            controller: 'AddSharedDatatype',
                            size: 'lg',
                            windowClass: 'addDatatype',
                            resolve: {
                                hl7Version: function() {
                                    return $scope.hl7Version;
                                },

                                datatypeLibrary: function(){
                                	return $rootScope.datatypeLibrary;
                                },
                                tableLibrary :function(){
                                	return $rootScope.tableLibrary;
                                },
                                versionAndUseMap:function(){
                                	return $rootScope.versionAndUseMap;
                                }
                            }
                        }).result.then(function(results) {


            });

            }

            $rootScope.addDatatypeFromMasterLib=function(){

                   DatatypeLibrarySvc.getDataTypeLibraryByScope('MASTER').then(function(masterLib) {
                    	var dtlibs=[];
                    	angular.forEach(masterLib, function(dtLib){
                    		if(dtLib.id!==$rootScope.datatypeLibrary.id){
                    			dtlibs.push(dtLib);
                    		}
                    	});

                        var addDatatypeInstance = $modal.open({
                            templateUrl: 'AddMasterDatatypeIntoUser.html',
                            controller: 'addMAsterInLibrary',
                            size: 'lg',
                            windowClass: 'addDatatype',
                            resolve: {
                                hl7Version: function() {
                                    return $scope.hl7Version;
                                },
                                masterLib: function() {
                                    return dtlibs;
                                },
                                datatypeLibrary: function(){
                                	return $rootScope.datatypeLibrary;
                                },
                                tableLibrary :function(){
                                	return $rootScope.tableLibrary;
                                },
                                versionAndUseMap:function(){
                                	return $rootScope.versionAndUseMap;
                                }
                            }
                        }).result.then(function(results) {
                            var ids = [];
                            angular.forEach(results, function(result) {
                                ids.push(result.id);
                            });
                        });

            });

            }
        }
    ]);

    angular.module('igl').controller('AddDatatypeCtrlFromUserLib',
	    function($scope, $rootScope, $modalInstance, hl7Version, userDtLib, DatatypeLibrarySvc, DatatypeService, TableLibrarySvc, TableService, $http,datatypeLibrary,tableLibrary,versionAndUseMap) {
			$scope.versionAndUseMap=versionAndUseMap;
	        $scope.newDts = [];
	        $scope.checkedExt = true;
	        $scope.NocheckedExt = true;
	        $scope.userDtLib = userDtLib;
	        $scope.selectedDatatypes = [];
	        $scope.selectUserDtLib = function(usrLib) {
	            console.log(usrLib);
	            DatatypeLibrarySvc.getDatatypesByLibrary(usrLib.id).then(function(datatypes) {

	                $scope.userDatatypes = datatypes;

	                console.log($scope.userDatatypes);
	            });
	        };
	        var listHL7Versions = function() {
	            return $http.get('api/igdocuments/findVersions', {
	                timeout: 60000
	            }).then(function(response) {
	                var hl7Versions = [];
	                var length = response.data.length;
	                for (var i = 0; i < length; i++) {
	                    hl7Versions.push(response.data[i]);
	                }
	                console.log(hl7Versions);
	                return hl7Versions;
	            });
	        };

	        var init = function() {
	            listHL7Versions().then(function(versions) {
	            	$scope.hl7Datatypes=[];
	                $scope.version1 = "";
	                $scope.versions = versions;
	                var scopes = ['HL7STANDARD'];
	            });

	        };
	        init();
	        $scope.setVersion = function(version) {
	            $scope.version1 = version;
	            var scopes = ['HL7STANDARD'];
	            DatatypeService.getDataTypesByScopesAndVersion(scopes, version).then(function(result) {
	                console.log("result");
	                console.log(result);

	                $scope.hl7Datatypes = result;

	            });
	        }
	        $scope.addDt = function(datatype) {
	            console.log(datatype);
	            $scope.selectedDatatypes.push(datatype);
	            console.log("chowing map");

	            console.log($rootScope.versionAndUseMap[datatype.id]);
	        };
	        $scope.checkExist = function(datatype) {

	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                if ($scope.selectedDatatypes[i].id === datatype.id) {
	                    return true;
	                }
	            }
	            for (var i = 0; i < $rootScope.datatypes.length; i++) {
	                if ($rootScope.datatypes[i].id === datatype.id) {
	                    return true;
	                }
	            }
	            return false;
	        }
	        $scope.checkExt = function(datatype) {
	            $scope.checkedExt = true;
	            $scope.NocheckedExt = true;
	            if (datatype.ext === "") {
	                $scope.NocheckedExt = false;
	                return $scope.NocheckedExt;
	            }
	            for (var i = 0; i < $rootScope.datatypes.length; i++) {
	                if ($rootScope.datatypes[i].name === datatype.name && $rootScope.datatypes[i].ext === datatype.ext) {
	                    $scope.checkedExt = false;
	                    return $scope.checkedExt;
	                }
	            }
	            console.log($scope.selectedDatatypes.indexOf(datatype));
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                if ($scope.selectedDatatypes.indexOf(datatype) !== i) {
	                    if ($scope.selectedDatatypes[i].name === datatype.name && $scope.selectedDatatypes[i].ext === datatype.ext) {
	                        $scope.checkedExt = false;
	                        return $scope.checkedExt;
	                    }
	                }

	            }

	            return $scope.checkedExt;
	        };
	        $scope.addDtFlv = function(datatype) {
	                $scope.newDatatype = angular.copy(datatype);

	            	$scope.newDatatype.ext=Math.floor(Math.random() * 1000);

                	console.log($scope.newDatatype.ext);
       	            $scope.newDatatype.scope =datatypeLibrary.scope;
                  	$scope.newDatatype.status="UNPUBLISHED";

       	            $scope.newDatatype.participants = [];
       	            $scope.newDatatype.id = new ObjectId().toString();
       	            $scope.newDatatype.libIds = [];
    	            $scope.selectedDatatypes.push($scope.newDatatype);
    	            console.log($scope.selectedDatatypes)
	            console.log($scope.newDatatype.ext);
	            $scope.newDatatype.scope =datatypeLibrary.scope;
           	 	$scope.newDatatype.status="UNPUBLISHED";
	            $scope.newDatatype.participants = [];
	            $scope.newDatatype.id = new ObjectId().toString();;
	            $scope.newDatatype.libIds = [];
	            if ($scope.newDatatype.components != undefined && $scope.newDatatype.components != null && $scope.newDatatype.components.length != 0) {
	                for (var i = 0; i < $scope.newDatatype.components.length; i++) {
	                    $scope.newDatatype.components[i].id = new ObjectId().toString();
	                }
	            }

	            var predicates = $scope.newDatatype['predicates'];
	            if (predicates != undefined && predicates != null && predicates.length != 0) {
	                angular.forEach(predicates, function(predicate) {
	                    predicate.id = new ObjectId().toString();
	                });
	            }

	            var conformanceStatements = $scope.newDatatype['conformanceStatements'];
	            if (conformanceStatements != undefined && conformanceStatements != null && conformanceStatements.length != 0) {
	                angular.forEach(conformanceStatements, function(conformanceStatement) {
	                    conformanceStatement.id = new ObjectId().toString();
	                });
	            }
	          //  $scope.selectedDatatypes.push($scope.newDatatype);
	            console.log($scope.selectedDatatypes)
	        }
	        $scope.deleteDt = function(datatype) {
	            var index = $scope.selectedDatatypes.indexOf(datatype);
	            if (index > -1) $scope.selectedDatatypes.splice(index, 1);
	        };
	        var secretEmptyKey = '[$empty$]';

	        $scope.dtComparator = function(datatype, viewValue) {
	            if (datatype) {
	                console.log(datatype.name);
	                console.log(datatype);
	            }
	            return viewValue === secretEmptyKey || (datatype && ('' + datatype.name).toLowerCase().indexOf(('' + viewValue).toLowerCase()) > -1);
	        };


	        $scope.isInDts = function(datatype) {

	            if ($scope.hl7Datatypes.indexOf(datatype) === -1) {
	                return false;
	            } else {
	                return true;
	            }

	        }


	        $scope.selectDT = function(datatype) {
	            console.log(datatype);
	            $scope.newDatatype = datatype;
	        };
	        $scope.selected = function() {
	            return ($scope.newDatatype !== undefined);
	        };
	        $scope.unselect = function() {
	            $scope.newDatatype = undefined;
	        };
	        $scope.isActive = function(id) {
	            if ($scope.newDatatype) {
	                return $scope.newDatatype.id === id;
	            } else {
	                return false;
	            }
	        };

	        $scope.ok = function() {
	            console.log($scope.selectedDatatypes);
	            $scope.selectFlv = [];
	            var newLinks = [];
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                if ($scope.selectedDatatypes[i].scope === datatypeLibrary.scope) {
	                    $scope.selectFlv.push($scope.selectedDatatypes[i]);
	                } else {
	                    newLinks.push({
	                        id: $scope.selectedDatatypes[i].id,
	                        name: $scope.selectedDatatypes[i].name
	                    })
	                }
	            }
	            $rootScope.usedDtLink = [];
	            $rootScope.usedVsLink = [];
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                $rootScope.fillMaps($scope.selectedDatatypes[i]);
	            }
	            DatatypeService.saves($scope.selectFlv).then(function(result) {
	                for (var i = 0; i < result.length; i++) {
	                    newLinks.push({
	                        id: result[i].id,
	                        name: result[i].name,
	                        ext: result[i].ext
	                    })
	                }
	                DatatypeLibrarySvc.addChildren(datatypeLibrary.id, newLinks).then(function(link) {
	                    for (var i = 0; i < newLinks.length; i++) {
	                        datatypeLibrary.children.splice(0, 0, newLinks[i]);
	                    }
	                    for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                        $rootScope.datatypes.splice(0, 0, $scope.selectedDatatypes[i]);
	                    }
	                    for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                        $rootScope.datatypesMap[$scope.selectedDatatypes[i].id] = $scope.selectedDatatypes[i];
	                    }
	                    var usedDtId1 = _.map($rootScope.usedDtLink, function(num, key) {
	                        return num.id;
	                    });

	                    DatatypeService.get(usedDtId1).then(function(datatypes) {
	                        for (var j = 0; j < datatypes.length; j++) {
	                            if (!$rootScope.datatypesMap[datatypes[j].id]) {

	                                $rootScope.datatypesMap[datatypes[j].id] = datatypes[j];
	                                $rootScope.datatypes.push(datatypes[j]);
	                               // $rootScope.getDerived(datatypes[j]);
	                            }
	                        }

	                        var usedVsId = _.map($rootScope.usedVsLink, function(num, key) {
	                            return num.id;
	                        });
	                        console.log("$rootScope.usedVsLink");

	                        console.log($rootScope.usedVsLink);
	                        var newTablesLink = _.difference($rootScope.usedVsLink,tableLibrary.children);
	                        console.log(newTablesLink);

	                        TableLibrarySvc.addChildren(tableLibrary.id, newTablesLink).then(function() {
	                          tableLibrary.children = _.union(newTablesLink, tableLibrary.children);

	                            TableService.get(usedVsId).then(function(tables) {
	                                for (var j = 0; j < tables.length; j++) {
	                                    if (!$rootScope.tablesMap[tables[j].id]) {
	                                        $rootScope.tablesMap[tables[j].id] = tables[j];
	                                        $rootScope.tables.push(tables[j]);

	                                    }
	                                }


                                $modalInstance.close(datatypes);

	                            });
	                        });
	                    });
	                    $rootScope.msg().text = "datatypeAdded";
	                    $rootScope.msg().type = "success";
	                    $rootScope.msg().show = true;

	                });

	            }, function(error) {
	                $rootScope.saving = false;
	                $rootScope.msg().text = error.data.text;
	                $rootScope.msg().type = error.data.type;
	                $rootScope.msg().show = true;
	            });


	        };

	        $scope.cancel = function() {
	            $modalInstance.dismiss('cancel');
	        };
	    });


    angular.module('igl').controller('addMAsterInLibrary',
    function($scope, $rootScope, $modalInstance, hl7Version, masterLib,DatatypeLibrarySvc, DatatypeService, TableLibrarySvc, TableService, $http,datatypeLibrary,tableLibrary,versionAndUseMap) {
			$scope.versionAndUseMap=versionAndUseMap;
	        $scope.newDts = [];
	        $scope.checkedExt = true;
	        $scope.NocheckedExt = true;
	        $scope.masterLib = [];
	        $scope.masterLib = masterLib;
	        $scope.selectedDatatypes = [];
	        $scope.selectMasterDtLib = function(masLib) {
	            console.log(masLib);
	            DatatypeLibrarySvc.getDatatypesByLibrary(masLib.id).then(function(datatypes) {
	            	console.log(datatypes);

	                $scope.masterDatatypes = _.where(datatypes, {scope:"MASTER",status:"PUBLISHED"}) ;
	                console.log($scope.masterDatatypes);
	            });
	        };

	        var listHL7Versions = function() {
	            return $http.get('api/igdocuments/findVersions', {
	                timeout: 60000
	            }).then(function(response) {
	                var hl7Versions = [];
	                var length = response.data.length;
	                for (var i = 0; i < length; i++) {
	                    hl7Versions.push(response.data[i]);
	                }
	                console.log(hl7Versions);
	                return hl7Versions;
	            });
	        };

	        var init = function() {
	            listHL7Versions().then(function(versions) {
	            	$scope.hl7Datatypes=[];
	                $scope.version1 = "";
	                $scope.versions = versions;
	                var scopes = ['HL7STANDARD'];
	            });

	        };
	        init();
	        $scope.setVersion = function(version) {
	            $scope.version1 = version;
	            var scopes = ['HL7STANDARD'];
	            DatatypeService.getDataTypesByScopesAndVersion(scopes, version).then(function(result) {
	                console.log("result");
	                console.log(result);
	                $scope.hl7Datatypes = result;
	            });
	        }
	        $scope.addDt = function(datatype) {
	            console.log(datatype);
	            $scope.selectedDatatypes.push(datatype);
	            console.log("chowing map");

	            console.log($rootScope.versionAndUseMap[datatype.id]);
	        };
	        $scope.checkExist = function(datatype) {

	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                if ($scope.selectedDatatypes[i].id === datatype.id) {
	                    return true;
	                }
	            }
	            for (var i = 0; i < $rootScope.datatypes.length; i++) {
	                if ($rootScope.datatypes[i].id === datatype.id) {
	                    return true;
	                }
	            }
	            return false;
	        }
	        $scope.checkExt = function(datatype) {
	            $scope.checkedExt = true;
	            $scope.NocheckedExt = true;
	            if (datatype.ext === "") {
	                $scope.NocheckedExt = false;
	                return $scope.NocheckedExt;
	            }
	            for (var i = 0; i < $rootScope.datatypes.length; i++) {
	                if ($rootScope.datatypes[i].name === datatype.name && $rootScope.datatypes[i].ext === datatype.ext) {
	                    $scope.checkedExt = false;
	                    return $scope.checkedExt;
	                }
	            }
	            console.log($scope.selectedDatatypes.indexOf(datatype));
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                if ($scope.selectedDatatypes.indexOf(datatype) !== i) {
	                    if ($scope.selectedDatatypes[i].name === datatype.name && $scope.selectedDatatypes[i].ext === datatype.ext) {
	                        $scope.checkedExt = false;
	                        return $scope.checkedExt;
	                    }
	                }

	            }

	            return $scope.checkedExt;
	        };
	        $scope.addDtFlv = function(datatype) {
	                $scope.newDatatype = angular.copy(datatype);
	        	    if($rootScope.igdocument){

                console.log("merging");
                //newDatatype.hl7versions=[$rootScope.igdocument.profile.metaData.hl7Version];
                var temp = [];
                temp.push($rootScope.igdocument.profile.metaData.hl7Version);
                $scope.newDatatype.hl7versions = temp;
                $scope.newDatatype.hl7Version = $rootScope.igdocument.profile.metaData.hl7Version;
                DatatypeService.getOneStandard(datatype.name, $scope.newDatatype.hl7Version, $scope.newDatatype.hl7versions).then(function (standard) {
                    $rootScope.mergeEmptyProperty($scope.newDatatype, standard);
                    console.log("MERGING");
                });
                 }

                 if($rootScope.libraryDoc){
                     console.log("HERRRRE");
                var temp = [];
                temp.push(datatype.hl7Version);
                $scope.newDatatype.hl7versions = temp;
                $scope.newDatatype.hl7Version = datatype.hl7Version;
                DatatypeService.getOneStandard(datatype.name, datatype.hl7Version, datatype.hl7versions).then(function (standard) {
                    $rootScope.mergeEmptyProperty($scope.newDatatype, standard);
                    console.log("MERGING");
                        });

                 }


	            	$scope.newDatatype.ext=Math.floor(Math.random() * 1000);

                	console.log($scope.newDatatype.ext);
       	            $scope.newDatatype.scope =datatypeLibrary.scope;
                  	$scope.newDatatype.status="UNPUBLISHED";

       	            $scope.newDatatype.participants = [];
       	            $scope.newDatatype.id = new ObjectId().toString();
       	            $scope.newDatatype.libIds = [];
    	            $scope.selectedDatatypes.push($scope.newDatatype);
    	            console.log($scope.selectedDatatypes)
	                console.log($scope.newDatatype.ext);
	                $scope.newDatatype.scope =datatypeLibrary.scope;
           	    	$scope.newDatatype.status="UNPUBLISHED";
	                $scope.newDatatype.participants = [];
	            $scope.newDatatype.id = new ObjectId().toString();
	            $scope.newDatatype.libIds = [];
	            if ($scope.newDatatype.components != undefined && $scope.newDatatype.components != null && $scope.newDatatype.components.length != 0) {
	                for (var i = 0; i < $scope.newDatatype.components.length; i++) {
	                    $scope.newDatatype.components[i].id = new ObjectId().toString();
	                }
	            }

	            var predicates = $scope.newDatatype['predicates'];
	            if (predicates != undefined && predicates != null && predicates.length != 0) {
	                angular.forEach(predicates, function(predicate) {
	                    predicate.id = new ObjectId().toString();
	                });
	            }

	            var conformanceStatements = $scope.newDatatype['conformanceStatements'];
	            if (conformanceStatements != undefined && conformanceStatements != null && conformanceStatements.length != 0) {
	                angular.forEach(conformanceStatements, function(conformanceStatement) {
	                    conformanceStatement.id = new ObjectId().toString();
	                });
	            }
	          //  $scope.selectedDatatypes.push($scope.newDatatype);
	            console.log($scope.selectedDatatypes)
	        }
	        $scope.deleteDt = function(datatype) {
	            var index = $scope.selectedDatatypes.indexOf(datatype);
	            if (index > -1) $scope.selectedDatatypes.splice(index, 1);
	        };
	        var secretEmptyKey = '[$empty$]'
	        $scope.dtComparator = function(datatype, viewValue) {
	            if (datatype) {
	                console.log(datatype.name);
	                console.log(datatype);
	            }
	            return viewValue === secretEmptyKey || (datatype && ('' + datatype.name).toLowerCase().indexOf(('' + viewValue).toLowerCase()) > -1);
	        };


	        $scope.isInDts = function(datatype) {

	            if ($scope.hl7Datatypes.indexOf(datatype) === -1) {
	                return false;
	            } else {
	                return true;
	            }

	        }


	        $scope.selectDT = function(datatype) {
	            console.log(datatype);
	            $scope.newDatatype = datatype;
	        };
	        $scope.selected = function() {
	            return ($scope.newDatatype !== undefined);
	        };
	        $scope.unselect = function() {
	            $scope.newDatatype = undefined;
	        };
	        $scope.isActive = function(id) {
	            if ($scope.newDatatype) {
	                return $scope.newDatatype.id === id;
	            } else {
	                return false;
	            }
	        };
	        $scope.ok = function() {
	            console.log($scope.selectedDatatypes);
	            $scope.selectFlv = [];
	            var newLinks = [];
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                if ($scope.selectedDatatypes[i].scope === datatypeLibrary.scope) {
	                    $scope.selectFlv.push($scope.selectedDatatypes[i]);
	                } else {
	                    newLinks.push({
	                        id: $scope.selectedDatatypes[i].id,
	                        name: $scope.selectedDatatypes[i].name
	                    })
	                }
	            }
	            $rootScope.usedDtLink = [];
	            $rootScope.usedVsLink = [];
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                $rootScope.fillMaps($scope.selectedDatatypes[i]);
	            }
	            DatatypeService.saves($scope.selectFlv).then(function(result) {
	                for (var i = 0; i < result.length; i++) {
	                    newLinks.push({
	                        id: result[i].id,
	                        name: result[i].name,
	                        ext: result[i].ext
	                    })
	                }
	                DatatypeLibrarySvc.addChildren(datatypeLibrary.id, newLinks).then(function(link) {
	                    for (var i = 0; i < newLinks.length; i++) {
	                        datatypeLibrary.children.splice(0, 0, newLinks[i]);
	                    }
	                    for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                        $rootScope.datatypes.splice(0, 0, $scope.selectedDatatypes[i]);
	                    }
	                    for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                        $rootScope.datatypesMap[$scope.selectedDatatypes[i].id] = $scope.selectedDatatypes[i];
	                    }
	                    var usedDtId1 = _.map($rootScope.usedDtLink, function(num, key) {
	                        return num.id;
	                    });

	                    DatatypeService.get(usedDtId1).then(function(datatypes) {
	                        for (var j = 0; j < datatypes.length; j++) {
	                            if (!$rootScope.datatypesMap[datatypes[j].id]) {

	                                $rootScope.datatypesMap[datatypes[j].id] = datatypes[j];
	                                $rootScope.datatypes.push(datatypes[j]);
	                                //$rootScope.getDerived(datatypes[j]);
	                            }
	                        }

	                        var usedVsId = _.map($rootScope.usedVsLink, function(num, key) {
	                            return num.id;
	                        });
	                        console.log("$rootScope.usedVsLink");

	                        console.log($rootScope.usedVsLink);
	                        var newTablesLink = _.difference($rootScope.usedVsLink,tableLibrary.children);
	                        console.log(newTablesLink);

	                        TableLibrarySvc.addChildren(tableLibrary.id, newTablesLink).then(function() {
	                          tableLibrary.children = _.union(newTablesLink, tableLibrary.children);

	                            TableService.get(usedVsId).then(function(tables) {
	                                for (var j = 0; j < tables.length; j++) {
	                                    if (!$rootScope.tablesMap[tables[j].id]) {
	                                        $rootScope.tablesMap[tables[j].id] = tables[j];
	                                        $rootScope.tables.push(tables[j]);

	                                    }
	                                }
                                    $modalInstance.close(datatypes);
	                            });

	                        });
	                    });
	                    $rootScope.msg().text = "datatypeAdded";
	                    $rootScope.msg().type = "success";
	                    $rootScope.msg().show = true;
	                });

	            }, function(error) {
	                $rootScope.saving = false;
	                $rootScope.msg().text = error.data.text;
	                $rootScope.msg().type = error.data.type;
	                $rootScope.msg().show = true;
	            });


	        };

	        $scope.cancel = function() {
	            $modalInstance.dismiss('cancel');
	        };
	    });

angular.module('igl').controller('cannotPublish', function($scope, $rootScope, $http, $modalInstance, datatype, derived) {

    $scope.datatypeTo= datatype;
    $scope.delete = function() {
        $modalInstance.close($scope.datatypeTo);
    };

    $scope.cancel = function() {
    	console.log("sssss");
        $modalInstance.dismiss('cancel');
    };
});
angular.module('igl').controller('ConfirmTablePublishCtl', function($scope, $rootScope, $http, $modalInstance, tableToPublish) {

    $scope.tableToPublish = tableToPublish;
    $scope.loading = false;

    $scope.confirm = function() {
        console.log("confirming")

        $modalInstance.close($scope.tableToPublish);
    };

    $scope.cancel = function() {
        $scope.tableToPublish.status = "UNPUBLISHED";
        $modalInstance.dismiss('cancel');
    };
});


angular.module('igl').controller('AddSharedDatatype',
	    function($scope, $rootScope, $modalInstance, hl7Version, DatatypeLibrarySvc, DatatypeService, TableLibrarySvc, TableService, $http,datatypeLibrary,tableLibrary,versionAndUseMap) {
			$scope.versionAndUseMap=versionAndUseMap;
	        $scope.newDts = [];
	        $scope.checkedExt = true;
	        $scope.NocheckedExt = true;
	        $scope.selectedDatatypes = [];


	        var listHL7Versions = function() {
	            return $http.get('api/igdocuments/findVersions', {
	                timeout: 60000
	            }).then(function(response) {
	                var hl7Versions = [];
	                var length = response.data.length;
	                for (var i = 0; i < length; i++) {
	                    hl7Versions.push(response.data[i]);
	                }
	                console.log(hl7Versions);
	                return hl7Versions;
	            });
	        };

	        var init = function() {
	            listHL7Versions().then(function(versions) {
	            	$scope.hl7Datatypes=[];
	                $scope.version1 = "";
	                $scope.versions = versions;
                    DatatypeService.getSharedDatatypes().then(function(result) {
	                console.log("result");
	                console.log(result);

	               $scope.hl7Datatypes= result;

	            });
	                var scopes = ['HL7STANDARD'];
	            });

	        };
	        init();
	        $scope.setVersion = function(version) {
	            $scope.version1 = version;
	        }
	        $scope.addDt = function(datatype) {
	            console.log(datatype);
	            $scope.selectedDatatypes.push(datatype);
	            console.log("chowing map");

	            console.log($rootScope.versionAndUseMap[datatype.id]);
	        };
	        $scope.checkExist = function(datatype) {

	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                if ($scope.selectedDatatypes[i].id === datatype.id) {
	                    return true;
	                }
	            }
	            for (var i = 0; i < $rootScope.datatypes.length; i++) {
	                if ($rootScope.datatypes[i].id === datatype.id) {
	                    return true;
	                }
	            }
	            return false;
	        }
	        $scope.checkExt = function(datatype) {
	            $scope.checkedExt = true;
	            $scope.NocheckedExt = true;
	            if (datatype.ext === "") {
	                $scope.NocheckedExt = false;
	                return $scope.NocheckedExt;
	            }
	            for (var i = 0; i < $rootScope.datatypes.length; i++) {
	                if ($rootScope.datatypes[i].name === datatype.name && $rootScope.datatypes[i].ext === datatype.ext) {
	                    $scope.checkedExt = false;
	                    return $scope.checkedExt;
	                }
	            }
	            console.log($scope.selectedDatatypes.indexOf(datatype));
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                if ($scope.selectedDatatypes.indexOf(datatype) !== i) {
	                    if ($scope.selectedDatatypes[i].name === datatype.name && $scope.selectedDatatypes[i].ext === datatype.ext) {
	                        $scope.checkedExt = false;
	                        return $scope.checkedExt;
	                    }
	                }

	            }

	            return $scope.checkedExt;
	        };
	        $scope.addDtFlv = function(datatype) {
	                $scope.newDatatype = angular.copy(datatype);

	            	$scope.newDatatype.ext=Math.floor(Math.random() * 1000);

                	console.log($scope.newDatatype.ext);
       	            $scope.newDatatype.scope =datatypeLibrary.scope;
                  	$scope.newDatatype.status="UNPUBLISHED";

       	            $scope.newDatatype.participants = [];
       	            $scope.newDatatype.id = new ObjectId().toString();
       	            $scope.newDatatype.libIds = [];
    	            $scope.selectedDatatypes.push($scope.newDatatype);
    	            console.log($scope.selectedDatatypes)
	            console.log($scope.newDatatype.ext);
	            $scope.newDatatype.scope =datatypeLibrary.scope;
           	 	$scope.newDatatype.status="UNPUBLISHED";
	            $scope.newDatatype.participants = [];
	            $scope.newDatatype.id = new ObjectId().toString();;
	            $scope.newDatatype.libIds = [];
	            if ($scope.newDatatype.components != undefined && $scope.newDatatype.components != null && $scope.newDatatype.components.length != 0) {
	                for (var i = 0; i < $scope.newDatatype.components.length; i++) {
	                    $scope.newDatatype.components[i].id = new ObjectId().toString();
	                }
	            }

	            var predicates = $scope.newDatatype['predicates'];
	            if (predicates != undefined && predicates != null && predicates.length != 0) {
	                angular.forEach(predicates, function(predicate) {
	                    predicate.id = new ObjectId().toString();
	                });
	            }

	            var conformanceStatements = $scope.newDatatype['conformanceStatements'];
	            if (conformanceStatements != undefined && conformanceStatements != null && conformanceStatements.length != 0) {
	                angular.forEach(conformanceStatements, function(conformanceStatement) {
	                    conformanceStatement.id = new ObjectId().toString();
	                });
	            }
	          //  $scope.selectedDatatypes.push($scope.newDatatype);
	            console.log($scope.selectedDatatypes)
	        }
	        $scope.deleteDt = function(datatype) {
	            var index = $scope.selectedDatatypes.indexOf(datatype);
	            if (index > -1) $scope.selectedDatatypes.splice(index, 1);
	        };
	        var secretEmptyKey = '[$empty$]';

	        $scope.dtComparator = function(datatype, viewValue) {
	            if (datatype) {
	                console.log(datatype.name);
	                console.log(datatype);
	            }
	            return viewValue === secretEmptyKey || (datatype && ('' + datatype.name).toLowerCase().indexOf(('' + viewValue).toLowerCase()) > -1);
	        };


	        $scope.isInDts = function(datatype) {

	            if ($scope.hl7Datatypes.indexOf(datatype) === -1) {
	                return false;
	            } else {
	                return true;
	            }

	        }


	        $scope.selectDT = function(datatype) {
	            console.log(datatype);
	            $scope.newDatatype = datatype;
	        };
	        $scope.selected = function() {
	            return ($scope.newDatatype !== undefined);
	        };
	        $scope.unselect = function() {
	            $scope.newDatatype = undefined;
	        };
	        $scope.isActive = function(id) {
	            if ($scope.newDatatype) {
	                return $scope.newDatatype.id === id;
	            } else {
	                return false;
	            }
	        };

	        $scope.ok = function() {
	            console.log($scope.selectedDatatypes);
	            $scope.selectFlv = [];
	            var newLinks = [];
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                if ($scope.selectedDatatypes[i].scope === datatypeLibrary.scope) {
	                    $scope.selectFlv.push($scope.selectedDatatypes[i]);
	                } else {
	                    newLinks.push({
	                        id: $scope.selectedDatatypes[i].id,
	                        name: $scope.selectedDatatypes[i].name
	                    })
	                }
	            }
	            $rootScope.usedDtLink = [];
	            $rootScope.usedVsLink = [];
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                $rootScope.fillMaps($scope.selectedDatatypes[i]);
	            }
	            DatatypeService.saves($scope.selectFlv).then(function(result) {
	                for (var i = 0; i < result.length; i++) {
	                    newLinks.push({
	                        id: result[i].id,
	                        name: result[i].name,
	                        ext: result[i].ext
	                    })
	                }
	                DatatypeLibrarySvc.addChildren(datatypeLibrary.id, newLinks).then(function(link) {
	                    for (var i = 0; i < newLinks.length; i++) {
	                        datatypeLibrary.children.splice(0, 0, newLinks[i]);
	                    }
	                    for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                        $rootScope.datatypes.splice(0, 0, $scope.selectedDatatypes[i]);
	                    }
	                    for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                        $rootScope.datatypesMap[$scope.selectedDatatypes[i].id] = $scope.selectedDatatypes[i];
	                    }
	                    var usedDtId1 = _.map($rootScope.usedDtLink, function(num, key) {
	                        return num.id;
	                    });

	                    DatatypeService.get(usedDtId1).then(function(datatypes) {
	                        for (var j = 0; j < datatypes.length; j++) {
	                            if (!$rootScope.datatypesMap[datatypes[j].id]) {

	                                $rootScope.datatypesMap[datatypes[j].id] = datatypes[j];
	                                $rootScope.datatypes.push(datatypes[j]);
	                               // $rootScope.getDerived(datatypes[j]);
	                            }
	                        }

	                        var usedVsId = _.map($rootScope.usedVsLink, function(num, key) {
	                            return num.id;
	                        });
	                        console.log("$rootScope.usedVsLink");

	                        console.log($rootScope.usedVsLink);
	                        var newTablesLink = _.difference($rootScope.usedVsLink,tableLibrary.children);
	                        console.log(newTablesLink);

	                        TableLibrarySvc.addChildren(tableLibrary.id, newTablesLink).then(function() {
	                          tableLibrary.children = _.union(newTablesLink, tableLibrary.children);

	                            TableService.get(usedVsId).then(function(tables) {
	                                for (var j = 0; j < tables.length; j++) {
	                                    if (!$rootScope.tablesMap[tables[j].id]) {
	                                        $rootScope.tablesMap[tables[j].id] = tables[j];
	                                        $rootScope.tables.push(tables[j]);

	                                    }
	                                }


                                $modalInstance.close(datatypes);

	                            });
	                        });
	                    });
	                    $rootScope.msg().text = "datatypeAdded";
	                    $rootScope.msg().type = "success";
	                    $rootScope.msg().show = true;

	                });

	            }, function(error) {
	                $rootScope.saving = false;
	                $rootScope.msg().text = error.data.text;
	                $rootScope.msg().type = error.data.type;
	                $rootScope.msg().show = true;
	            });


	        };

	        $scope.cancel = function() {
	            $modalInstance.dismiss('cancel');
	        };
	    });

'use strict';

/**
 * @ngdoc function
 * @name clientApp.controller:AboutCtrl
 * @description
 * # AboutCtrl
 * Controller of the clientApp
 */
angular.module('igl')
  .controller('AboutCtrl', function ($scope, $rootScope) {

   $scope.releaseNotes = [
        {
            "version":$rootScope.appInfo.version,
            "date":$rootScope.appInfo.date,
            updates:[
                'Update License for Editor',' Update Select IG Document Types Buttons','Update Create IG Document dialog',' Update Export as Dialog'
            ]
        },
        {
            "version":'1.0.0-beta-2',
            "date":'03/07/2016',
            updates:[
                'Display the left side table of contents for HTML export','Add Image (pfg,gif,jpeg,jpg) upload feature',' Add File (word, html,pdf) Upload feature','Export IG Document as Word Document',
                'Display the list message events by version for the creation of a new IG Document','Handle the message level predicates and conformance statements','Added Issue and About Tabs'
            ]
        }
    ];



  });

'use strict';

/* "newcap": false */

angular.module('igl')
.controller('UserProfileCtrl', ['$scope', '$resource', 'AccountLoader', 'Account', 'userInfoService', '$location',
    function ($scope, $resource, AccountLoader, Account, userInfoService, $location) {
        var PasswordChange = $resource('api/accounts/:id/passwordchange', {id:'@id'});

        $scope.accountpwd = {};

        $scope.initModel = function(data) {
            $scope.account = data;
            $scope.accountOrig = angular.copy($scope.account);
        };

        $scope.updateAccount = function() {
            //not sure it is very clean...
            //TODO: Add call back?
            new Account($scope.account).$save();

            $scope.accountOrig = angular.copy($scope.account);
        };

        $scope.resetForm = function() {
            $scope.account = angular.copy($scope.accountOrig);
        };

        //TODO: Change that: formData is only supported on modern browsers
        $scope.isUnchanged = function(formData) {
            return angular.equals(formData, $scope.accountOrig);
        };


        $scope.changePassword = function() {
            var user = new PasswordChange();
            user.username = $scope.account.username;
            user.password = $scope.accountpwd.currentPassword;
            user.newPassword = $scope.accountpwd.newPassword;
            user.id = $scope.account.id;
            //TODO: Check return value???
            user.$save().then(function(result){
                $scope.msg = angular.fromJson(result);
            });
        };

        $scope.deleteAccount = function () {
            var tmpAcct = new Account();
            tmpAcct.id = $scope.account.id;

            tmpAcct.$remove(function() {
                //console.log("Account removed");
                //TODO: Add a real check?
                userInfoService.setCurrentUser(null);
                $scope.$emit('event:logoutRequest');
                $location.url('/home');
            });
        };

        /*jshint newcap:false */
        AccountLoader(userInfoService.getAccountID()).then(
            function(data) {
                $scope.initModel(data);
                if (!$scope.$$phase) {
                    $scope.$apply();
                }
            },
            function() {
//                console.log('Error fetching account information');
            }
        );
    }
]);


angular.module('igl')
    .controller('UserAccountCtrl', ['$scope', '$resource', 'AccountLoader', 'Account', 'userInfoService', '$location', '$rootScope',
        function ($scope, $resource, AccountLoader, Account, userInfoService, $location,$rootScope) {


            $scope.accordi = { account : true, accounts:false};
            $scope.setSubActive = function (id) {
                if(id && id != null) {
                    $rootScope.setSubActive(id);
                    $('.accountMgt').hide();
                    $('#' + id).show();
                }
            };
            $scope.initAccount = function(){
                if($rootScope.subActivePath == null){
                    $rootScope.subActivePath = "account";
                }
                $scope.setSubActive($rootScope.subActivePath);
            };


        }
    ]);

'use strict';

angular.module('igl')
    .controller('AccountsListCtrl', ['$scope', 'MultiAuthorsLoader', 'MultiSupervisorsLoader','Account', '$modal', '$resource','AccountLoader','userInfoService','$location',
        function ($scope, MultiAuthorsLoader, MultiSupervisorsLoader, Account, $modal, $resource, AccountLoader, userInfoService, $location) {

            //$scope.accountTypes = [{ 'name':'Author', 'type':'author'}, {name:'Supervisor', type:'supervisor'}];
            //$scope.accountType = $scope.accountTypes[0];
            $scope.tmpAccountList = [].concat($scope.accountList);
            $scope.account = null;
            $scope.accountOrig = null;
            $scope.accountType = "author";
            $scope.scrollbarWidth = $scope.getScrollbarWidth();

//        var PasswordChange = $resource('api/accounts/:id/passwordchange', {id:'@id'});
            var PasswordChange = $resource('api/accounts/:id/userpasswordchange', {id:'@id'});
            var ApproveAccount = $resource('api/accounts/:id/approveaccount', {id:'@id'});
            var SuspendAccount = $resource('api/accounts/:id/suspendaccount', {id:'@id'});
            $scope.msg = null;

            $scope.accountpwd = {};

            $scope.updateAccount = function() {
                //not sure it is very clean...
                //TODO: Add call back?
                new Account($scope.account).$save();
                $scope.accountOrig = angular.copy($scope.account);
            };

            $scope.resetForm = function() {
                $scope.account = angular.copy($scope.accountOrig);
            };

            //TODO: Change that: formData is only supported on modern browsers
            $scope.isUnchanged = function(formData) {
                return angular.equals(formData, $scope.accountOrig);
            };

            $scope.changePassword = function() {
                var user = new PasswordChange();
                user.username = $scope.account.username;
                user.password = $scope.accountpwd.currentPassword;
                user.newPassword = $scope.accountpwd.newPassword;
                user.id = $scope.account.id;
                //TODO: Check return value???
                user.$save().then(function(result){
                    $scope.msg = angular.fromJson(result);
                });
            };

            $scope.loadAccounts = function(){
                if (userInfoService.isAuthenticated() && userInfoService.isAdmin()) {
                    $scope.msg = null;
                    new MultiAuthorsLoader().then(function (response) {
                        $scope.accountList = response;
                        $scope.tmpAccountList = [].concat($scope.accountList);
                    });
                }
            };

            $scope.initManageAccounts = function(){
                $scope.loadAccounts();
            };

            $scope.selectAccount = function(row) {
                $scope.accountpwd = {};
                $scope.account = row;
                $scope.accountOrig = angular.copy($scope.account);
            };

            $scope.deleteAccount = function() {
                $scope.confirmDelete($scope.account);
            };

            $scope.confirmDelete = function (accountToDelete) {
                var modalInstance = $modal.open({
                    templateUrl: 'ConfirmAccountDeleteCtrl.html',
                    controller: 'ConfirmAccountDeleteCtrl',
                    resolve: {
                        accountToDelete: function () {
                            return accountToDelete;
                        },
                        accountList: function () {
                            return $scope.accountList;
                        }
                    }
                });
                modalInstance.result.then(function (accountToDelete,accountList ) {
                    $scope.accountToDelete = accountToDelete;
                    $scope.accountList = accountList;
                }, function () {
                });
            };

            $scope.approveAccount = function() {
                var user = new ApproveAccount();
                user.username = $scope.account.username;
                user.id = $scope.account.id;
                user.$save().then(function(result){
                    $scope.account.pending = false;
                    $scope.msg = angular.fromJson(result);
                });
            };

            $scope.suspendAccount = function(){
                var user = new SuspendAccount();
                user.username = $scope.account.username;
                user.id = $scope.account.id;
                user.$save().then(function(result){
                    $scope.account.pending = true;
                    $scope.msg = angular.fromJson(result);
                });
            };


        }
    ]);



angular.module('igl').controller('ConfirmAccountDeleteCtrl', function ($scope, $modalInstance, accountToDelete,accountList,Account) {

    $scope.accountToDelete = accountToDelete;
    $scope.accountList = accountList;
    $scope.delete = function () {
        //console.log('Delete for', $scope.accountList[rowIndex]);
        Account.remove({id:accountToDelete.id},
            function() {
                var rowIndex = $scope.accountList.indexOf(accountToDelete);
                if(index !== -1){
                    $scope.accountList.splice(rowIndex,1);
                }
                $modalInstance.close($scope.accountToDelete);
            },
            function() {
//                            console.log('There was an error deleting the account');
            }
        );
    };

    $scope.cancel = function () {
        $modalInstance.dismiss('cancel');
    };
});






angular.module('igl').controller('compareCtrl', function($scope, $modal, ObjectDiff, orderByFilter, $rootScope, $q, $interval, ngTreetableParams, $http, StorageService, userInfoService, IgDocumentService, CompareService, SegmentService, DatatypeService, SegmentLibrarySvc, DatatypeLibrarySvc, TableLibrarySvc) {
    $scope.igDocumentConfig = {
        selectedType: null
    };
    $scope.getLabel = function(element) {
        if (element.ext !== null) {
            return element.name + "_" + element.ext;
        } else {
            return element.name;
        }
    };
    console.log("herrereer");
    console.log($rootScope.message);

    $scope.msgSelected = false;
    $scope.igDisabled1 = false;
    $scope.igDisabled2 = false;
    $scope.msgChanged = false;
    $scope.segChanged = false
    $scope.dtChanged = false;
    $scope.vsChanged = false;
    $scope.cmpMsg = false;
    $scope.cmpSeg = false;
    $scope.cmpDT = false;
    $scope.cmpVS = false;
    $scope.vsTemplate = false;

    //$scope.scopes = ["USER", "HL7STANDARD"];
    $scope.scopes = [{
        name: "USER",
        alias: "My IG"
    }, {
        name: "HL7STANDARD",
        alias: "Base HL7"
    }];
    $scope.toCompare = [{
        name: "message",
        alias: "Messages"
    }, {
        name: "datatype",
        alias: "Datatypes"
    }, {
        name: "valueset",
        alias: "Value Sets"
    }, {
        name: "segment",
        alias: "Segments"
    }];

    $scope.showDelta = false;
    var listHL7Versions = function() {
        return $http.get('api/igdocuments/findVersions', {
            timeout: 60000
        }).then(function(response) {
            var hl7Versions = [];
            var length = response.data.length;
            for (var i = 0; i < length; i++) {
                hl7Versions.push(response.data[i]);
            }
            return hl7Versions;
        });
    };

    var init = function() {
        listHL7Versions().then(function(versions) {
            $scope.versions = versions;
        });
    };

    $scope.$on('event:loginConfirmed', function(event) {
        init();
    });

    init();



    $scope.setCmpType = function(type) {
        if (type === "message") {
            $scope.cmpSeg = false;
            $scope.cmpVS = false;
            $scope.cmpDT = false;
            $scope.cmpMsg = true;
        } else if (type === "segment") {
            $scope.cmpMsg = false;
            $scope.cmpVS = false;
            $scope.cmpDT = false;
            $scope.cmpSeg = true;
        } else if (type === "datatype") {
            $scope.cmpSeg = false;
            $scope.cmpVS = false;
            $scope.cmpMsg = false;
            $scope.cmpDT = true;
        } else if (type === "valueset") {
            $scope.cmpSeg = false;
            $scope.cmpMsg = false;
            $scope.cmpDT = false;
            $scope.cmpVS = true;
        }
    }


    $scope.setVersion1 = function(vr) {
        $scope.version1 = vr;

    };
    $scope.setScope1 = function(scope) {

        $scope.scope1 = scope;

    }
    $scope.setVersion2 = function(vr) {
        $scope.version2 = vr;

    };
    $scope.setScope2 = function(scope) {

        $scope.scope2 = scope;
    };

    $scope.$watchGroup(['version1', 'scope1'], function() {
        $scope.igList1 = [];
        $scope.messages1 = [];
        $scope.datatypes1 = [];
        $scope.tables1 = [];
        $scope.segments1 = [];
        $scope.ig1 = "";


        if ($scope.scope1 && $scope.version1) {
            IgDocumentService.getIgDocumentsByScopesAndVersion([$scope.scope1], $scope.version1).then(function(result) {
                console.log(result);

                if (result) {

                    if ($scope.scope1 === "HL7STANDARD") {
                        $scope.igDisabled1 = true;


                        $scope.ig1 = {
                            id: result[0].id,
                            title: result[0].metaData.title
                        };


                        $scope.igList1.push($scope.ig1);
                        $scope.setIG1($scope.ig1);

                    } else {
                        $scope.igDisabled1 = false;

                        for (var i = 0; i < result.length; i++) {
                            $scope.igList1.push({
                                id: result[i].id,
                                title: result[i].metaData.title
                            });
                        }

                    }





                }
            });
        }

    }, true);
    $scope.$watchGroup(['version2', 'scope2'], function() {
        $scope.igList2 = [];
        $scope.messages2 = [];
        $scope.datatypes2 = [];
        $scope.tables2 = [];
        $scope.segments2 = [];
        $scope.ig2 = "";
        if ($scope.scope2 && $scope.version2) {
            console.log("hereee2");
            IgDocumentService.getIgDocumentsByScopesAndVersion([$scope.scope2], $scope.version2).then(function(result) {

                if (result) {
                    if ($scope.scope2 === "HL7STANDARD") {
                        $scope.igDisabled2 = true;
                        $scope.ig2 = {
                            id: result[0].id,
                            title: result[0].metaData.title
                        };
                        $scope.igList2.push($scope.ig2);

                        $scope.setIG2($scope.ig2);
                    } else {
                        $scope.igDisabled2 = false;
                        for (var i = 0; i < result.length; i++) {
                            $scope.igList2.push({
                                id: result[i].id,
                                title: result[i].metaData.title,
                            });
                        }

                    }




                }

            });
            // SegmentService.getSegmentsByScopesAndVersion([$scope.scope2], $scope.version2).then(function(result) {
            //     console.log(result);

            // });
        }

    }, true);
    $scope.$watchGroup(['msg1', 'msg2'], function() {
        $scope.msgChanged = true;


    }, true);
    $scope.$watchGroup(['segment1', 'segment2'], function() {
        $scope.segChanged = true;


    }, true);
    $scope.$watchGroup(['datatype1', 'datatype2'], function() {
        $scope.dtChanged = true;


    }, true);
    $scope.$watchGroup(['table1', 'table2'], function() {
        $scope.vsChanged = true;


    }, true);


    $scope.findIGbyID = function(id) {
        var selectedIG = [];

        angular.forEach($rootScope.igs, function(ig) {
            if (ig.id === id) {

                selectedIG = ig;
            }
        });
        return selectedIG;


    };
    $scope.setIG1 = function(ig) {
        console.log("ig==============");
        console.log(ig);
        if (ig) {
            IgDocumentService.getOne(ig.id).then(function(igDoc) {
                console.log(ig.id);
                SegmentLibrarySvc.getSegmentsByLibrary(igDoc.profile.segmentLibrary.id).then(function(segments) {
                    DatatypeLibrarySvc.getDatatypesByLibrary(igDoc.profile.datatypeLibrary.id).then(function(datatypes) {
                        TableLibrarySvc.getTablesByLibrary(igDoc.profile.tableLibrary.id).then(function(tables) {
                            $scope.messages1 = [];
                            $scope.msg1 = "";
                            if (igDoc) {
                                $scope.segList1 = angular.copy(segments);
                                $scope.dtList1 = angular.copy(datatypes);
                                $scope.tableList2 = angular.copy(tables);
                                $scope.messages1 = orderByFilter(igDoc.profile.messages.children, 'name');
                                $scope.segments1 = orderByFilter(segments, 'name');
                                $scope.datatypes1 = orderByFilter(datatypes, 'name');
                                $scope.tables1 = orderByFilter(tables, 'bindingIdentifier');
                            }
                        });
                    });
                });

            });

            //$scope.messages1 = ($scope.findIGbyID(JSON.parse(ig).id)).profile.messages.children;

        }


    };
    $scope.setIG2 = function(ig) {
        if (ig) {
            IgDocumentService.getOne(ig.id).then(function(igDoc) {
                SegmentLibrarySvc.getSegmentsByLibrary(igDoc.profile.segmentLibrary.id).then(function(segments) {
                    DatatypeLibrarySvc.getDatatypesByLibrary(igDoc.profile.datatypeLibrary.id).then(function(datatypes) {
                        TableLibrarySvc.getTablesByLibrary(igDoc.profile.tableLibrary.id).then(function(tables) {
                            $scope.messages2 = [];
                            $scope.msg2 = "";
                            if (igDoc) {
                                $scope.segList2 = angular.copy(segments);
                                //$scope.segList2 = orderByFilter($scope.segList2, 'name');
                                $scope.dtList2 = angular.copy(datatypes);
                                $scope.tableList2 = angular.copy(tables);
                                $scope.messages2 = orderByFilter(igDoc.profile.messages.children, 'name');
                                $scope.segments2 = orderByFilter(segments, 'name');
                                $scope.datatypes2 = orderByFilter(datatypes, 'name');
                                $scope.tables2 = orderByFilter(tables, 'bindingIdentifier');
                            }
                        });
                    });
                });

            });

            //$scope.messages2 = ($scope.findIGbyID(JSON.parse(ig).id)).profile.messages.children;

        }

    };
    $scope.hideMsg = function(msg1, msg2) {

        if (msg2) {
            return !(msg1.structID === JSON.parse(msg2).structID);
        } else {
            return false;
        }
    };
    $scope.disableMsg = function(msg1, msg2) {

        if (msg2) {
            return (msg1.id === JSON.parse(msg2).id);
        } else {
            return false;
        }
    };
    $scope.hideSeg = function(seg1, seg2) {

        if (seg2) {
            return !(seg1.name === JSON.parse(seg2).name);
        } else {
            return false;
        }
    };
    $scope.disableSeg = function(seg1, seg2) {

        if (seg2) {
            return (seg1.id === JSON.parse(seg2).id);
        } else {
            return false;
        }
    };

    $scope.setMsg1 = function(msg) {
        console.log(JSON.parse(msg));
        $scope.msg1 = msg;
    };
    $scope.setMsg2 = function(msg) {
        $scope.msg2 = msg;
    };
    $scope.setSegment1 = function(segment) {
        console.log(JSON.parse(segment));

        $scope.segment1 = segment;
    };
    $scope.setSegment2 = function(segment) {
        $scope.segment2 = segment;
    };
    $scope.setDatatype1 = function(datatype) {
        console.log(JSON.parse(datatype));

        $scope.datatype1 = datatype
    };
    $scope.setDatatype2 = function(datatype) {
        $scope.datatype2 = datatype
    };
    $scope.setTable1 = function(table) {
        console.log(JSON.parse(table));
    };
    $scope.setTable2 = function(table) {
        console.log(JSON.parse(table));
    };
    $scope.clearAll = function() {
        $scope.msg1 = "";
        $scope.msg2 = "";
        $scope.ig1 = "";
        $scope.ig2 = "";
        $scope.version1 = "";
        $scope.version2 = "";
        $scope.scope1 = "";
        $scope.scope2 = "";
        $scope.segment1 = "";
        $scope.segment2 = "";
        $scope.datatype1 = "";
        $scope.datatype2 = "";
        $scope.table1 = "";
        $scope.table2 = "";

    };
    $scope.clearIG = function() {
        $scope.ig1 = "";
        $scope.ig2 = "";
    }
    $scope.clearVersion = function() {
        $scope.version1 = "";
        $scope.version2 = "";
    }
    $scope.clearMessage = function() {
        $scope.msg1 = "";
        $scope.msg2 = "";
        $scope.segment1 = "";
        $scope.segment2 = "";
        $scope.datatype1 = "";
        $scope.datatype2 = "";
        $scope.table1 = "";
        $scope.table2 = "";

    }
    $scope.clearScope = function() {
        $scope.scope1 = "";
        $scope.scope2 = "";
    }
    $scope.formatGrp = function(grp) {
        var delay = $q.defer();

        var group = {
            id: grp.id,
            name: grp.name,
            type: grp.type,
            minCard: grp.min,
            maxCard: grp.max,
            usage: grp.usage,
            position: grp.position,
            //segments: $scope.formatSeg(grp.children)
        };
        $scope.formatSegments(grp.children).then(function(result) {
            //group.segments = result;
            var resultList = _.flatten(result);
            var SortedRes = [];
            SortedRes = orderByFilter(resultList, 'position');
            // for(var i=0;i<result.length;i++){
            //     if(angular.isArray(result[i])){
            //         for (var j = 0; i < result[i].length; j++) {
            //             resultList.push(result[i][j])
            //         };

            //     } 
            // }

            group.segments = SortedRes;
            delay.resolve(group);


        });
        return delay.promise;
        //return group;

    };

    $scope.formatFields = function(ids, fields) {
        var delay = $q.defer();
        DatatypeService.get(ids).then(function(dts) {
            for (var j = 0; j < dts.length; j++) {
                for (var i = 0; i < dts[j].components.length; i++) {
                    dts[j].components[i].id = "";

                }
            }
            for (var j = 0; j < fields.length; j++) {
                for (var i = 0; i < dts.length; i++) {
                    if (fields[j].datatype.id === dts[i].id && dts[i].components.length > 0) {
                        fields[j].components = dts[i].components;
                    }
                }
            }
            delay.resolve(fields);
        });
        return delay.promise;
    };


    $scope.formatComponent = function(ids, fields) {
        var delay = $q.defer();


        DatatypeService.get(ids).then(function(dts) {
            for (var j = 0; j < dts.length; j++) {
                for (var i = 0; i < dts[j].components.length; i++) {
                    dts[j].components[i].id = "";
                    dts[j].components[i].datatype.id = "";

                }
            }
            for (var j = 0; j < fields.length; j++) {
                for (var i = 0; i < dts.length; i++) {
                    if (fields[j].datatype.id === dts[i].id) {
                        fields[j].components = dts[i].components;
                    }

                }
                fields[j].datatype.id = "";
            }
            delay.resolve(fields);
        });






        // DatatypeService.getOne(field.datatype.id).then(function(dt) {
        //     for (var i = 0; i < dt.components.length; i++) {
        //         dt.components[i].id = "";
        //     }
        //     field.components = dt.components;
        //     delay.resolve(field);
        // });
        return delay.promise;



    };

    $scope.formatField = function(segment) {
        var delay = $q.defer();
        var promises = [];
        var dtId = [];
        for (var i = 0; i < segment.fields.length; i++) {
            segment.fields[i].id = "";
            //$scope.formatField(segs.fields[i]);
            dtId.push(segment.fields[i].datatype.id);

            //            promises.push($scope.formatComponent(segment.fields[i]));
        }
        promises.push($scope.formatComponent(dtId, segment.fields));

        $q.all(promises).then(function(fields) {
            delay.resolve(fields);
        });
        return delay.promise;
    };

    $scope.formatSeg = function(segment, segs) {
        var delay = $q.defer();
        if (segment.type === 'segmentRef') {
            var newSegment = {};
            newSegment = {
                id: segment.ref.id,
                name: segment.ref.name,
                label: segment.ref.label,
                type: segment.type,
                // fields: result,
                minCard: segment.min,
                maxCard: segment.max,
                usage: segment.usage,
                position: segment.position,
                description: segs.description,
                conformanceStatements: segs.conformanceStatements,
                coConstraints: segs.coConstraints,
                predicates: segs.predicates



            };
            $scope.formatField(segs).then(function(fields) {
                newSegment.fields = segs.fields;
                delay.resolve(newSegment);

            });

            // SegmentService.get(segment.ref.id).then(function(segs) {
            //     newSegment.description = segs.description;
            //     $scope.formatField(segs).then(function(fields) {
            //         newSegment.fields = segs.fields;
            //         delay.resolve(newSegment);

            //     });




            // });

            // $scope.formatFields(dtIds, newSegment.fields);


        } else {
            $scope.formatGrp(segment).then(function(grp) {
                delay.resolve(grp);
            });
        }
        return delay.promise;
    };

    $scope.segRefsFormating = function(idList, segmentRefs) {
        var delay = $q.defer();
        var promises = [];
        SegmentService.findByIds(idList).then(function(segments) {
            for (var i = 0; i < segmentRefs.length; i++) {
                for (var j = 0; j < segments.length; j++) {
                    if (segmentRefs[i].ref.id === segments[j].id) {
                        promises.push($scope.formatSeg(segmentRefs[i], segments[j]));
                    }

                }
            }
            $q.all(promises).then(function(segs) {
                delay.resolve(segs);
            });

        });

        return delay.promise;

    };




    $scope.formatSegments = function(segments) {

        var delay = $q.defer();
        var promises = [];
        var segRefList = [];
        var idList = [];
        for (var i = 0; i < segments.length; i++) {
            if (segments[i].type === "group") {

                promises.push($scope.formatGrp(segments[i]));

            } else if (segments[i].type === "segmentRef") {
                idList.push(segments[i].ref.id);
                segRefList.push(segments[i]);

                //                promises.push($scope.formatSeg(segments[i]));

            }
            // else if (segments[i].type === "field") {
            //     promises.push($scope.formatField(segments[i]));

            // }
        };
        promises.push($scope.segRefsFormating(idList, segRefList));
        $q.all(promises).then(function(segs) {
            delay.resolve(segs);
        });
        return delay.promise;


        //return result;


    };
    $scope.formatMsg = function(msg) {
        console.log(msg);
        var delay = $q.defer();

        var message = {
            name: msg.name,
            event: msg.event,
            structID: msg.structID,
            position: msg.position,
            //segments: $scope.formatSeg(msg.children)
        }
        $scope.formatSegments(msg.children).then(function(result) {
            var resultList = _.flatten(result);
            var SortedRes = [];
            SortedRes = orderByFilter(resultList, 'position');

            // for(var i=0;i<result.length;i++){
            //     if(angular.isArray(result[i])){
            //         for (var j = 0; i < result[i].length; j++) {
            //             resultList.push(result[i][j])
            //         };

            //     } 
            // }

            message.segments = SortedRes;

            delay.resolve(message);

        });


        return delay.promise;

        // console.log(message);
        // return message;

    };


    $scope.fMsg = function(msg, datatypeList, segmentList) {
        console.log("====");
        console.log(segmentList);
        var elements = []
        var message = {
            name: msg.name,
            event: msg.event,
            structID: msg.structID,
            position: msg.position,
            segments: $scope.fElements(msg.children, datatypeList, segmentList)
        };
        // for (var i = 0; i < msg.children.length; i++) {
        //     elements.push($scope.fElement(msg.children[i]));
        // };
        // message.segments=elements;

        return message;
    };
    $scope.fSegment = function(segment, datatypeList, segmentList) {
        var elements = [];

        if (segment.type === "segment") {
            elements.push(segment);
        }
        console.log(elements);
        return $scope.fElements(elements, datatypeList, segmentList);
    };
    $scope.fDatatype = function(datatype, datatypeList, segmentList) {
        var elements = [];

        if (datatype.type === "datatype") {
            elements.push(datatype);
        }
        console.log("fDatatype");
        console.log(elements)
        return $scope.fElements(elements, datatypeList, segmentList);
    };
    $scope.fTable = function(table) {

    };

    $scope.fElements = function(elements, datatypeList, segmentList) {
        console.log(elements);
        console.log("elements");

        var result = [];
        for (var i = 0; i < elements.length; i++) {
            if (elements[i].type === 'segmentRef') {
                var segment = {};

                segment = {
                    //id: elements[i].ref.id,
                    name: elements[i].ref.name,
                    label: elements[i].ref.label,
                    type: elements[i].type,
                    minCard: elements[i].min,
                    maxCard: elements[i].max,
                    usage: elements[i].usage,
                    position: elements[i].position
                };

                for (var j = 0; j < segmentList.length; j++) {


                    if (elements[i].ref.id === segmentList[j].id) {

                        segment.description = segmentList[j].description;
                        segment.conformanceStatements = segmentList[j].conformanceStatements;
                        segment.coConstraints = segmentList[j].coConstraints;
                        segment.predicates = segmentList[j].predicates;
                        segment.fields = $scope.fFields(segmentList[j].fields, datatypeList, segmentList);
                    }
                };



                result.push(segment);

            } else if (elements[i].type === 'group') {
                result.push($scope.fGrp(elements[i], datatypeList, segmentList));
            } else if (elements[i].type === 'segment') {
                elements[i].fields = $scope.fFields(elements[i].fields, datatypeList, segmentList);
                result.push(elements[i]);
            } else if (elements[i].type === 'datatype') {
                elements[i].components = $scope.fFields(elements[i].components, datatypeList, segmentList);
                result.push(elements[i]);
            } else if (elements[i].type === 'component') {
                //elements[i].fields = $scope.fFields(elements[i].fields, datatypeList, segmentList);

            }
        };
        return result;
    };
    $scope.fGrp = function(grp, datatypeList, segmentList) {
        var group = {
            name: grp.name,
            type: grp.type,
            minCard: grp.min,
            maxCard: grp.max,
            usage: grp.usage,
            position: grp.position,
            segments: $scope.fElements(grp.children, datatypeList, segmentList)
        };
        return group;
    };
    $scope.fFields = function(fields, datatypeList, segmentList) {
        // for (var j = 0; j < datatypeList.length; j++) {
        //     for (var i = 0; i < datatypeList[j].components.length; i++) {
        //         datatypeList[j].components[i].id = "";
        //         datatypeList[j].components[i].datatype.id = "";

        //     }
        // }

        for (var i = 0; i < fields.length; i++) {
            fields[i].id = "";
            for (var j = 0; j < datatypeList.length; j++) {
                if (fields[i].datatype.id === datatypeList[j].id) {

                    fields[i].components = $scope.fFields(datatypeList[j].components, datatypeList, segmentList);

                }
            };
            fields[i].datatype.id = "";

        };

        return fields;


    };




    var objToArray = function(object) {
        var result = [];
        $.map(object, function(value, index) {

            result.push(value);
        });
        return result;

    };
    var writettTable = function(childArray, dataArray) {
        var result = {};


        if (childArray.changed === "object change") {
            if (childArray.value.position && childArray.value.position.changed === "equal") {
                result.position = {
                    element: childArray.value.position.value,

                };
            }

            if (childArray.value.type.changed === "equal") {
                result.type = {
                    element: childArray.value.type.value,
                };

                if (childArray.value.usage && childArray.value.usage.changed === "primitive change") {
                    result.usage = {
                        element1: childArray.value.usage.removed,
                        element2: childArray.value.usage.added

                    };
                }
                if (childArray.value.type.value === "field" || childArray.value.type.value === "component" || childArray.value.type.value === "datatype") {

                    if (childArray.value.name.changed === "primitive change") {
                        result.label = {
                            element1: childArray.value.name.removed,
                            element2: childArray.value.name.added

                        };

                    }


                    if (childArray.value.name.changed === "equal") {
                        result.label = {
                            element: childArray.value.name.value,

                        };
                    }
                    if (childArray.value.ext && childArray.value.ext.changed === "primitive change") {
                        result.ext = {
                            element1: childArray.value.ext.removed,
                            element2: childArray.value.name.added

                        };

                    }


                    if (childArray.value.ext && childArray.value.ext.changed === "equal" && childArray.value.ext.value !== null) {
                        result.ext = {
                            element: childArray.value.ext.value,

                        };
                    }
                    if (childArray.value.min && childArray.value.min.changed === "primitive change") {
                        result.minCard = {
                            element1: childArray.value.min.removed,
                            element2: childArray.value.min.added

                        };
                    } else if (childArray.value.min && childArray.value.min.changed === "removed") {
                        console.log(childArray.value.min);
                    } else if (childArray.value.min && childArray.value.min.changed === "added") {
                        console.log(childArray.value.min);
                    }
                    if (childArray.value.max && childArray.value.max.changed === "primitive change") {
                        result.maxCard = {
                            element1: childArray.value.max.removed,
                            element2: childArray.value.max.added

                        };
                    }
                    if (childArray.value.minLength && childArray.value.minLength.changed === "primitive change") {
                        result.minLength = {
                            element1: childArray.value.minLength.removed,
                            element2: childArray.value.minLength.added

                        };
                    }
                    if (childArray.value.maxLength && childArray.value.maxLength.changed === "primitive change") {
                        result.maxLength = {
                            element1: childArray.value.maxLength.removed,
                            element2: childArray.value.maxLength.added

                        };
                    }
                    if (childArray.value.confLength && childArray.value.confLength.changed === "primitive change") {
                        result.confLength = {
                            element1: childArray.value.confLength.removed,
                            element2: childArray.value.confLength.added

                        };
                    }
                    if (childArray.value.datatype && childArray.value.datatype.changed === "object change") {
                        result.datatype = {
                            element1: childArray.value.datatype.value.label.removed,
                            element2: childArray.value.datatype.value.label.added

                        };
                    }
                    if (childArray.value.components && childArray.value.components.changed === "object change") {
                        result.components = [];
                        objToArray(childArray.value.components.value).forEach(function(childNode) {
                            writettTable(childNode, result.components);

                        });
                        // objToArray(childArray.value.components.value).forEach(function(childNode) {
                        //     if(childNode.changed==="added"){
                        //         result.component.push({
                        //             msg1:"";
                        //             msg2:childNode
                        //         })

                        //     } else if(childNode.changed==="removed"){

                        //     } else 
                        //     if(childNode.changed==="object change"){
                        //         writettTable(childNode, result.components);

                        //     }


                        // });

                    }
                    if (childArray.value.table && childArray.value.table.changed === "object change" && childArray.value.table.value.bindingIdentifier.changed === "primitive change") {
                        result.valueset = {
                            element1: childArray.value.table.value.bindingIdentifier.removed,
                            element2: childArray.value.table.value.bindingIdentifier.added

                        };

                    }


                } else {

                    if (childArray.value.minCard && childArray.value.minCard.changed === "primitive change") {
                        result.minCard = {
                            element1: childArray.value.minCard.removed,
                            element2: childArray.value.minCard.added

                        };
                    }
                    if (childArray.value.maxCard && childArray.value.maxCard.changed === "primitive change") {
                        result.maxCard = {
                            element1: childArray.value.maxCard.removed,
                            element2: childArray.value.maxCard.added

                        };
                    }
                }

                if (childArray.value.type.value === "segmentRef" || childArray.value.type.value === "segment") {
                    if (childArray.value.name.changed === "primitive change") {
                        result.label = {
                            element1: childArray.value.name.removed,
                            element2: childArray.value.name.added
                        };
                    }
                    if (childArray.value.name.changed === "equal") {
                        result.label = {
                            element: childArray.value.name.value,
                        };
                    }
                    if (childArray.value.ext && childArray.value.ext.changed === "primitive change") {
                        result.ext = {
                            element1: childArray.value.ext.removed,
                            element2: childArray.value.ext.added
                        };
                    }
                    if (childArray.value.ext && childArray.value.ext.changed === "equal") {
                        result.ext = {
                            element: childArray.value.ext.value,
                        };
                    }
                    if (childArray.value.description && childArray.value.description.changed === "primitive change") {
                        result.description = {
                            element1: childArray.value.description.removed,
                            element2: childArray.value.description.added
                        };
                    } else if (childArray.value.description && childArray.value.description.changed === "equal") {
                        result.description = {
                            element: childArray.value.description.value,

                        };
                    }


                    if (childArray.value.fields && childArray.value.fields.changed === "object change") {
                        result.fields = [];
                        objToArray(childArray.value.fields.value).forEach(function(childNode) {
                            console.log(childNode);
                            writettTable(childNode, result.fields);

                        });
                    }

                } else if (childArray.value.type.value === "group") {
                    if (childArray.value.name.changed === "primitive change") {
                        result.label = {
                            element1: childArray.value.name.removed,
                            element2: childArray.value.name.added

                        };

                    }

                    if (childArray.value.name.changed === "equal") {
                        result.label = {
                            element: childArray.value.name.value,

                        };
                    }
                    if (childArray.value.segments.changed === "object change") {
                        result.segments = [];
                        objToArray(childArray.value.segments.value).forEach(function(childNode) {
                            writettTable(childNode, result.segments);

                        });


                    }
                } else if (childArray.value.type.value === "table") {
                    if (childArray.value.bindingIdentifier.changed === "primitive change") {
                        result.label = {
                            element1: childArray.value.bindingIdentifier.removed,
                            element2: childArray.value.bindingIdentifier.added

                        };

                    }

                    if (childArray.value.bindingIdentifier.changed === "equal") {
                        result.label = {
                            element: childArray.value.bindingIdentifier.value,

                        };
                    }
                    if (childArray.value.description && childArray.value.description.changed === "primitive change") {
                        result.description = {
                            element1: childArray.value.description.removed,
                            element2: childArray.value.description.added
                        };
                    } else if (childArray.value.description && childArray.value.description.changed === "equal") {
                        result.description = {
                            element: childArray.value.description.value,

                        };
                    }
                    if (childArray.value.contentDefinition && childArray.value.contentDefinition.changed === "primitive change") {
                        result.contentDefinition = {
                            element1: childArray.value.contentDefinition.removed,
                            element2: childArray.value.contentDefinition.added
                        };
                    }
                    if (childArray.value.codes && childArray.value.codes.changed === "object change") {
                        result.codes = [];
                        objToArray(childArray.value.codes.value).forEach(function(childNode) {
                            writettTable(childNode, result.codes);

                        });
                    }
                } else if (childArray.value.type.value === "code") {
                    if (childArray.value.codeSystem && childArray.value.codeSystem.changed === "primitive change") {
                        result.codeSystem = {
                            element1: childArray.value.codeSystem.removed,
                            element2: childArray.value.codeSystem.added
                        };
                    }
                    if (childArray.value.codeUsage && childArray.value.codeUsage.changed === "primitive change") {
                        result.codeUsage = {
                            element1: childArray.value.codeUsage.removed,
                            element2: childArray.value.codeUsage.added
                        };
                    }
                    if (childArray.value.label && childArray.value.label.changed === "primitive change") {
                        result.description = {
                            element1: childArray.value.label.removed,
                            element2: childArray.value.label.added
                        };
                    } else if (childArray.value.label && childArray.value.label.changed === "equal") {
                        result.description = {
                            element: childArray.value.label.value,

                        };
                    }
                    if (childArray.value.value && childArray.value.value.changed === "primitive change") {
                        result.label = {
                            element1: childArray.value.value.removed,
                            element2: childArray.value.value.added
                        };
                    } else if (childArray.value.value && childArray.value.value.changed === "equal") {
                        console.log(childArray);
                        result.label = {
                            element: childArray.value.value.value,

                        };
                    }
                }
            } else if (childArray.value.type.changed === "primitive change") {
                result.label = {
                    element1: childArray.value.name.removed,
                    element2: childArray.value.name.added

                };
                result.type = {
                    element1: childArray.value.type.removed,
                    element2: childArray.value.type.added
                };
            }
            dataArray.push(result);




        }

    };
    $scope.valueSet_params = new ngTreetableParams({
        getNodes: function(parent) {
            if ($scope.dataList !== undefined) {

                //return parent ? parent.fields : $scope.test;
                if (parent) {
                    if (parent.codes) {
                        return parent.codes;
                    }

                } else {
                    return $scope.dataList;
                }

            }
        },
        getTemplate: function(node) {

            // if (node.type.element === "table" || node.type.element === "code") {
            $scope.vsTemplate = true;
            return 'valueSet_node';
            // } else if (node.type.element === "segment") {
            // console.log("node===============");
            // console.log(node);
            // $scope.vsTemplate = false;
            // return 'tree_node';
            // }




        }
    });
    $scope.dynamic_params = new ngTreetableParams({
        getNodes: function(parent) {
            if ($scope.dataList !== undefined) {

                //return parent ? parent.fields : $scope.test;
                if (parent) {
                    if (parent.fields) {
                        return parent.fields;
                    } else if (parent.components) {
                        return parent.components;
                    } else if (parent.segments) {
                        return parent.segments;
                    } else if (parent.codes) {
                        return parent.codes;
                    }

                } else {
                    return $scope.dataList;
                }

            }
        },
        getTemplate: function(node) {
            return 'tree_node';
        }
    });
    $scope.cmpValueSet = function(table1, table2) {
        $scope.loadingSelection = true;
        $scope.vsChanged = false;
        $scope.vsTemplate = true;
        $scope.dataList = CompareService.cmpValueSet(table1, table2);
        $scope.loadingSelection = false;
        if ($scope.valueSet_params) {
            console.log($scope.dataList);
            $scope.showDelta = true;
            $scope.valueSet_params.refresh();
        }
    };

    $scope.cmpDatatype = function(datatype1, datatype2) {
        $scope.loadingSelection = true;
        $scope.dtChanged = false;
        $scope.vsTemplate = false;
        $scope.dataList = CompareService.cmpDatatype(datatype1, datatype2, $scope.dtList1, $scope.dtList2, $scope.segList1, $scope.segList2);
        $scope.loadingSelection = false;
        if ($scope.dynamic_params) {
            console.log($scope.dataList);
            $scope.showDelta = true;
            $scope.dynamic_params.refresh();
        }
    };
    $scope.cmpSegment = function(segment1, segment2) {
        $scope.loadingSelection = true;
        $scope.segChanged = false;
        $scope.vsTemplate = false;
        $scope.dataList = CompareService.cmpSegment(segment1, segment2, $scope.dtList1, $scope.dtList2, $scope.segList1, $scope.segList2);
        $scope.loadingSelection = false;
        if ($scope.dynamic_params) {
            console.log($scope.dataList);
            $scope.showDelta = true;
            $scope.dynamic_params.refresh();
        }
    };
    $scope.cmpMessage = function(msg1, msg2) {
        $scope.loadingSelection = true;
        $scope.msgChanged = false;
        $scope.vsTemplate = false;
        $scope.loadingSelection = false;
        $scope.dataList = CompareService.cmpMessage(msg1, msg2, $scope.dtList1, $scope.dtList2, $scope.segList1, $scope.segList2);
        //$scope.dataList = result;



        if ($scope.dynamic_params) {
            console.log($scope.dataList);
            $scope.showDelta = true;
            $scope.dynamic_params.refresh();
        }

    };

    // CompareService.cmpMessage = function(msg1, msg2) {
    //     $scope.loadingSelection = true;
    //     $scope.msgChanged = false;
    //     $scope.vsTemplate = false;
    //     var msg1 = $scope.fMsg(JSON.parse(msg1), $scope.dtList1, $scope.segList1);
    //     var msg2 = $scope.fMsg(JSON.parse(msg2), $scope.dtList2, $scope.segList2)

    //     console.log(msg1);
    //     console.log(msg2);
    //     $scope.diff = ObjectDiff.diffOwnProperties(msg1, msg2);
    //     $scope.dataList = [];
    //     console.log($scope.diff);

    //     if ($scope.diff.changed === "object change") {
    //         var array = objToArray($scope.diff);
    //         var arraySeg = objToArray(array[1].segments.value);

    //         //writeTable(array[1].segments, 0, $scope.gridOptions.data);
    //         for (var i = 0; i < arraySeg.length; i++) {
    //             writettTable(arraySeg[i], $scope.dataList);
    //         }

    //     }

    //     $scope.loadingSelection = false;


    //     if ($scope.dynamic_params) {
    //         console.log($scope.dataList);
    //         $scope.showDelta = true;
    //         $scope.dynamic_params.refresh();
    //     }

    // };


    $scope.compare = function() {

        $scope.loadingSelection = true;
        $scope.msgChanged = false;
        $scope.formatMsg(JSON.parse($scope.msg1)).then(function(msg1) {


            $scope.formatMsg(JSON.parse($scope.msg2)).then(function(msg2) {
                console.log(JSON.parse($scope.msg1));
                console.log(JSON.parse($scope.msg2));

                $scope.diff = ObjectDiff.diffOwnProperties(msg1, msg2);
                console.log($scope.diff);
                $scope.dataList = [];
                if ($scope.diff.changed === "object change") {
                    var array = objToArray($scope.diff);
                    var arraySeg = objToArray(array[1].segments.value);

                    //writeTable(array[1].segments, 0, $scope.gridOptions.data);
                    for (var i = 0; i < arraySeg.length; i++) {
                        writettTable(arraySeg[i], $scope.dataList);
                    }

                }

                $scope.loadingSelection = false;


                if ($scope.dynamic_params) {
                    console.log($scope.dataList);
                    $scope.showDelta = true;
                    $scope.dynamic_params.refresh();
                }
            });

        });

    };








});
angular.module('igl').controller('ListCompositeMessageCtrl', function($scope, $rootScope, $http, CompositeMessageService) {




    $scope.save = function() {
        $scope.saving = true;
        var message = $rootScope.compositeMessage;
        CompositeMessageService.save(message).then(function(result) {
            $rootScope.compositeMessage.dateUpdated = result.dateUpdated;
            $rootScope.compositeMessage = result;
            $rootScope.$emit("event:updateIgDate");
            var index = findIndex(message.id);
            $rootScope.igdocument.profile.compositeMessages.children[index] = result


            if (index < 0) {
                $rootScope.igdocument.profile.compositeMessages.children.splice(0, 0, message);
            }
            cleanState();


        }, function(error) {
            $rootScope.msg().text = error.data.text;
            $rootScope.msg().type = error.data.type;
            $rootScope.msg().show = true;
        });
    };
    var findIndex = function(id) {
        for (var i = 0; i < $rootScope.igdocument.profile.compositeMessages.children.length; i++) {
            if ($rootScope.igdocument.profile.compositeMessages.children[i].id === id) {
                return i;
            }
        }
        return -1;
    };
    var cleanState = function() {

        $scope.clearDirty();
        $scope.editForm.$setPristine();
        $scope.editForm.$dirty = false;
        $rootScope.clearChanges();
        if ($scope.compositeMessageParams) {
            $scope.compositeMessageParams.refresh();
        }
    };

});
/**
 * Created by Jungyub on 4/01/15.
 */

angular.module('igl').controller('ConstraintsListCtrl',function($scope, $rootScope, Restangular, $filter) {
	$scope.loading = false;
	$scope.tmpSegmentPredicates = [].concat($rootScope.segmentPredicates);
	$scope.tmpSegmentConformanceStatements = [].concat($rootScope.segmentConformanceStatements);
	$scope.tmpDatatypePredicates = [].concat($rootScope.datatypePredicates);
	$scope.tmpDatatypeConformanceStatements = [].concat($rootScope.datatypeConformanceStatements);
	 
	
	
	$scope.init = function() {
	};
	
});
/**
 * http://usejsdoc.org/
 */
angular.module('igl').controller('DatatypeLibraryCtl',
    function($scope, $http, $rootScope, $q, $modal, $timeout, TableService, ngTreetableParams, DatatypeLibraryDocumentSvc, TableLibrarySvc, DatatypeService, DatatypeLibrarySvc,IGDocumentSvc, TableService, ViewSettings, userInfoService, blockUI,CompareService,VersionAndUseService) {
        //  $scope.initLibrary();
        $rootScope.filteringModeON = false;
        $scope.ttype="USER";
       // $rootScope.config = { "usages": ["R", "B", "RE", "C", "W", "X", "O"], "codeUsages": ["P", "R", "E"], "codeSources": ["HL7", "Local", "Redefined", "SDO"], "tableStabilities": ["Dynamic", "Static"], "tableExtensibilities": ["Close", "Open"], "constraintVerbs": ["SHALL be", "SHALL NOT be", "is", "is not"], "constraintTypes": ["valued", "one of list values", "formatted value", "a literal value", "identical to the another node"], "predefinedFormats": ["YYYYMMDDhhmmss.sss", "ISO-compliant OID", "YYYYMMDDhhmm+-ZZZZ", "YYYYMMDDhh", "YYYY+-ZZZZ", "YYYY", "YYYYMMDDhhmm", "YYYYMM", "YYYYMMDDhhmmss+-ZZZZ", "Alphanumeric", "YYYYMM+-ZZZZ", "YYYYMMDDhhmmss", "YYYYMMDD+-ZZZZ", "YYYYMMDDhh+-ZZZZ", "YYYYMMDDhhmmss.sss+-ZZZZ", "YYYYMMDD"], "statuses": ["Draft", "Active", "Withdrawn", "Superceded"], "domainVersions": ["2.0", "2.1", "2.2", "2.3", "2.4", "2.5", "2.5.1", "2.6", "2.7", "2.3.1", "2.8"], "schemaVersions": ["1.0", "2.0", "1.5", "2.5"] }
        $rootScope.igdocument = null; // current igdocument
        $rootScope.message = null; // current message
        $rootScope.datatype = null; // current datatype
        $scope.accountId = userInfoService.getAccountID().toString();
        $rootScope.pages = ['list', 'edit', 'read'];
        $rootScope.context = { page: $rootScope.pages[0] };
        $rootScope.messagesMap = {}; // Map for Message;key:id, value:object
        $rootScope.segmentsMap = {}; // Map for Segment;key:id, value:object
        $rootScope.datatypesMap = {}; // Map for Datatype; key:id, value:object
        $rootScope.tablesMap = {}; // Map for tables; key:id, value:object
        $rootScope.segments = []; // list of segments of the selected messages
        $rootScope.datatypes = []; // list of datatypes of the selected messages
        $rootScope.segmentPredicates = [];
        $scope.linksForData = [];
        $rootScope.linksForTables = [];
        $scope.AllUnchanged=[];
        $scope.tabs = [{active: true}, {active: false}, {active: false}];
        // list of segment level predicates of
        $rootScope.segmentConformanceStatements = []; // list of segment level

        $rootScope.datatypePredicates = []; // list of segment level predicates of
        $rootScope.datatypeConformanceStatements = []; // list of segment level
        // Conformance Statements of
        // the selected messages
        $rootScope.tables = [];
        $rootScope.postfixCloneTable = 'CA';
        $rootScope.newCodeFakeId = 0;
        $rootScope.newTableFakeId = 0;
        $rootScope.newPredicateFakeId = 0;
        $rootScope.newConformanceStatementFakeId = 0;
        $rootScope.segment = null;
        $rootScope.messagesData = [];
        $rootScope.messages = []; // list of messages
        $rootScope.customIgs = [];
        $rootScope.preloadedIgs = [];
        $rootScope.changes = {};
        $rootScope.generalInfo = { type: null, 'message': null };
        $rootScope.references = []; // collection of element referencing a datatype
        $rootScope.tmpReferences = [];
        $rootScope.section = {};
        $rootScope.conformanceStatementIdList = [];
        $rootScope.parentsMap = {};
        $rootScope.igChanged = false;
        $scope.selectedDT = null;
        $rootScope.messageTree = null;
        $scope.scrollbarWidth = 0;
        $scope.datatypeLibsStruct = [];
        $scope.editableDTInLib = '';
        $scope.editableVS = '';
        $scope.derivedDatatypes = [];
        $rootScope.tables = [];
        $scope.toShow === "";
        $rootScope.datatypesMap = {};
        $scope.tablesMap = {};
        $scope.tablesIds = [];
        $rootScope.datatypeLibrary = null;
        $scope.datatypeLibMetaDataCopy = null;
        $scope.datatypeStruct = null;
        $rootScope.datatype=null;
        $scope.loadingSelection = true;
        $scope.publishSelections = [];
        $scope.datatypeDisplay = [];
        $scope.selectedChildren = [];
        $scope.viewSettings = ViewSettings;
        $scope.subview = null;
        $scope.datatypeListView = null;
        $scope.added = [];
        $scope.accordi = { metaData: false, definition: true, dtList: true, dtDetails: false };
        $rootScope.DTLibList = true;
        $rootScope.DTLibDetails = false;
        //      $scope.forms.datatypeForm = {};
        $scope.tableWidth = null;
        // $rootScope.datatypeLibrary = "";
        $scope.hl7Version = null;
        $scope.scopes = [];
        $scope.tableCollapsed = false;
        $scope.datatypeLibrariesConfig = {};
        $scope.AllUnchanged=[];
        //$scope.accountId =userInfoService.accountId;

        $rootScope.readOnly = false;
        $scope.$on('event:openDatatypeInLib', function(event, datatype) {

            $scope.selectDatatype(datatype); // Should we open in a dialog ??
        });

        $scope.$on('event:openTable', function(event, table) {
            $scope.selectTable(table); // Should we open in a dialog ??
        });

        $scope.addingView = 'addingView.html';

        $scope.toggle = function(param) {
            $scope.toShow = param;

        }

    	$scope.vrs=["#","2.1","2.2","2.3","2.3.1","2.4","2.5","2.5.1","2.6","2.7","2.7.1","2.8","2.8.1","2.8.2"];
    	$scope.adjusted=["21","22","23","231","24","25","251","26","27","271","28","281","282"];
    	
    	$scope.initMatrix=function(){
    		
    		blockUI.start();
    	DatatypeLibraryDocumentSvc.getMatrix().then(function(result){
    		
    		$scope.matrix= result;
    		blockUI.stop();
    	});
    	}
    	$scope.make_active = function(x) {
    		
    		for(i=0; i<$scope.tabs.length;i++){
    			if(i==x){
    				$scope.tabs[i].active = true;
    			}else{
    				$scope.tabs[i].active=false;
    			}
    		}
    	    
    	};
    	$scope.getColor= function(index){
    		if(index===undefined){
    			return "";
    		}else if(index===0){
    			return "#008B8B";
    		}else if (index ===1){
    			return "#B8860B";
    		}else if (index ===2){
    			return "#6495ED";
    		}else if (index ===3){
    			return "#9932CC";
    		}else if (index ===4){
    			return "#8FBC8F";
    		}else if (index ===5){
    			return "#2F4F4F";
    		}else if (index ===6){
    			return "#FF1493";
    		}else if (index ===7){
    			return "#FFD700";
    		}else if (index ===8){
    			return "#4B0082";
    		}else if (index ===9){
    			return "#FFB6C1";
    		}else if (index ===10){
    			return "#778899";
    		}
    	}
    	$scope.isSelected1=function(dt,version){
    		return $scope.selectedRow===dt&& $scope.selectedVersion1===version ;

    	}
    	$scope.isSelected2=function(dt, version){
    		return $scope.selectedRow===dt&& $scope.selectedVersion2===version ;
    	}

    	$scope.selectedVersion1=null;
    	$scope.selectedVersion2=null;
    	$scope.selectCell=function(dt,version){
    		var vr=version.split('.').join("");

    		console.log(version);
    		console.log(vr);
    		console.log(dt.links);
    		if(dt.links[vr]!==undefined){
    			$scope.selectCellAfterCheck(dt,version);
    		}else{
    			console.log("no version");
    		}

    	}

    	$scope.selectCellAfterCheck=function(dt,version){
    	if($scope.selectedRow && dt===$scope.selectedRow){
    		if($scope.selectedVersion1!==null){
    			if($scope.selectedVersion1&&$scope.selectedVersion1=== version){
    				$scope.selectedVersion1=null;
    				}else if($scope.selectedVersion2!==null &&$scope.selectedVersion2=== version){
    					$scope.selectedVersion2=null;
    				}else{
    					$scope.selectedVersion2=version;
    				}
    			}else{
    				$scope.selectedVersion1=version;
    			}

    	}else if($scope.selectedRow && dt!==$scope.selectedRow ||!$scope.selectedRow){
    		$scope.selectedRow=dt;
    		$scope.selectedVersion2=null;
    		$scope.selectedVersion1=version;
    	}

    		if($scope.selectedRow !==null &&$scope.selectedVersion2!==null &&$scope.selectedVersion1!==null ){

        		var versions1=[];
        		versions1.push($scope.selectedVersion1);
        		var versions2=[];
        		versions2.push($scope.selectedVersion2);

              DatatypeService.getOneStandard($scope.selectedRow.name, $scope.selectedVersion1,versions1).then(function(result1) {
            	$scope.cmp1=result1;
            	console.log("Found the first One")
            	console.log($scope.cmp1);
                DatatypeService.getOneStandard($scope.selectedRow.name, $scope.selectedVersion2,versions2).then(function(result2) {
                	$scope.cmp2=result2;
                	console.log("Found the secont One")
                	console.log($scope.cmp2);

                    $scope.loadingSelection = true;
                    $scope.dtChanged = false;
                    $scope.vsTemplate = false;
                    $scope.dataList = CompareService.cmpDatatype(JSON.stringify($scope.cmp1), JSON.stringify($scope.cmp2), [], [], [], []);
                 
                    
                    $scope.loadingSelection = false;
                    if ($scope.dynamicDt_params) {
                        console.log($scope.dataList);
                        $scope.showDelta = true;
                        $scope.dynamicDt_params.refresh();
                    }
                });
            });


    		}
    	}

        $scope.datatypeSource = null;
        $scope.tableSource = null;

        $scope.collapseTables = function() {
            $scope.tableCollapsed = !$scope.tableCollapsed;

        }
        $scope.selectDTLibTab = function(value) {
            if (value === 1) {
                $rootScope.DTLibList = false;
                $rootScope.DTLibDetails = true;
                $scope.evolution=false;
            } else if(value===0) {
                $rootScope.DTLibList = true;
                $rootScope.DTLibDetails = false;
                $scope.evolution=false;
            }else{
            	$scope.evolution=true;
            	 $rootScope.DTLibList = false;
                 $rootScope.DTLibDetails = false;
            }
        };

        $scope.seq = function(idx) {
            return idx + 1;
        };

        $scope.getDatatypes = function(datatypeLibrary) {
            $scope.datatypeListView = "DatatypeList.html";
            $scope.loadingSelection = true;
            $timeout(
                function() {
                    $scope.loadingSelection = false;
                }, 100);
        };

        $scope.getDataTypeLibraryByScope = function(scope) {
            $scope.ttype=scope;
            $scope.datatypeLibsStruct = [];
            DatatypeLibraryDocumentSvc.getDataTypeLibraryDocumentByScope(scope).then(function(data) {
                $scope.datatypeLibsStruct = [];
                angular.forEach(data.data, function(lib) {
                    $scope.datatypeLibsStruct.push(lib);
                });
                //$scope.datatypeLibsStruct=data.data;
                console.log($scope.datatypeLibsStruct);
                $rootScope.isEditing = false;
                $scope.DataTypeTree = [];
                $scope.datatypeLibCopy = {};
                //console.log("$scope.datatypeLibsStruct size=" + $scope.datatypeLibsStruct.length);
            }).catch(function(error) {
                //console.log(error);
            });
        };

        $scope.saveMetaDataOfLibrary = function() {
            $rootScope.datatypeLibrary.metaData = angular.copy($scope.datatypeLibMetaDataCopy);

            DatatypeLibrarySvc.saveMetaData($rootScope.datatypeLibrary.id, $scope.datatypeLibMetaDataCopy).then(function(metaData){

                     $scope.editForm.$dirty = false;

                $rootScope.clearChanges();
                console.log("called");
            });
            //$scope.clearDirty();


        };
        $scope.initForm=function(){
        	$scope.editForm={$dirty:false,
        			$invalid:false};
        }
        $scope.resetMetaDataOfLibrary = function() {

            $scope.datatypeLibMetaDataCopy = angular.copy($rootScope.datatypeLibrary.metaData);

            $scope.DataTypeTree[0].metaData = $scope.datatypeLibMetaDataCopy;
            $rootScope.clearChanges();
        };

        $scope.editMetadata = function() {

            $scope.datatypeLibMetaDataCopy = $scope.DataTypeTree[0].metaData;
            $rootScope.currentData= $scope.datatypeLibMetaDataCopy;
            console.log($scope.datatypeLibMetaDataCopy);
           // $rootScope.$emit("event:initEditArea");

            $scope.subview = "LibraryMetaData.html";

        }

        $scope.exportAs = function(dataTypeLibraryDocumentId,format){
            DatatypeLibraryDocumentSvc.exportAs(dataTypeLibraryDocumentId,format);
        }

        $scope.editLibrary = function(datatypeLibraryDocument, readOnly) {
        	blockUI.start();
        	$timeout(function () {
        	$rootScope.libraryDoc= datatypeLibraryDocument;
            $rootScope.accountId=datatypeLibraryDocument.accountId;
        	$scope.viewSettings.setTableReadonly(readOnly);
        	$rootScope.ext=datatypeLibraryDocument.metaData.ext;

            $rootScope.tables = [];
            $scope.tablesIds = [];
            $rootScope.datatypeLibrary = datatypeLibraryDocument.datatypeLibrary;
            $rootScope.datatypeLibrary = datatypeLibraryDocument.datatypeLibrary;
            $scope.datatypesIds = [];
            angular.forEach($rootScope.datatypeLibrary.children, function(datatypeLink) {
                $scope.datatypesIds.push(datatypeLink.id);
            });

            $scope.tableLibrary = datatypeLibraryDocument.tableLibrary;
            $rootScope.tableLibrary = datatypeLibraryDocument.tableLibrary;
            angular.forEach($scope.tableLibrary.children, function(table) {
                $scope.tablesIds.push(table.id);
            });

            $scope.subview = "LibraryMetaData.html";
            $scope.addedDatatypes = [];
            $scope.datataypestoAdd = [];
            $rootScope.libEXT = $rootScope.datatypeLibrary.metaData.ext;

            var scopes = ['HL7STANDARD'];

            $scope.loadingSelection = true;
            //$rootScope.isEditing = true;
           // $scope.hl7Version = $rootScope.datatypeLibrary.metaData.hl7Version;
            $rootScope.datatypeLibraryId = $rootScope.datatypeLibrary.id;
            $scope.datatypeLibMetaDataCopy = angular.copy(datatypeLibraryDocument.metaData);
            $rootScope.currentData= $scope.datatypeLibMetaDataCopy;
            $scope.loadingSelection = false;
            $scope.DataTypeTree = [];
            $scope.datatypeLibCopy = angular.copy($rootScope.datatypeLibrary);
            $scope.datatypeLibCopy.children = [];
            $rootScope.readOnly = readOnly;

            if (!readOnly) {
                $scope.datatypeListView = "DatatypeList.html";
            } else {
                $scope.datatypeListView = "DatatypeListReadOnly.html";
            }
            $rootScope.datatype=null;
            $rootScope.filteringModeON = false;
            $rootScope.initMaps();
            $scope.make_active(1);
            //DTLibDetails=true;
            $rootScope.datatypes = [];
            $rootScope.datatypesMap = {};
            $rootScope.tablesMap = {};
            $rootScope.igdocument = null;
            $scope.DataTypeTree.push($scope.datatypeLibCopy);
            $rootScope.$emit("event:initEditArea");

                    DatatypeLibraryDocumentSvc.getAllDatatypesNames().then(function(res) {
                        $scope.AllUnchanged = res;
                        $scope.loadVersionAndUseInfo().then(function(){
                            $scope.loadDatatypes().then(function() {
            		                $scope.loadTables().then(function() {
            		                	$scope.make_active(1);
            		                	blockUI.stop();
                        }, function() {});
            	    })
            }, function() {});
                 });
        	 }, function () {
        		 
        	 });

        };


//        $scope.startCallback = function(event, ui, title) {
//            $scope.draged = title;
//        };
//        $scope.dropCallback = function(event, ui) {
//            var index = $scope.addedDatatypes.indexOf($scope.draged);
//            if (index > -1) {
//                $scope.addedDatatypes.splice(index, 1);
//            }
//            $scope.addedItem = angular.copy($scope.draged);
//            var randext = $scope.datatypeLibMetaDataCopy.ext + Math.floor(Math.random() * 100);
//            $scope.addedItem.id = new ObjectId().toString();
//            $scope.addedItem.ext = randext;
//            $scope.addedItem.scope = 'MASTER';
//            $scope.addedItem.status = 'UNPUBLISHED';
//            $scope.addedItem.libIds = [];
//            $scope.addedItem.libIds.push($rootScope.datatypeLibrary.id);
//            $scope.addedDatatypes.push($scope.addedItem);
//        };
//


       $rootScope.getDerived = function(element) {
            try {
                if (element && element.type && element.type === "datatype") {

                    angular.forEach(element.components, function(component) {
                        $rootScope.getDerived(component);
                    });
                } else if (element && element.type && element.type === "component") {

                    if (element.tables&&element.tables != null) {
                    	angular.forEach(element.tables, function(table){
                            $rootScope.linksForTables.push(table);

                    	});


                    }
                    if (element.datatype !== null || element.datatype !== undefined) {
                        var newLink = angular.fromJson({
                            id: element.datatype.id,
                            name: element.datatype.name,
                            ext: element.datatype.ext
                        });

                        $scope.getDatatypeById(element.datatype.id).then(function(result) {

                            DatatypeLibrarySvc.addChild($rootScope.datatypeLibrary.id, newLink).then(function(link) {
                                if (!$rootScope.datatypesMap[element.datatype.id] || $rootScope.datatypesMap[element.datatype.id] === undefined) {
                                    $rootScope.datatypes.push(result);
                                    $rootScope.datatypesMap[element.datatype.id] = result;
                                    $rootScope.getDerived(result);


                                }

                            }, function(error) {
                                $rootScope.saving = false;
                                $rootScope.msg().text = error.data.text;
                                $rootScope.msg().type = error.data.type;
                                $rootScope.msg().show = true;
                            });

                        });
                    }

                }

            } catch (e) {
                throw e;
            }

        };

        $scope.hasUnpublishedCopy= function(dt){
        	var res= false;

        	angular.forEach($rootScope.datatypes, function(datatype){
        		if(datatype.versionInfo&&datatype.versionInfo.sourceId&&datatype.versionInfo.sourceId&&datatype.versionInfo.sourceId===dt.id){
        			return true;
        		}
        	});
        	return res;
        }
        $scope.addDatatypeForUser = function(hl7Version) {
            var scopes = ['HL7STANDARD'];

            DatatypeService.getDataTypesByScopesAndVersion(scopes, $scope.hl7Version).then(function(datatypes) {
                DatatypeLibrarySvc.getDataTypeLibraryByScope('MASTER').then(function(masterLib) {
                    DatatypeLibrarySvc.getDataTypeLibraryByScope('USER').then(function(userDtLib) {
                    	var dtlibs=[];
                    	angular.forEach(userDtLib, function(dtLib){
                    		if(dtLib.id!==$rootScope.datatypeLibrary.id){
                    			dtlibs.push(dtLib);
                    		}
                    	});
                    	console.log(dtlibs);
                        console.log("userDtLib");
                        console.log(userDtLib);

                        console.log("addDatatype scopes=" + scopes.length);
                        var addDatatypeInstance = $modal.open({
                            templateUrl: 'AddHL7Datatype.html',
                            controller: 'AddDatatypeCtrl',
                            size: 'lg',
                            windowClass: 'addDatatype',
                            resolve: {
                                hl7Version: function() {
                                    return $scope.hl7Version;
                                },
                                datatypes: function() {

                                    return datatypes;
                                },
                                masterLib: function() {

                                    return masterLib;
                                },
                                userDtLib: function() {
                                    return dtlibs;
                                },
                                datatypeLibrary: function(){
                                	return $rootScope.datatypeLibrary;
                                },
                                tableLibrary :function(){
                                	return $rootScope.tableLibrary;
                                },
                                versionAndUseMap:function(){
                                	return $rootScope.versionAndUseMap;
                                }

                            }
                        }).result.then(function(results) {
                            var ids = [];
                            angular.forEach(results, function(result) {
                                ids.push(result.id);
                            });
                        });
                    });
                });
            });
        };

        $scope.addMasterDt = function() {
            var scopes = ['HL7STANDARD'];
                        var addDatatypeInstance = $modal.open({
                            templateUrl: 'createMasterDt.html',
                            controller: 'AddMasterDtCtrl',
                            size: 'lg',
                            windowClass: 'addDatatype',
                            resolve: {
                                datatypes: function() {

                                    return $rootScope.datatypes;
                                },
                               AllUnchanged: function() {

                                    return $scope.AllUnchanged;
                                },
                                datatypeLibrary: function(){
                                	return $rootScope.datatypeLibrary;
                                },
                                tableLibrary :function(){
                                	return $scope.tableLibrary;
                                }
                            }
                        }).result.then(function(results) {
                        	console.log(results);
                        	$scope.submit(results);
                            });
        };



        $scope.dynamicDt_params = new ngTreetableParams({
            getNodes: function(parent) {
                if ($scope.dataList !== undefined) {

                    //return parent ? parent.fields : $scope.test;
                    if (parent) {
                        if (parent.fields) {
                            return parent.fields;
                        } else if (parent.components) {
                            return parent.components;
                        } else if (parent.segments) {
                            return parent.segments;
                        } else if (parent.codes) {
                            return parent.codes;
                        }

                    } else {
                        return $scope.dataList;
                    }

                }
            },
            getTemplate: function(node) {
                return 'tree_node';
            }
        });
        $scope.cmpDatatype = function(datatype1, datatype2) {

            $scope.loadingSelection = true;
            $scope.dtChanged = false;
            $scope.vsTemplate = false;
            $scope.dataList = CompareService.cmpDatatype(JSON.stringify(datatype1), JSON.stringify(datatype2), $scope.dtList1, $scope.dtList2, $scope.segList1, $scope.segList2);
            console.log("hg==========");
            console.log($scope.dataList);
            $scope.loadingSelection = false;
            if ($scope.dynamicDt_params) {
                console.log($scope.dataList);
                $scope.showDelta = true;
                $scope.status.isSecondOpen = true;
                $scope.dynamicDt_params.refresh();
            }

        };

        $scope.selectOneToAdd = function(data) {
            if (data.clone) {

                $scope.addedItem = angular.copy(data);
                //var randext = $scope.datatypeLibMetaDataCopy.ext + Math.floor(Math.random() * 100);
                //$scope.addedItem.id = new ObjectId().toString();
                //$scope.addedItem.ext = randext;
                //$scope.addedItem.scope = 'MASTER';
                //$scope.addedItem.status = 'UNPUBLISHED';
                $scope.addedItem.libIds = [];
                $scope.addedItem.libIds.push($rootScope.datatypeLibrary.id);
                $scope.addedDatatypes.push($scope.addedItem);
                data.clone = false;

            }
            if (data.flavor) {
                $scope.addedItem = angular.copy(data);
                var randext = $scope.datatypeLibMetaDataCopy.ext + Math.floor(Math.random() * 100);
                $scope.addedItem.id = new ObjectId().toString();
                $scope.addedItem.ext = randext;
                $scope.addedItem.scope = $rootScope.datatypeLibrary.scope;
                $scope.addedItem.status = 'UNPUBLISHED';
                $scope.addedItem.libIds = [];
                $scope.addedItem.libIds.push($rootScope.datatypeLibrary.id);
                $scope.addedDatatypes.push($scope.addedItem);
                data.flavor = false;
            }
        };

        $scope.AddAsFlavor = function(data) {


            $scope.addedItem = angular.copy(data);
            var randext = $scope.datatypeLibMetaDataCopy.ext + Math.floor(Math.random() * 100);
            $scope.addedItem.id = new ObjectId().toString();
            $scope.addedItem.ext = randext;
            $scope.addedItem.scope = $rootScope.datatypeLibrary.scope;
            $scope.addedItem.status = 'UNPUBLISHED';
            $scope.addedItem.libIds = [];
            $scope.addedItem.libIds.push($rootScope.datatypeLibrary.id);
            $scope.addedDatatypes.push($scope.addedItem);


        };

        $scope.AddAsIs = function(data) {
            $scope.miniDTMap[data.id] = data;
            $scope.addedItem = data;
            $scope.addedItem.libIds = [];
            $scope.addedItem.libIds.push($rootScope.datatypeLibrary.id);
            $scope.addedDatatypes.push($scope.addedItem);

        };

        $scope.submit = function(addedDatatype) {
        	$scope.addedDatatypes=addedDatatype;
        	$rootScope.clearChanges();
            $scope.linksForData = [];
            $rootScope.linksForTables = [];
            angular.forEach($scope.addedDatatypes, function(data) {
                $scope.LinksForSubmit(data);
                if (data.status !== "PUBLISHED") {
                    DatatypeService.save(data).then(function(res) {
                    });
                }
            });

            angular.forEach($scope.addedDatatypes, function(datatype) {

                var newLink = {};
                newLink = angular.fromJson({
                    id: datatype.id,
                    name: datatype.name,
                    ext: datatype.ext
                });
                $scope.linksForData.push(newLink);
            });
            $rootScope.datatypeLibrary.children = _.union($rootScope.datatypeLibrary.children, $scope.linksForData);
            $rootScope.tableLibrary.children = _.union($scope.tableLibrary.children, $rootScope.linksForTables);
            $rootScope.tablesMap = {};
            $rootScope.datatypesMap = {};
            $scope.addedDatatypes=[];
            DatatypeLibrarySvc.addChildren($rootScope.datatypeLibrary.id, $scope.linksForData).then(function(results) {
                TableLibrarySvc.addChildren($rootScope.tableLibrary.id, $rootScope.linksForTables).then(function(tables) {
                    $scope.loadDatatypes().then(function() {

                        $scope.loadTables().then(function() {

                        }, function() {});
                    }, function() {});
                });
            });

        };



        $scope.submitAdded = function() {
            var delay = $q.defer();
            var promises = [];
            angular.forEach($scope.addedDatatypes, function(datatype) {
                promises.push($scope.submitAsynch(datatype));
            });
            console.log("promises");
            console.log(promises);
            console.log("My datatypeLoibrary ");
            console.log($rootScope.datatypeLibrary);
            $scope.addedDatatypes = [];
            $q.all(promises).then(function(fields) {
                delay.resolve(fields);
            });
            return delay.promise;

        };


        $scope.submit1 = function() {
            $scope.submitAdded().then(function(result) {
                console.log("result");
                console.log(result);
                $scope.miniDTMap = [];
            });

        };




        $scope.LinksForSubmit = function(element) {

            if (element && element.type && element.type === "datatype") {

                angular.forEach(element.components, function(component) {
                    $scope.LinksForSubmit(component);
                });


            } else if (element && element.type && element.type === "component") {

                if (element.tables&& element.tables != null) {
                	angular.forEach(element.tables, function(table){
                		 var tmp = [];
                         tmp.push(table);

                         $rootScope.linksForTables = _.union($rootScope.linksForTables, tmp);
                	});

                }
                if (element.datatype !== null || element.datatype !== undefined) {


                    var index = $scope.linksForData.indexOf(element.datatype);
                    if (index < 0) {
                        $scope.linksForData.push(element.datatype);

                        $scope.getDatatypeById(element.datatype.id).then(function(result) {

                            $scope.LinksForSubmit(result);

                        });

                    }


                }

            }
        };

        $scope.publishDatatype = function(datatype) {

            $scope.containUnpublished = false;
            $scope.unpublishedTables = [];
            $scope.unpublishedDatatypes = [];
            $scope.ContainUnpublished(datatype);

            if ($scope.containUnpublished) {
                $scope.abortPublish(datatype);
                datatype.status = "UNPUBLISHED";
            } else {
                $scope.confirmPublish(datatype);

            }
        };


        $scope.getFilteredTables = function(element) {

            try {
                if (element && element.type && element.type === "datatype") {

                    angular.forEach(element.components, function(component) {
                        $scope.getFilteredTables(component);
                    });
                } else if (element && element.type && element.type === "component") {

                    if (element.tables&&element.tables != null) {
                    	angular.forEach(element.tables, function(table){

                            var index = $rootScope.tables.indexOf($rootScope.tablesMap[table.id]);
                            if (index < 0) {

                                console.log("Adding the table");
                                console.log(element);
                                console.log($rootScope.tablesMap[table.id]);
                                $rootScope.tables.push($rootScope.tablesMap[table.id]);
                            }

                    	});
                    }
                    if (element.datatype !== null || element.datatype !== undefined) {

                        $scope.getFilteredTables($rootScope.datatypesMap[element.datatype.id]);

                    }

                }

            } catch (e) {
                throw e;
            }

        };

                $rootScope.getDerived = function(element) {
            try {
                if (element && element.type && element.type === "datatype") {

                    angular.forEach(element.components, function(component) {
                        $rootScope.getDerived(component);
                    });
                } else if (element && element.type && element.type === "component") {

                    if (element.tables&&element.tables != null) {
                    	angular.forEach(element.tables, function(table){
                            $rootScope.linksForTables.push(table);

                    	});


                    }
                    if (element.datatype !== null || element.datatype !== undefined) {
                        var newLink = angular.fromJson({
                            id: element.datatype.id,
                            name: element.datatype.name,
                            ext: element.datatype.ext
                        });

                        $rootScope.getDatatypeById(element.datatype.id).then(function(result) {

                            DatatypeLibrarySvc.addChild($rootScope.datatypeLibrary.id, newLink).then(function(link) {
                                if (!$rootScope.datatypesMap[element.datatype.id] || $rootScope.datatypesMap[element.datatype.id] === undefined) {
                                    $rootScope.datatypes.push(result);
                                    $rootScope.datatypesMap[element.datatype.id] = result;
                                    $rootScope.getDerived(result);


                                }

                            }, function(error) {
                                $rootScope.saving = false;
                                $rootScope.msg().text = error.data.text;
                                $rootScope.msg().type = error.data.type;
                                $rootScope.msg().show = true;
                            });

                        });
                    }

                }

            } catch (e) {
                throw e;
            }

        };

        $scope.filterByDatatype = function(datatype) {
            $rootScope.filteringModeON = true;

            // $scope.tablesIds = [];
            $rootScope.tables = [];
            $scope.getFilteredTables(datatype);
        };

        $scope.deleteValueSetINLIB = function(table) {
            $rootScope.references = [];
            console.log($rootScope.datatypes);
            angular.forEach($rootScope.datatypes, function(dt) {
                console.log("=======================dddddd")
                console.log(dt);
                console.log($rootScope.getDatatypeLabel(dt));
                $rootScope.findTableRefsINLIB(table, dt, $rootScope.getDatatypeLabel(dt));
            });
            console.log($rootScope.references);
            if ($rootScope.references != null && $rootScope.references.length > 0) {
                abortValueSetDelete(table);
            } else {
                confirmValueSetDelete(table);
            }
        }

        function abortValueSetDelete(table) {
            var modalInstance = $modal.open({
                templateUrl: 'ValueSetReferencesCtrl.html',
                controller: 'ValueSetReferencesCtrl',
                resolve: {
                    tableToDelete: function() {
                        return table;
                    }
                }
            });
            modalInstance.result.then(function(table) {
                // $rootScope.tableToDelete = table;
            }, function() {});
        };

        function confirmValueSetDelete(table) {
            var modalInstance = $modal.open({
                templateUrl: 'ConfirmValueSetDeleteCtrl.html',
                controller: 'ConfirmTablesDeleteCtl',
                resolve: {
                    tableToDelete: function() {
                        return table;
                    }
                }
            });
            modalInstance.result.then(function(table) {
                //                tableToDelete = table;
                var newLink = {};
                newLink.bindingIdentifier = table.bindingIdentifier;
                newLink.id = table.id;
                if ($rootScope.tables && $rootScope.tables != null) {
                    console.log("dddddddddddddddddddddd");
                    console.log(table);
                    var index = $rootScope.tables.indexOf(table);
                    if (index >= 0)
                        $rootScope.tables.splice(index, 1);
                }

                TableLibrarySvc.deleteChild($scope.tableLibrary.id, newLink.id).then(function(link) {
                    console.log("table deleted");

                }, function(error) {
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
            }, function() {});
        };


        $scope.addDatatypetoLibrary = function(datatype) {
            var newLink = angular.fromJson({
                id: datatype.id,
                name: datatype.name,
                ext: datatype.ext
            });
            $rootScope.datatypeLibrary.children.push(newLink);
            DatatypeService.save(datatype).then(function(result) {
                DatatypeLibrarySvc.addChild($rootScope.datatypeLibrary.id, newLink).then(function(link) {}, function(error) {
                    $rootScope.saving = false;
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
            }, function(error) {
                $rootScope.saving = false;
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        }

        $scope.addHL7DatatypetoLibrary = function(datatype) {
            var newLink = angular.fromJson({
                id: datatype.id,
                name: datatype.name,
                ext: datatype.ext
            });
            $rootScope.datatypeLibrary.children.push(newLink);

            DatatypeLibrarySvc.addChild($rootScope.datatypeLibrary.id, newLink).then(function(link) {}, function(error) {
                $rootScope.saving = false;
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        }

        $rootScope.findTableRefsINLIB = function(table, obj, path) {
            console.log(obj);
            if (obj && angular.equals(obj.type, 'component')) {

                if (obj.tables != undefined &&obj.tables!==null) {
                	angular.forEach(obj.tables,function(table1){
                		if (table1.id === table.id) {
                            var found = angular.copy(obj);
                            console.log(found);
                            found.path = path;
                            $rootScope.references.push(found);
                        }
                	});
                }
//                if (obj.datatype !== null) {
//                    console.log($rootScope.datatypesMap[obj.datatype.id]);
//                    $rootScope.findTableRefsINLIB(table, $rootScope.datatypesMap[obj.datatype.id], path);
//                }
            } else if (obj && angular.equals(obj.type, 'datatype')) {
                if (obj.components != undefined && obj.components != null && obj.components.length > 0) {
                    angular.forEach(obj.components, function(component) {
                        $rootScope.findTableRefsINLIB(table, component, path + "." + component.position);
                    });
                }
            }
        };

//
//        $scope.loadDatatypes = function() {
//            var delay = $q.defer();
//            $rootScope.datatypeLibrary.type = "datatypes";
//            var dtIds = [];
//            for (var i = 0; i < $rootScope.datatypeLibrary.children.length; i++) {
//                dtIds.push($rootScope.datatypeLibrary.children[i].id);
//                //console.log(0)
//            }
//            DatatypeService.get(dtIds).then(function(result) {
//                console.log("==========Adding Datatypes from their IDS============");
//                $rootScope.datatypes = result;
//                console.log(result);
//                angular.forEach(result, function(datatype) {
//                    $rootScope.datatypesMap[datatype.id] = datatype;
//                });
//                delay.resolve(true);
//
//            }, function(error) {
//                $rootScope.msg().text = "DatatypesLoadFailed";
//                $rootScope.msg().type = "danger";
//                $rootScope.msg().show = true;
//                delay.reject(false);
//
//            });
//            return delay.promise;
//        };

        $scope.loadDatatypes = function () {
            var delay = $q.defer();
            $rootScope.datatypeLibrary.type = "datatypes";
            DatatypeLibrarySvc.getDatatypesByLibrary($rootScope.datatypeLibrary.id).then(function (children) {
                $rootScope.datatypes = children;
                $rootScope.datatypesMap = {};
                angular.forEach(children, function (child) {
                    this[child.id] = child;
                }, $rootScope.datatypesMap);
                delay.resolve(true);
            }, function (error) {
                $rootScope.msg().text = "DatatypesLoadFailed";
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
                delay.reject(false);

            });
            return delay.promise;
        };
        $scope.loadVersionAndUseInfo = function() {
            var delay = $q.defer();
            var dtIds = [];
            for (var i = 0; i < $rootScope.datatypeLibrary.children.length; i++) {
                dtIds.push($rootScope.datatypeLibrary.children[i].id);
                //console.log(0)
            }
            VersionAndUseService.findAll().then(function(result) {

                console.log(result);
                angular.forEach(result, function(info) {
                    $rootScope.versionAndUseMap[info.id] = info;
                });
                delay.resolve(true);

            }, function(error) {
                $rootScope.msg().text = "DatatypesLoadFailed";
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
                delay.reject(false);

            });
            return delay.promise;
        };
//        $scope.loadTables = function() {
//            var delay = $q.defer();
//            //$scope.tableLibrary.type = "tables";
//            var tableIds = [];
//            console.log($scope.tableLibrary);
//            for (var i = 0; i < $scope.tableLibrary.children.length; i++) {
//                tableIds.push($scope.tableLibrary.children[i].id);
//            }
//
//
//            TableService.findAllByIds(tableIds).then(function(tables) {
//                $rootScope.tables = tables;
//                angular.forEach(tables, function(table) {
//                    $rootScope.tablesMap[table.id] = table;
//                });
//                console.log($rootScope.tablesMap);
//
//            }, function(error) {
//                $rootScope.msg().text = "TablesLoadFailed";
//                $rootScope.msg().type = "danger";
//                $rootScope.msg().show = true;
//                delay.reject(false);
//            });
//
//            return delay.promise;
//        };
        
        $scope.loadTables = function () {
            var delay = $q.defer();
            $rootScope.tableLibrary.type = "tables";




            TableLibrarySvc.getTablesByLibrary($rootScope.tableLibrary.id).then(function (children) {
                $rootScope.tables = children;
                $rootScope.tablesMap = {};
                angular.forEach(children, function (child) {
                    this[child.id] = child;
                }, $rootScope.tablesMap);
                delay.resolve(true);
            }, function (error) {
                $rootScope.msg().text = "TablesLoadFailed";
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
                delay.reject(false);
            });
            return delay.promise;

        };

        $scope.openRichTextDlg = function(obj, key, title, disabled) {
            var modalInstance = $modal.open({
                templateUrl: 'RichTextCtrlLIB.html',
                controller: 'RichTextCtrlLIB',
                windowClass: 'app-modal-window',
                backdrop: true,
                keyboard: true,
                backdropClick: false,
                resolve: {
                    editorTarget: function() {
                        return {
                            key: key,
                            obj: obj,
                            disabled: disabled,
                            title: title
                        };
                    }
                }
            });
        };
        $scope.addAllTables = function() {
            console.log($scope.tablesIds);
            var delay = $q.defer();
            TableService.findAllByIds($scope.tablesIds).then(function(tables) {
                angular.forEach(tables, function(child) {
                    this[child.id] = child;
                }, $scope.tablesMap);

                console.log($rootScope.tables)
                $rootScope.tables = tables;
                $scope.initialTables = angular.copy(tables);
                $rootScope.tables.forEach(function(table, i) {
                    var newLink = {};
                    newLink.bindingIdentifier = table.bindingIdentifier;
                    newLink.id = table.id;

                    TableLibrarySvc.addChild($scope.tableLibrary.id, newLink).then(function(link) {
                        $scope.tableLibrary.children.splice(0, 0, newLink);

                    }, function(error) {
                        $rootScope.msg().text = error.data.text;
                        $rootScope.msg().type = error.data.type;
                        $rootScope.msg().show = true;
                    });
                });

            }, function(error) {
                console.log(error);
                $rootScope.msg().text = "TablesLoadFailed";
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
                delay.reject(false);
            });
            return delay.promise;
        };

        $scope.addTables = function(igdocument) {
            var modalInstance = $modal.open({
                templateUrl: 'AddTableOpenCtrlLIB.html',
                controller: 'AddTableOpenCtrlLIB',
                windowClass: 'conformance-profiles-modal',
                resolve: {
                    tableLibrary: function() {
                        return $scope.tableLibrary;
                    },
                    derivedTables: function() {
                        return $rootScope.tables;
                    }
                }
            });
            modalInstance.result.then(function() {}, function() {});
        };


        $scope.addTable = function(tableLink) {
            var delay = $q.defer();

            var tableId = [];
            tableId.push(tableLink.id);
            TableService.getOne(tableLink.id).then(function(table) {


                if (!$rootScope.tablesMap[table.id] || $rootScope.tablesMap[table.id] === undefined) {

                    $rootScope.tables.push(table);
                    $rootScope.tablesMap[table.id] = table;
                    var newLink = {};
                    newLink.bindingIdentifier = table.bindingIdentifier;
                    newLink.id = table.id;

                    TableLibrarySvc.addChild($scope.tableLibrary.id, newLink).then(function(link) {
                        $scope.tableLibrary.children.splice(0, 0, newLink);
                    }, function(error) {
                        $rootScope.msg().text = error.data.text;
                        $rootScope.msg().type = error.data.type;
                        $rootScope.msg().show = true;
                    });

                }

            }, function(error) {
                console.log(error);
                $rootScope.msg().text = "TablesLoadFailed";
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
                delay.reject(false);
            });
            return delay.promise;
        };

        $scope.createNewExtension = function(ext) {
            if ($rootScope.datatypeLibrary != null) {
                var rand = (Math.floor(Math.random() * 10000000) + 1);
                if ($rootScope.datatypeLibrary.metaData.ext === null) {
                    return ext != null && ext != "" ? ext + "_" + rand : rand;
                } else {
                    return ext != null && ext != "" ? ext + "_" + $rootScope.datatypeLibrary.metaData.ext + "_" + rand + 1 : rand + 1;
                }
            } else {
                return null;
            }
        };
        $scope.copyTableINLIB = function(table) {
            var newTable = angular.copy(table);
            newTable.participants = [];
            newTable.scope = $scope.tableLibrary.scope;
            newTable.status = "UNPUBLISHED";
            newTable.id = null;
            newTable.libIds = [];
            newTable.bindingIdentifier = $scope.createNewExtension(table.bindingIdentifier);


            if (newTable.codes != undefined && newTable.codes != null && newTable.codes.length != 0) {
                for (var i = 0, len1 = newTable.codes.length; i < len1; i++) {
                    newTable.codes[i].id = new ObjectId().toString();
                }
            }

            TableService.save(newTable).then(function(result) {
                newTable = result;
                $scope.table = newTable;
                $scope.tablesMap[newTable.id] = newTable;
                console.log(result);
                $scope.tablesIds.push(result.id);
                var newLink = angular.copy(TableLibrarySvc.findOneChild(table.id, $scope.tableLibrary.children));
                newLink.bindingIdentifier = newTable.bindingIdentifier;
                newLink.id = newTable.id;

                TableLibrarySvc.addChild($scope.tableLibrary.id, newLink).then(function(link) {
                    $scope.tableLibrary.children.splice(0, 0, newLink);
                    $rootScope.tables.splice(0, 0, newTable);
                    $scope.table = newTable;
                    $scope.tablesMap[newTable.id] = newTable;

                    $scope.codeSystems = [];

                    for (var i = 0; i < $scope.table.codes.length; i++) {
                        if ($scope.codeSystems.indexOf($scope.table.codes[i].codeSystem) < 0) {
                            if ($scope.table.codes[i].codeSystem && $scope.table.codes[i].codeSystem !== '') {
                                //$scope.s.push($scope.table.codes[i].codeSystem);
                            }
                        }
                    }


                }, function(error) {
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });


            }, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        };

        $scope.redirectDTLIB = function(datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'ConfirmRedirect.html',
                controller: 'ConfirmRedirect',
                resolve: {
                    datatypeTo: function() {
                        return datatype;
                    }
                }
            });
            modalInstance.result.then(function(datatype) {
                DatatypeService.getOne(datatype.id).then(function(datatype) {
                	$rootScope.datatype = datatype;
                	$rootScope.editDatatype($scope.datatype);
                    $rootScope.ActiveModel=datatype;

                });
            });
        };
        $rootScope.getDatatypeById = function(id) {
            var delay = $q.defer();
            if ($rootScope.datatypesMap[id] === undefined || $rootScope.datatypesMap[id] === null) {
                $http.get('api/datatypes/' + id).then(function(response) {
                    var datatype = angular.fromJson(response.data);
                    //$rootScope.datatypesMap[id] = datatype;
                    delay.resolve(datatype);
                }, function(error) {
                    delay.reject(error);
                });
            } else {
                delay.resolve($rootScope.datatypesMap[id]);
            }
            return delay.promise;
        }



        $scope.addTablesInLibrary = function() {
            var modalInstance = $modal.open({
                templateUrl: 'AddTableOpenCtrl.html',
                controller: 'AddTableOpenCtrlLIB',
                windowClass: 'conformance-profiles-modal',
                resolve: {
                    igdocumentToSelect: function() {
                        return igdocument;
                    }
                }
            });
            modalInstance.result.then(function() {}, function() {});

        }
        $scope.backDT = function() {
            $scope.editableDTInLib = '';
        };

        $scope.copyLibrary = function(datatypeLibrary) {
            var newDatatypeLibrary = angular.copy(datatypeLibrary.datatypeLibrary);
            newDatatypeLibrary.id = new ObjectId().toString();
            //newDatatypeLibrary.metaData.ext = newDatatypeLibrary.metaData.ext + "-" + (Math.floor(Math.random() * 10000000) + 1);
            newDatatypeLibrary.accountId = userInfoService.getAccountID();
            var newTableLibrary = angular.copy(datatypeLibrary.tableLibrary);
            newTableLibrary.id = new ObjectId().toString();
            //newTableLibrary.metaData.ext = newDatatypeLibrary.metaData.ext + "-" + (Math.floor(Math.random() * 10000000) + 1);
            newTableLibrary.accountId = userInfoService.getAccountID();

            var newDatatypeLibraryDocument = angular.copy(datatypeLibrary);
            newDatatypeLibraryDocument.id = null;
            newDatatypeLibraryDocument.datatypeLibrary = newDatatypeLibrary;
            newDatatypeLibraryDocument.tableLibrary = newTableLibrary;
           // newDatatypeLibraryDocument.metaData.ext = newDatatypeLibrary.metaData.ext + "-" + (Math.floor(Math.random() * 10000000) + 1);
            newDatatypeLibraryDocument.accountId = userInfoService.getAccountID();
            $scope.datatypeLibsStruct.push(newDatatypeLibrary);
            DatatypeLibrarySvc.save(newDatatypeLibrary).then(function(response) {

                //newDatatypeLibraryDocument.datatypeLibrary=response;
                TableLibrarySvc.save(newTableLibrary).then(function(response) {
                    //newDatatypeLibraryDocument.tableLibrary=response;
                    DatatypeLibraryDocumentSvc.save(newDatatypeLibraryDocument).then(function(response) {

                    	$scope.editLibrary(response);

                    });
                });
            });

        };

        $scope.deleteLibrary = function(datatypeLibrary) {
            $scope.confirmLibraryDelete(datatypeLibrary);
        };

        $scope.confirmLibraryDelete = function(datatypeLibrary) {
            var modalInstance = $modal.open({
                templateUrl: 'ConfirmDatatypeLibraryDeleteCtrl.html',
                controller: 'ConfirmDatatypeLibraryDeleteCtrl',
                resolve: {
                    datatypeLibraryToDelete: function() {
                        return datatypeLibrary;
                    }
                }
            });
            modalInstance.result.then(function(datatypeLibraryDocument) {
                DatatypeLibraryDocumentSvc.delete(datatypeLibraryDocument.id).then(function(result) {
                	$rootScope.datatypeLibrary=null;
                    $rootScope.msg().text = "Data Type Library deleted";
                    var idxP = _.findIndex($scope.datatypeLibsStruct, function(child) {
                        return child.id === datatypeLibrary.id;
                    });
                    $scope.datatypeLibsStruct.splice(idxP, 1);
                    $scope.DataTypeTree = [];
                    $scope.datatypeLibCopy = {};
                    $scope.datatypeLibMetaDataCopy = {};
                    $scope.accordi.dtDetails = false;
                    $rootScope.isEditing = false;
                });
            });
        };

        $scope.toggleStatus = function(status) {
            $scope.datatype.status = $scope.datatype.status === 'PUBLISHED' ? 'UNPUBLISHED' : 'PUBLISHED';
        };

        $scope.saveDatatype = function(datatypeCopy) {
            //console.log("save datatypeForm=" + $scope.forms.editForm);
            $rootScope.datatypeLibrary = angular.copy(datatypeCopy);
            DatatypeService.save($rootScope.datatypeLibrary).then(function(result) {
                //$scope.selectedDT=$scope.datatype;
                $rootScope.msg().text = "datatypeSaved";
                $rootScope.msg().type = "success";
                $rootScope.msg().show = true;
                //$scope.editForm.$setPristine();
                cleanState();
            });
        };

        $scope.resetDatatype = function() {
            blockUI.start();
           $rootScope.datatype=angular.copy($rootScope.datatypesMap[$scope.datatype.id]);
            cleanState();
            blockUI.stop();
        };
        var cleanState = function() {

            if ($scope.editForm) {
            	console.log("Cleeaning");
                $scope.editForm.$setPristine();
                $scope.editForm.$dirty = false;
            }
        };
//        $scope.datatypesParams = new ngTreetableParams({
//            getNodes: function(parent) {
//                return DatatypeService.getDatatypeNodesInLib(parent, $rootScope.datatype);
//            },
//            getTemplate: function(node) {
//                return DatatypeService.getTemplateINLIB(node, $rootScope.datatype);
//            }
//        });
        $scope.datatypesParams = new ngTreetableParams({
            getNodes: function(parent) {
                return DatatypeService.getNodes(parent, $rootScope.datatype);
            },
            getTemplate: function(node) {
                return DatatypeService.getTemplate(node, $rootScope.datatype);
            }
        });

        function processEditDataType(data) {
            console.log("dialog not opened");
            //$rootScope.datatype=data;
            $rootScope.datatype = angular.copy(data);
            //$rootScope.datatype =result;
            $rootScope.currentData =$rootScope.datatype;
            $scope.$emit('event:openDatatypeInLib',$rootScope.datatype);
        };

        $scope.editDatatype = function(data) {
        	console.log(data);
          // Find share participants
          if (data.shareParticipantIds && data.shareParticipantIds.length > 0) {
        	  
        	  console.log(data.shareParticipantIds);
        	  var listOfIds= _.map(data.shareParticipantIds, function(element){ 
        		  if(element.id){
        		  return element.id;}
        		  else if(element.accountId){
        			 return element.accountId;
        		  }
        	  
        	  
        	  
        	  });
        	  console.log(listOfIds);
                  $http.get('api/shareparticipants', { params: { ids: listOfIds} })
                      .then(
                      function (response) {
                    	  data.shareParticipantIds=angular.fromJson(response.data);
                          //Proceed with next
                          $scope.editDatatypeNext(data);
                      },
                      function (error) {
                          console.log(error);
                      }
                      );
              
          } else {
            $scope.editDatatypeNext(data);
          }

        };

        $scope.editDatatypeNext = function(data) {
          if ($rootScope.hasChanges()) {
            console.log("found changes");

            $rootScope.openConfirmLeaveDlg().result.then(function() {
              console.log("dialog opened");
              processEditDataType(data);
            });
          } else {
            processEditDataType(data);
          }
        };



        $scope.selectDatatype = function(datatype) {
            $rootScope.Activate(datatype.id);
            $rootScope.datatype = datatype;
            //$rootScope.datatype =result;
            $rootScope.currentData =$rootScope.datatype;
            $scope.subview = "EditDatatypes.html";
                                $scope.loadingSelection = true;
                                $rootScope.datatype["type"] = "datatype";


                                try {
                                    if ($scope.datatypesParams)
                                        $scope.datatypesParams.refresh();
                                    $scope.loadingSelection = false;
                                } catch (e) {

                                }
                                $rootScope.references = [];
                                $rootScope.tmpReferences = [].concat($rootScope.references);

                                angular.forEach($rootScope.datatypes, function(dt) {
                                    if (dt && dt != null && dt.id !== $rootScope.datatype.id) $rootScope.findDatatypeRefs(datatype, dt, $rootScope.getDatatypeLabel(dt), dt);
                                });

                                $rootScope.tmpReferences = [].concat($rootScope.references);

                                $rootScope.$emit("event:initEditArea");


        };



        $scope.copyDatatype = function(datatypeCopy) {

        	//$scope.lastExt="1";
        	//$scope.lastExt
            var newDatatype = angular.copy(datatypeCopy);

            $scope.getLastExtesion(datatypeCopy);
            newDatatype.ext= $scope.lastExt;
            newDatatype.id = null;
            newDatatype.status = 'UNPUBLISHED';
            newDatatype.scope = $rootScope.datatypeLibrary.scope;
            newDatatype.ext=datatypeCopy.ext+"_"+(Math.floor(Math.random() * 10000000) + 1);
            DatatypeService.save(newDatatype).then(function(savedDatatype) {
                newDatatype = savedDatatype;
                $rootScope.datatypesMap[savedDatatype.id] = savedDatatype;
                $scope.editDatatype(savedDatatype);
                $rootScope.activeModel=savedDatatype.id;
                $rootScope.datatypeLibrary.children.push(createLink(newDatatype));
                $rootScope.datatypes.push(newDatatype);
                $rootScope.datatypes = _.uniq($rootScope.datatypes);
                DatatypeLibrarySvc.save($rootScope.datatypeLibrary);

            });
        };

        function createLink(datatype) {
            return {
                "id": datatype.id,
                "name": datatype.name,
                "ext": datatype.ext
            };
        };

        $scope.deleteDatatype = function(datatype) {
            if (datatype.status === 'PUBLISHED') {
                $scope.preventDeletePublished(datatype);
                console.log("Published");

            } else {
                $scope.confirmDelete(datatype);
            }

        };


        $scope.isAvailableDTForTables = function(dt) {
            if (dt != undefined) {
                if (dt.name === 'IS' || dt.name === 'ID' || dt.name === 'CWE' || dt.name === 'CNE' || dt.name === 'CE') return true;

                if (dt.components != undefined && dt.components.length > 0) return true;

            }
            return false;
        };
        $scope.preventDeletePublished = function(datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'PreventDatatypeDeleteCtl.html',
                controller: 'PreventDatatypeDeleteCtl',
                resolve: {
                    datatypeToDelete: function() {
                        return datatype;
                    }
                }
            });
            modalInstance.result.then(function(datatype) {

            });
        };

        $scope.confirmDelete = function(datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'ConfirmDatatypeDeleteCtl.html',
                controller: 'ConfirmDatatypeDeleteCtl',
                resolve: {
                    datatypeToDelete: function() {
                        return datatype;
                    }
                }
            });
            modalInstance.result.then(function(datatype) {
                console.log(datatype);
                var newLink = angular.fromJson({
                    id: datatype.id,
                    name: datatype.name,
                    ext: datatype.ext
                });
                //$rootScope.datatypeLibrary.children.push(newLink);
                var index = $rootScope.datatypes.indexOf(datatype);
                if (index > -1) {
                    $rootScope.datatypes.splice(index, 1);
                }


                DatatypeLibrarySvc.deleteChild($rootScope.datatypeLibrary.id, newLink).then(function(link) {
                    if(datatype.status=='PUBLISHED'){
                    	DatatypeService.delete(datatype);
                    }
                });
            });
        };

        $scope.getTableWidth = function() {
            if ($scope.tableWidth === null || $scope.tableWidth == 0) {
                $scope.tableWidth = $("#nodeDetailsPanel").width();
            }
            return $scope.tableWidth;
        };

        $scope.getDynamicWidth = function(a, b, otherColumsWidth) {
            var tableWidth = $scope.getTableWidth();
            if (tableWidth > 0) {
                var left = tableWidth - otherColumsWidth;
                return { "width": a * parseInt(left / b) + "px" };
            }
            return "";
        };

        $scope.isVisible = function(node) {
            var isVis = DatatypeService.isVisible(node);
            return isVis;
        };

        $scope.hasChildren = function(node) {
            //console.log("hasChildren getDatatype=" + $scope.getDatatype(node.datatype.id));
            console.log("node");
            console.log(node);
            return node && node != null && node.datatype && $scope.getDatatype(node.datatype.id) != undefined && $scope.getDatatype(node.datatype.id).components != null && $scope.getDatatype(node.datatype.id).components.length > 0;
        };

        $scope.isChildSelected = function(component) {
            return $scope.selectedChildren.indexOf(component) >= 0;
        };

        $scope.isChildNew = function(component) {
            return component && component != null && component.status === 'DRAFT';
        };

        $scope.recordDatatypeChange = function(type, command, id, valueType, value) {
            var datatypeFromChanges = $rootScope.findObjectInChanges("datatype", "add", $rootScope.datatype.id);
            if (datatypeFromChanges === undefined) {
                $rootScope.recordChangeForEdit2(type, command, id, valueType, value);
            }
        };

        $scope.countPredicate = function(position) {
            if (selectedDatatype != null)
                for (var i = 0, len1 = selectedDatatype.predicates.length; i < len1; i++) {
                    if (selectedDatatype.predicates[i].constraintTarget.indexOf(position + '[') === 0)
                        return 1;
                }

            return 0;
        };


        // create a data Library by scope

        $scope.createDatatypeLibrary = function(scope) {
        	$rootScope.creatingScope=scope;
            var standardDatatypesInstance = $modal.open({
                templateUrl: 'standardDatatypeDlg.html',
                controller: 'StandardDatatypeLibraryInstanceDlgCtl',
                size:'md',
                resolve: {
                    hl7Versions: function() {
                        return DatatypeLibrarySvc.getHL7Versions();
                    }
                }
            }).result.then(function(standard) {
                $scope.hl7Version = standard.hl7Version;
                DatatypeLibraryDocumentSvc.create(standard.hl7Version, scope, standard.name, standard.ext).then(function(result) {
                    console.log(result.data);

                    //angular.forEach($scope.datatypeLibrariesConfig, function(lib) {});
                    $scope.editLibrary(result.data, false);


                });
            });
        };


        $scope.showEvolution = function(scope) {
            var standardDatatypesInstance = $modal.open({
                templateUrl: 'evolution.html',
                controller: 'evolution',
                size:'lg'

            }).result.then(function() {

            });
        };

        $scope.getDatatype = function(id) {
            return $rootScope.datatypesMap && $rootScope.datatypesMap[id];
        };

        $scope.getNodes = function(parent, root) {
            console.log(root);
            var children = [];
            if (parent && parent != null) {
                if (parent.datatype) {
                    var dt = $rootScope.datatypesMap[parent.datatype.id];
                    children = dt.components;
                } else {
                    children = parent.components;
                }
            } else {
                if (root != null) {
                    children = root.components;
                } else {
                    children = [];
                }
            }
            console.log(children);

            return children;
        };

        $scope.getEditTemplate = function(node, root) {
            return node.type === 'datatype' ? 'DatatypeLibraryEditTree.html' : node.type === 'component' && !DatatypeService.isDatatypeSubDT(node, root) ? 'DatatypeLibraryComponentEditTree.html' : node.type === 'component' && DatatypeService.isDatatypeSubDT(node, root) ? 'DatatypeLibrarySubComponentEditTree.html' : '';
        };

        $scope.isVisible = function(node) {
            return DatatypeService.isVisible(node);
        };

        $scope.sort = {
            label: function(dt) {
                return $rootScope.getLabel(dt.name, $rootScope.datatypeLibrary.metaData.ext)
            }
        };

        $scope.openStandardDataypes = function(scope) {
        	$rootScope.creatingScope=scope;
            var standardDatatypesInstance = $modal.open({
                templateUrl: 'standardDatatypeDlg.html',
                controller: 'StandardDatatypeLibraryInstanceDlgCtl',
                windowClass: 'addDatatype',
                size:'md',
                resolve: {
                    hl7Versions: function() {
                        return DatatypeLibrarySvc.getHL7Versions();
                    }
                }
            }).result.then(function(standard) {
                $scope.hl7Version = standard.hl7Version;
                DatatypeLibraryDocumentSvc.create(standard.hl7Version, scope, standard.name, standard.ext,standard.description,standard.orgName).then(function(result) {
                    $scope.datatypeLibsStruct.push(result.data);
                    angular.forEach($scope.datatypeLibrariesConfig, function(lib) {
                        if (lib.type === scope) {
                            $scope.datatypeLibrariesConfig.selectedType = lib;
                        }
                    });
                    $scope.subview = "LibraryMetaData.html";
                    //$scope.datatypeLibsStruct.push(result.data);
                    $scope.editLibrary(result.data, false);

                    console.log(result.data);

                });
            });
        };

        $scope.addingToc = [];

        $scope.addDatatypesFromTree = function() {
            //$scope.openDataypeList();
            $scope.miniDTMap = [];
            $scope.datatypeLibList = [];
           $rootScope.datatype=null;
            if ($rootScope.datatypeLibrary.scope === 'MASTER') {
                $scope.subview = "addingViewForMaster.html";

            } else if ($rootScope.datatypeLibrary.scope === 'USER') {
                $scope.subview = "addingViewForMaster.html";

            }
        };

        $scope.containDatatypeWithname = function(datatype) {
            var temp = false;
            if ($scope.addedDatatypes.length > 0) {

                angular.forEach($scope.addedDatatypes, function(flavor) {

                    if (flavor.name === datatype.name) {
                        temp = true;
                    }
                });
            }
            return temp;

        };

        $scope.displayVersion= function(element){

        	if(element){
        		return element.hl7Version;
        	}
        };
        $scope.setLibrary = function(library) {
            DatatypeLibrarySvc.getDatatypesByLibrary(JSON.parse(library).id).then(function(result) {
                var dts = [];
                for (var i = 0; i < result.length; i++) {
                    if (result[i].status === "PUBLISHED") {
                        dts.push(result[i]);
                    }
                }
                $scope.datataypestoAdd = dts;
            });
        };
        $scope.openDataypeList = function(hl7Version) {

            var scopes = ['HL7STANDARD'];
            if ($scope.datatypeLibrariesConfig.selectedType === 'MASTER') {
                scopes.push('MASTER');
            } else {
                scopes.push('USER');
            }
            //console.log("openDataypeList scopes=" + scopes.length);
            var datatypesListInstance = $modal.open({
                templateUrl: 'datatypeListDlg.html',
                controller: 'DatatypeListInstanceDlgCtl',
                windowClass: 'addDatatype',
                resolve: {
                    hl7Version: function() {
                        return $scope.hl7Version;
                    },
                    datatypeLibsStruct: function() {
                        return DatatypeLibrarySvc.getDataTypeLibraryByScopesAndVersion(scopes, $scope.hl7Version);
                    }
                }
            }).result.then(function(results) {
                var ids = [];
                angular.forEach(results, function(result) {
                    ids.push(result.id);
                });

                DatatypeLibrarySvc.bindDatatypes(ids, $rootScope.datatypeLibrary.id, $rootScope.datatypeLibrary.metaData.ext).then(function(datatypeLinks) {
                    var ids = [];
                    angular.forEach(datatypeLinks, function(datatypeLink) {
                        $rootScope.datatypeLibrary.children.push(datatypeLink);
                        ids.push(datatypeLink.id);
                    });
                    DatatypeService.get(ids).then(function(datatypes) {
                        angular.forEach(datatypes, function(datatype) {
                            datatype.status = "UNPUBLISHED";
                            $scope.datatypeLibCopy.children.push(datatype);
                            DatatypeService.collectDatatypes(datatype.id).then(function(datatypes) {
                                angular.forEach(datatypes, function(dt) {
                                    if (!_.includes(dt.libIds, $rootScope.datatypeLibrary.id)) {
                                        dt.libIds.push($rootScope.datatypeLibrary.id);
                                    }
                                    if ($rootScope.datatypesMap[dt.id] === null || $rootScope.datatypesMap[dt.id] === undefined) {
                                        $rootScope.datatypesMap[dt.id] = dt;
                                        $scope.added.push(dt.id);
                                    };
                                    var exists2 = _.find($scope.DataTypeTree[0].children, 'id', dt.id);
                                    if (exists2 === undefined) {
                                        $scope.DataTypeTree[0].children.push(dt);
                                    }
                                });
                                //            //console.log("$scope.DataTypeTree=" + JSON.stringify($scope.DataTypeTree, null, 2));
                                DatatypeService.saveAll(datatypes);
                            });
                        });

                    });
                });
            });
        };



        $scope.abortPublish = function(datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'AbortPublishCtl.html',
                controller: 'AbortPublishCtl',
                resolve: {
                    datatypeToPublish: function() {
                        return datatype;
                    },
                    unpublishedDatatypes: function() {
                        return $scope.unpublishedDatatypes;
                    },
                    unpublishedTables: function() {
                        return $scope.unpublishedTables;
                    }

                }
            });

        };

        $scope.confirmPublish = function(datatypeCopy) {
            var modalInstance = $modal.open({
                templateUrl: 'ConfirmDatatypePublishCtl.html',
                controller: 'ConfirmDatatypePublishCtl',
                resolve: {
                    datatypeToPublish: function() {
                        return datatypeCopy;
                    }
                }
            });
            modalInstance.result.then(function(datatypetoPublish) {
            	console.log("Saving");
            	console.log($rootScope.datatype);
            	console.log("IN LIBRARY");
            	console.log($rootScope.datatypeLibrary);

                var ext = $rootScope.datatype.ext;

                DatatypeService.publish($rootScope.datatype).then(function(result) {

                    var oldLink = DatatypeLibrarySvc.findOneChild(result.id, $rootScope.datatypeLibrary.children);
                    var newLink = DatatypeService.getDatatypeLink(result);
                    newLink.ext = ext;
                    DatatypeLibrarySvc.updateChild($rootScope.datatypeLibrary.id, newLink).then(function(link) {
                        	DatatypeService.merge($rootScope.datatypesMap[result.id], result);
                        	$rootScope.datatypesMap[result.id].status="PUBLISHED";
                        	$rootScope.datatype.status="PUBLISHED";

                            if ($scope.editForm) {
                            	console.log("Cleeaning");
                                $scope.editForm.$setPristine();
                                $scope.editForm.$dirty = false;
                                $scope.editForm.$invalid = false;

                            }
                            $rootScope.clearChanges();
                            DatatypeService.merge($rootScope.datatype, result);
                            if ($scope.datatypesParams){
                                $scope.datatypesParams.refresh();
                            }
                         	VersionAndUseService.findById(result.id).then(function(inf){
                        		$rootScope.versionAndUseMap[inf.id]=inf;
                        		if($rootScope.versionAndUseMap[inf.sourceId]){
                        			$rootScope.versionAndUseMap[inf.sourceId].deprecated=true;
                        		}

                        	});
                            oldLink.ext = newLink.ext;
                            oldLink.name = newLink.name;
                            $scope.saving = false;
                            //$scope.cleanState();
                        }, function(error) {
                            $scope.saving = false;
                            $rootScope.msg().text = "Sorry an error occured. Please try again";
                            $rootScope.msg().type = "danger";
                            $rootScope.msg().show = true;
                        });
                    }, function(error) {
                        $scope.saving = false;
                        $rootScope.msg().text = "Sorry an error occured. Please try again";
                        $rootScope.msg().type = "danger";
                        $rootScope.msg().show = true;
                    });
            });
        };

        $scope.selectTable = function(t) {
            $rootScope.Activate(t.id);
            var table = angular.copy(t);
            if ($scope.viewSettings.tableReadonly || table.status == 'PUBLISHED') {
                $scope.subview = "ReadValueSets.html";
            } else {
                $scope.subview = "EditValueSets.html";
            }
            $scope.loadingSelection = true;
            blockUI.start();
            $rootScope.references = [];
            angular.forEach($rootScope.datatypes, function(dt) {
            console.log(dt);
            console.log($rootScope.getDatatypeLabel(dt));
            $rootScope.findTableRefsINLIB(table, dt, $rootScope.getDatatypeLabel(dt));
      });

            try {
                TableService.getOne(table.id).then(function(tbl) {
                    $rootScope.table = tbl;
                    $rootScope.table.smallCodes = $rootScope.table.codes.slice(0,1000);
                    $rootScope.currentData = $rootScope.table;
                    $rootScope.codeSystems = [];
                    for (var i = 0; i < $rootScope.table.codes.length; i++) {
                        if ($rootScope.codeSystems.indexOf($rootScope.table.codes[i].codeSystem) < 0) {
                            if ($rootScope.table.codes[i].codeSystem && $rootScope.table.codes[i].codeSystem !== '') {
                                $rootScope.codeSystems.push($rootScope.table.codes[i].codeSystem);
                            }
                        }
                    }
                    $rootScope.references = [];
                    angular.forEach($rootScope.datatypes, function(dt) {
                        $rootScope.findTableRefs($rootScope.table, dt, $rootScope.getDatatypeLabel(dt), dt);
                    });
                    $scope.loadingSelection = false;
                    $rootScope.$emit("event:initEditArea");
                    blockUI.stop();
                }, function(errr) {
                    $scope.loadingSelection = false;
                    $rootScope.msg().text = errr.data.text;
                    $rootScope.msg().type = errr.data.type;
                    $rootScope.msg().show = true;
                    blockUI.stop();
                });
            } catch (e) {
                $scope.loadingSelection = false;
                $rootScope.msg().text = "An error occured. DEBUG: \n" + e;
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
                blockUI.stop();
            }
        };

    });


angular.module('igl').controller('StandardDatatypeLibraryInstanceDlgCtl',
    function($scope, $rootScope, $modalInstance, $timeout, hl7Versions, DatatypeLibrarySvc, DatatypeService) {

        $scope.okDisabled = true;

        $scope.scope = "HL7STANDARD";
        $scope.hl7Versions = hl7Versions;
        $scope.standard = {};
        $scope.standard.hl7Version = null;
        $scope.name = null;
        $scope.standard.ext = null;

        $scope.getDisplayLabel = function(dt) {
            if (dt) {
                return dt.label;
            }
        }

        $scope.ok = function() {
            $modalInstance.close($scope.standard);
        };

        $scope.cancel = function() {
            $modalInstance.dismiss('cancel');
        };

    });

angular.module('igl').controller('evolution',
	    function($scope, $rootScope, $modalInstance, $timeout,DatatypeLibraryDocumentSvc) {

	$scope.vrs=["#","2.1","2.2","2.3","2.3.1","2.4","2.5","2.5.1","2.6","2.7","2.7.1","2.8","2.8.1","2.8.2"];
	$scope.adjusted=["21","22","23","231","24","25","251","26","27","271","28","281","282"];


	DatatypeLibraryDocumentSvc.getMatrix().then(function(result){
			$scope.matrix= result;
	});

	$scope.getColor= function(index){
		if(index===undefined){
			return "";
		}else if(index===0){
			return "#008B8B";
		}else if (index ===1){
			return "#B8860B";
		}else if (index ===2){
			return "#6495ED";
		}else if (index ===3){
			return "#9932CC";
		}else if (index ===4){
			return "#8FBC8F";
		}else if (index ===5){
			return "#2F4F4F";
		}else if (index ===6){
			return "#FF1493";
		}else if (index ===7){
			return "#FFD700";
		}else if (index ===8){
			return "#4B0082";
		}else if (index ===9){
			return "#FFB6C1";
		}else if (index ===10){
			return "#778899";
		}

	}




	        $scope.ok = function() {
	            $modalInstance.close();
	        };

	        $scope.cancel = function() {
	            $modalInstance.dismiss('cancel');
	        };

	    });
angular.module('igl').controller('DatatypeListInstanceDlgCtl',
    function($scope, $rootScope, $modalInstance, hl7Version, datatypeLibsStruct, DatatypeLibrarySvc, DatatypeService) {

        $scope.hl7Version = hl7Version;
        $scope.datatypesLibStruct = datatypeLibsStruct;
        $scope.selectedLib;
        $scope.dtSelections = [];

        $scope.trackSelections = function(bool, event) {
            if (bool) {
                $scope.dtSelections.push(event);
            } else {
                for (var i = 0; i < $scope.dtSelections.length; i++) {
                    if ($scope.dtSelections[i].id === event.id) {
                        $scope.dtSelections.splice(i, 1);
                    }
                }
            }
            $scope.okDisabled = $scope.dtSelections.length === 0;
        };

        $scope.libSelected = function(datatypeLib) {
            $scope.selectedLib = datatypeLib;
        };

        $scope.ok = function() {
            $modalInstance.close($scope.dtSelections);
        };

        $scope.cancel = function() {
            $modalInstance.dismiss('cancel');
        };
    });

angular.module('igl').controller('ConfirmDatatypeLibraryDeleteCtrl', function($scope, $rootScope, $http, $modalInstance, datatypeLibraryToDelete) {

    $rootScope.datatypeLibraryToDelete = datatypeLibraryToDelete;
    $scope.loading = false;

    $scope.delete = function() {
        $modalInstance.close($rootScope.datatypeLibraryToDelete);
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});

angular.module('igl').controller('ConfirmDatatypeDeleteCtl', function($scope, $rootScope, $http, $modalInstance, datatypeToDelete) {

    $scope.datatypeToDelete = datatypeToDelete;
    $scope.loading = false;

    $scope.delete = function() {
        $modalInstance.close($scope.datatypeToDelete);
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});


angular.module('igl').controller('ConfirmTablesDeleteCtl', function($scope, $rootScope, $http, $modalInstance, tableToDelete) {

    $scope.tableToDelete = tableToDelete;
    $scope.loading = false;

    $scope.delete = function() {
        $modalInstance.close($scope.tableToDelete);
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});


angular.module('igl').controller('PreventDatatypeDeleteCtl', function($scope, $rootScope, $http, $modalInstance, datatypeToDelete) {

    $scope.datatypeToDelete = datatypeToDelete;
    $scope.loading = false;

    $scope.delete = function() {
        $modalInstance.close($scope.datatypeToDelete);
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});

angular.module('igl').controller('ConfirmRedirect', function($scope, $rootScope, $http, $modalInstance, datatypeTo) {

    $scope.datatypeTo = datatypeTo;
    $scope.loading = false;

    $scope.delete = function() {
        $modalInstance.close($scope.datatypeTo);
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});




angular.module('igl').controller('PredicateDatatypeLibraryCtrl', function($scope, $modalInstance, selectedNode, selectedDatatype, $rootScope) {
    $scope.constraintType = 'Plain';
    $scope.selectedNode = selectedNode;

    $scope.firstConstraint = null;
    $scope.secondConstraint = null;
    $scope.compositeType = null;
    $scope.complexConstraint = null;
    $scope.complexConstraintTrueUsage = null;
    $scope.complexConstraintFalseUsage = null;

    $scope.changed = false;
    $scope.tempPredicates = [];
    angular.copy(selectedDatatype.predicates, $scope.tempPredicates);


    $scope.setChanged = function() {
        $scope.changed = true;
    }

    $scope.initPredicate = function() {
        $scope.newConstraint = angular.fromJson({
            position_1: null,
            position_2: null,
            location_1: null,
            location_2: null,
            datatype: '',
            component_1: null,
            subComponent_1: null,
            component_2: null,
            subComponent_2: null,
            verb: null,
            contraintType: null,
            value: null,
            value2: null,
            trueUsage: null,
            falseUsage: null,
            valueSetId: null,
            bindingStrength: 'R',
            bindingLocation: '1'
        });
        $scope.newConstraint.datatype = selectedDatatype.name;
    }

    $scope.initComplexPredicate = function() {
        $scope.firstConstraint = null;
        $scope.secondConstraint = null;
        $scope.compositeType = null;
        $scope.complexConstraintTrueUsage = null;
        $scope.complexConstraintFalseUsage = null;
    }

    $scope.initPredicate();


    $scope.deletePredicate = function(predicate) {
        $scope.tempPredicates.splice($scope.tempPredicates.indexOf(predicate), 1);
        $scope.changed = true;
    };

    $scope.updateComponent_1 = function() {
        $scope.newConstraint.subComponent_1 = null;
    };

    $scope.updateComponent_2 = function() {
        $scope.newConstraint.subComponent_2 = null;
    };


    $scope.genLocation = function(datatype, component, subComponent) {
        var location = null;
        if (component != null && subComponent == null) {
            location = datatype + '.' + component.position + "(" + component.name + ")";
        } else if (component != null && subComponent != null) {
            location = datatype + '.' + component.position + '.' + subComponent.position + "(" + subComponent.name + ")";
        }

        return location;
    };

    $scope.genPosition = function(component, subComponent) {
        var position = null;
        if (component != null && subComponent == null) {
            position = component.position + '[1]';
        } else if (component != null && subComponent != null) {
            position = component.position + '[1]' + '.' + subComponent.position + '[1]';
        }

        return position;
    };


    $scope.deletePredicateByTarget = function() {
        for (var i = 0, len1 = $scope.tempPredicates.length; i < len1; i++) {
            if ($scope.tempPredicates[i].constraintTarget.indexOf($scope.selectedNode.position + '[') === 0) {
                $scope.deletePredicate($scope.tempPredicates[i]);
                return true;
            }
        }
        return false;
    };

    $scope.addComplexPredicate = function() {
        $scope.complexConstraint = $rootScope.generateCompositePredicate($scope.compositeType, $scope.firstConstraint, $scope.secondConstraint);
        $scope.complexConstraint.trueUsage = $scope.complexConstraintTrueUsage;
        $scope.complexConstraint.falseUsage = $scope.complexConstraintFalseUsage;

        if ($scope.selectedNode === null) {
            $scope.complexConstraint.constraintId = '.';
        } else {
            $scope.complexConstraint.constraintId = $scope.newConstraint.datatype + '-' + $scope.selectedNode.position;
        }

        $scope.tempPredicates.push($scope.complexConstraint);
        $scope.initComplexPredicate();
        $scope.changed = true;
    };

    $scope.addPredicate = function() {

        $rootScope.newPredicateFakeId = $rootScope.newPredicateFakeId - 1;

        $scope.newConstraint.position_1 = $scope.genPosition($scope.newConstraint.component_1, $scope.newConstraint.subComponent_1);
        $scope.newConstraint.position_2 = $scope.genPosition($scope.newConstraint.component_2, $scope.newConstraint.subComponent_2);
        $scope.newConstraint.location_1 = $scope.genLocation($scope.newConstraint.datatype, $scope.newConstraint.component_1, $scope.newConstraint.subComponent_1);
        $scope.newConstraint.location_2 = $scope.genLocation($scope.newConstraint.datatype, $scope.newConstraint.component_2, $scope.newConstraint.subComponent_2);

        if ($scope.newConstraint.position_1 != null) {
            var cp = null;
            if ($scope.selectedNode === null) {
                var cp = $rootScope.generatePredicate(".", $scope.newConstraint);
            } else {
                var cp = $rootScope.generatePredicate($scope.selectedNode.position + '[1]', $scope.newConstraint);
            }

            $scope.tempPredicates.push(cp);
            $scope.changed = true;
        }
        $scope.initPredicate();
    };

    $scope.ok = function() {
        $modalInstance.close($scope.selectedNode);
    };

    $scope.saveclose = function() {
        angular.copy($scope.tempPredicates, selectedDatatype.predicates);
        $rootScope.recordChanged();
        $modalInstance.close($scope.selectedNode);
    };
});
angular.module('igl').controller('AddTableOpenCtrlLIB', function($scope, $modalInstance, tableLibrary, derivedTables, $rootScope, $http, $cookies, TableLibrarySvc, TableService) {
    $scope.loading = false;
    //$scope.igdocumentToSelect = igdocumentToSelect;
    $scope.source = '';
    $scope.selectedHL7Version = '';
    $scope.searchText = '';
    $scope.hl7Versions = [];
    $scope.hl7Tables = null;
    $scope.phinvadsTables = null;
    $scope.selectedTables = [];

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };

    $scope.listHL7Versions = function() {
        return $http.get('api/igdocuments/findVersions', {
            timeout: 60000
        }).then(function(response) {
            var hl7Versions = [];
            var length = response.data.length;
            for (var i = 0; i < length; i++) {
                hl7Versions.push(response.data[i]);
            }
            $scope.hl7Versions = hl7Versions;
        });
    };

    $scope.loadTablesByVersion = function(hl7Version) {
        $scope.loading = true;
        $scope.selectedHL7Version = hl7Version;
        return $http.get('api/igdocuments/' + hl7Version + "/tables", {
            timeout: 60000
        }).then(function(response) {
            $scope.hl7Tables = response.data;
            $scope.loading = false;
        });
    };

    $scope.searchPhinvads = function(searchText) {
        $scope.loading = true;
        $scope.searchText = searchText;
        return $http.get('api/igdocuments/' + searchText + "/PHINVADS/tables", {
            timeout: 600000
        }).then(function(response) {
            $scope.phinvadsTables = response.data;
            $scope.loading = false;
        });
    }
    $scope.createNewExtension = function(ext) {
        if (tableLibrary != null) {
            var rand = (Math.floor(Math.random() * 10000000) + 1);
            if (tableLibrary.metaData.ext === null) {
                return ext != null && ext != "" ? ext + "_" + rand : rand;
            } else {
                return ext != null && ext != "" ? ext + "_" + tableLibrary.metaData.ext + "_" + rand + 1 : rand + 1;
            }
        } else {
            return null;
        }
    };

    $scope.addTable = function(table) {
        var newTable = angular.copy(table);
        newTable.participants = [];
        newTable.bindingIdentifier = $scope.createNewExtension(table.bindingIdentifier);
        newTable.scope = $rootScope.datatypeLibrary.scope;

        if (newTable.codes != undefined && newTable.codes != null && newTable.codes.length != 0) {
            for (var i = 0, len1 = newTable.codes.length; i < len1; i++) {
                newTable.codes[i].id = new ObjectId().toString();
            }
        }
        console.log(JSON.stringify(newTable));
        $scope.selectedTables.push(newTable);
    };

    $scope.deleteTable = function(table) {
        var index = $scope.selectedTables.indexOf(table);
        if (index > -1) $scope.selectedTables.splice(index, 1);
    };


    function positionElements(chidren) {
        var sorted = _.sortBy(chidren, "sectionPosition");
        var start = sorted[0].sectionPosition;
        _.each(sorted, function(sortee) {
            sortee.sectionPosition = start++;
        });
        return sorted;
    }
});

angular.module('igl').controller('RichTextCtrlLIB', ['$scope', '$modalInstance', 'editorTarget', function($scope, $modalInstance, editorTarget) {
    $scope.editorTarget = editorTarget;

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };

    $scope.close = function() {
        $modalInstance.close($scope.editorTarget);
    };
}]);
angular.module('igl').controller('AddDatatypeCtrl',
	    function($scope, $rootScope, $modalInstance, hl7Version, datatypes, masterLib, userDtLib, DatatypeLibrarySvc, DatatypeService, TableLibrarySvc, TableService, $http,datatypeLibrary,tableLibrary,versionAndUseMap) {
			$scope.versionAndUseMap=versionAndUseMap;
	        $scope.newDts = [];
	        $scope.checkedExt = true;
	        $scope.NocheckedExt = true;
	        $scope.masterLib = [];
	        $scope.userDtLib = userDtLib;
	        $scope.masterLib = masterLib;
	        $scope.selectedDatatypes = [];
	        $scope.selectUserDtLib = function(usrLib) {
	            console.log(usrLib);
	            DatatypeLibrarySvc.getDatatypesByLibrary(usrLib.id).then(function(datatypes) {
	                $scope.userDatatypes = datatypes;
	                console.log($scope.userDatatypes);
	            });
	        };
	        $scope.selectMasterDtLib = function(masLib) {
	            console.log(masLib);
	            DatatypeLibrarySvc.getDatatypesByLibrary(masLib.id).then(function(datatypes) {
	            	console.log(datatypes);

	                $scope.masterDatatypes = _.where(datatypes, {scope:"MASTER",status:"PUBLISHED"}) ;
	                console.log($scope.masterDatatypes);
	            });
	        };
	        var listHL7Versions = function() {
	            return $http.get('api/igdocuments/findVersions', {
	                timeout: 60000
	            }).then(function(response) {
	                var hl7Versions = [];
	                var length = response.data.length;
	                for (var i = 0; i < length; i++) {
	                    hl7Versions.push(response.data[i]);
	                }
	                console.log(hl7Versions);
	                return hl7Versions;
	            });
	        };

	        var init = function() {
	            listHL7Versions().then(function(versions) {
	            	$scope.hl7Datatypes=[];
	                $scope.version1 = "";
	                $scope.versions = versions;
	                var scopes = ['HL7STANDARD'];
	            });

	        };
	        init();
	        $scope.setVersion = function(version) {
	            $scope.version1 = version;
	            var scopes = ['HL7STANDARD'];
	            DatatypeService.getDataTypesByScopesAndVersion(scopes, version).then(function(result) {
	                console.log("result");
	                console.log(result);
	                $scope.hl7Datatypes = result;
	            });
	        }
	        $scope.addDt = function(datatype) {
	            console.log(datatype);
	            $scope.selectedDatatypes.push(datatype);
	            console.log("chowing map");

	            console.log($rootScope.versionAndUseMap[datatype.id]);
	        };
	        $scope.checkExist = function(datatype) {

	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                if ($scope.selectedDatatypes[i].id === datatype.id) {
	                    return true;
	                }
	            }
	            for (var i = 0; i < $rootScope.datatypes.length; i++) {
	                if ($rootScope.datatypes[i].id === datatype.id) {
	                    return true;
	                }
	            }
	            return false;
	        }
	        $scope.checkExt = function(datatype) {
	            $scope.checkedExt = true;
	            $scope.NocheckedExt = true;
	            if (datatype.ext === "") {
	                $scope.NocheckedExt = false;
	                return $scope.NocheckedExt;
	            }
	            for (var i = 0; i < $rootScope.datatypes.length; i++) {
	                if ($rootScope.datatypes[i].name === datatype.name && $rootScope.datatypes[i].ext === datatype.ext) {
	                    $scope.checkedExt = false;
	                    return $scope.checkedExt;
	                }
	            }
	            console.log($scope.selectedDatatypes.indexOf(datatype));
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                if ($scope.selectedDatatypes.indexOf(datatype) !== i) {
	                    if ($scope.selectedDatatypes[i].name === datatype.name && $scope.selectedDatatypes[i].ext === datatype.ext) {
	                        $scope.checkedExt = false;
	                        return $scope.checkedExt;
	                    }
	                }

	            }

	            return $scope.checkedExt;
	        };
	        $scope.addDtFlv = function(datatype) {
	            //var newDatatype = {};

//	        		if ($rootScope.datatypeLibrary.scope=="USER") {
//	                var temp = [];
//	                $scope.newDatatype = angular.copy(datatype);
//
//		            	$scope.newDatatype.ext=Math.floor(Math.random() * 1000);
//
//	                	console.log($scope.newDatatype.ext);
//	       	            $scope.newDatatype.scope =datatypeLibrary.scope;
//	                  	$scope.newDatatype.status="UNPUBLISHED";
//	       	            $scope.newDatatype.participants = [];
//	       	            $scope.newDatatype.id = new ObjectId().toString();
//	       	            $scope.newDatatype.libIds = [];
//	    	            $scope.selectedDatatypes.push($scope.newDatatype);
//	    	            console.log($scope.selectedDatatypes)
//
//	            }else{
//
//	                DatatypeService.getLastMaster(datatype.name,$scope.version1).then(function(standard){
//	                	$scope.newDatatype=standard;
//	                	console.log($scope.newDatatype);
//	                	console.log($scope.newDatatype.ext);
//	       	            $scope.newDatatype.scope =datatypeLibrary.scope;
//	                  	$scope.newDatatype.status="UNPUBLISHED";
//	       	            $scope.newDatatype.participants = [];
//	       	            $scope.newDatatype.id = new ObjectId().toString();;
//	       	            $scope.newDatatype.libIds = [];
//	                	console.log(standard);
//	    	            $scope.selectedDatatypes.push($scope.newDatatype);
//	    	            console.log($scope.selectedDatatypes)
//	                });
//	            }
	                $scope.newDatatype = angular.copy(datatype);

	            	$scope.newDatatype.ext=Math.floor(Math.random() * 1000);

                	console.log($scope.newDatatype.ext);
       	            $scope.newDatatype.scope =datatypeLibrary.scope;
                  	$scope.newDatatype.status="UNPUBLISHED";

       	            $scope.newDatatype.participants = [];
       	            $scope.newDatatype.id = new ObjectId().toString();
       	            $scope.newDatatype.libIds = [];
    	            $scope.selectedDatatypes.push($scope.newDatatype);
    	            console.log($scope.selectedDatatypes)
	            console.log($scope.newDatatype.ext);
	            $scope.newDatatype.scope =datatypeLibrary.scope;
           	 	$scope.newDatatype.status="UNPUBLISHED";
	            $scope.newDatatype.participants = [];
	            $scope.newDatatype.id = new ObjectId().toString();;
	            $scope.newDatatype.libIds = [];
	            if ($scope.newDatatype.components != undefined && $scope.newDatatype.components != null && $scope.newDatatype.components.length != 0) {
	                for (var i = 0; i < $scope.newDatatype.components.length; i++) {
	                    $scope.newDatatype.components[i].id = new ObjectId().toString();
	                }
	            }

	            var predicates = $scope.newDatatype['predicates'];
	            if (predicates != undefined && predicates != null && predicates.length != 0) {
	                angular.forEach(predicates, function(predicate) {
	                    predicate.id = new ObjectId().toString();
	                });
	            }

	            var conformanceStatements = $scope.newDatatype['conformanceStatements'];
	            if (conformanceStatements != undefined && conformanceStatements != null && conformanceStatements.length != 0) {
	                angular.forEach(conformanceStatements, function(conformanceStatement) {
	                    conformanceStatement.id = new ObjectId().toString();
	                });
	            }
	          //  $scope.selectedDatatypes.push($scope.newDatatype);
	            console.log($scope.selectedDatatypes)
	        }
	        $scope.deleteDt = function(datatype) {
	            var index = $scope.selectedDatatypes.indexOf(datatype);
	            if (index > -1) $scope.selectedDatatypes.splice(index, 1);
	        };
	        var secretEmptyKey = '[$empty$]'

	        $scope.hl7Datatypes = datatypes.filter(function(current) {
	            return $rootScope.datatypes.filter(function(current_b) {
	                return current_b.id == current.id;
	            }).length == 0
	        });


	        $scope.dtComparator = function(datatype, viewValue) {
	            if (datatype) {
	                console.log(datatype.name);
	                console.log(datatype);
	            }
	            return viewValue === secretEmptyKey || (datatype && ('' + datatype.name).toLowerCase().indexOf(('' + viewValue).toLowerCase()) > -1);
	        };


	        $scope.isInDts = function(datatype) {

	            if ($scope.hl7Datatypes.indexOf(datatype) === -1) {
	                return false;
	            } else {
	                return true;
	            }

	        }


	        $scope.selectDT = function(datatype) {
	            console.log(datatype);
	            $scope.newDatatype = datatype;
	        };
	        $scope.selected = function() {
	            return ($scope.newDatatype !== undefined);
	        };
	        $scope.unselect = function() {
	            $scope.newDatatype = undefined;
	        };
	        $scope.isActive = function(id) {
	            if ($scope.newDatatype) {
	                return $scope.newDatatype.id === id;
	            } else {
	                return false;
	            }
	        };
	        $scope.ok = function() {
	            console.log($scope.selectedDatatypes);
	            $scope.selectFlv = [];
	            var newLinks = [];
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                if ($scope.selectedDatatypes[i].scope === datatypeLibrary.scope) {
	                    $scope.selectFlv.push($scope.selectedDatatypes[i]);
	                } else {
	                    newLinks.push({
	                        id: $scope.selectedDatatypes[i].id,
	                        name: $scope.selectedDatatypes[i].name
	                    })
	                }
	            }
	            $rootScope.usedDtLink = [];
	            $rootScope.usedVsLink = [];
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                $rootScope.fillMaps($scope.selectedDatatypes[i]);
	            }
	            DatatypeService.saves($scope.selectFlv).then(function(result) {
	                for (var i = 0; i < result.length; i++) {
	                    newLinks.push({
	                        id: result[i].id,
	                        name: result[i].name,
	                        ext: result[i].ext
	                    })
	                }
	                DatatypeLibrarySvc.addChildren(datatypeLibrary.id, newLinks).then(function(link) {
	                    for (var i = 0; i < newLinks.length; i++) {
	                        datatypeLibrary.children.splice(0, 0, newLinks[i]);
	                    }
	                    for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                        $rootScope.datatypes.splice(0, 0, $scope.selectedDatatypes[i]);
	                    }
	                    for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                        $rootScope.datatypesMap[$scope.selectedDatatypes[i].id] = $scope.selectedDatatypes[i];
	                    }
	                    var usedDtId1 = _.map($rootScope.usedDtLink, function(num, key) {
	                        return num.id;
	                    });

	                    DatatypeService.get(usedDtId1).then(function(datatypes) {
	                        for (var j = 0; j < datatypes.length; j++) {
	                            if (!$rootScope.datatypesMap[datatypes[j].id]) {

	                                $rootScope.datatypesMap[datatypes[j].id] = datatypes[j];
	                                $rootScope.datatypes.push(datatypes[j]);
	                                $rootScope.getDerived(datatypes[j]);
	                            }
	                        }

	                        var usedVsId = _.map($rootScope.usedVsLink, function(num, key) {
	                            return num.id;
	                        });
	                        console.log("$rootScope.usedVsLink");

	                        console.log($rootScope.usedVsLink);
	                        var newTablesLink = _.difference($rootScope.usedVsLink,tableLibrary.children);
	                        console.log(newTablesLink);

	                        TableLibrarySvc.addChildren(tableLibrary.id, newTablesLink).then(function() {
	                          tableLibrary.children = _.union(newTablesLink, tableLibrary.children);

	                            TableService.get(usedVsId).then(function(tables) {
	                                for (var j = 0; j < tables.length; j++) {
	                                    if (!$rootScope.tablesMap[tables[j].id]) {
	                                        $rootScope.tablesMap[tables[j].id] = tables[j];
	                                        $rootScope.tables.push(tables[j]);
	                                        $rootScope.getDerived(tables[j]);

	                                    }
	                                }

	                                for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                                    $rootScope.getDerived($scope.selectedDatatypes[i]);
	                                }

	                            });
	                        });
	                    });
	                    $rootScope.msg().text = "datatypeAdded";
	                    $rootScope.msg().type = "success";
	                    $rootScope.msg().show = true;
	                    $modalInstance.close(datatypes);
	                });

	            }, function(error) {
	                $rootScope.saving = false;
	                $rootScope.msg().text = error.data.text;
	                $rootScope.msg().type = error.data.type;
	                $rootScope.msg().show = true;
	            });


	        };

	        $scope.cancel = function() {
	            $modalInstance.dismiss('cancel');
	        };
	    });

angular.module('igl').controller('AddMasterDtCtrl',
	    function($scope, $rootScope, $modalInstance,datatypes, DatatypeLibrarySvc, DatatypeService, TableLibrarySvc, TableService, $http,datatypeLibrary,tableLibrary,AllUnchanged) {

	$scope.AllUnchanged=AllUnchanged;





	$scope.addedDatatypes=[];



    var listHL7Versions = function() {
        return $http.get('api/igdocuments/findVersions', {
            timeout: 60000
        }).then(function(response) {
            var hl7Versions = [];
            var length = response.data.length;
            for (var i = 0; i < length; i++) {
                hl7Versions.push(response.data[i]);
            }
            console.log(hl7Versions);
            return hl7Versions;
        });
    };

    var init = function() {
        listHL7Versions().then(function(versions) {
        	$scope.hl7Datatypes=[];
            $scope.version1 = "";
            $scope.versions = versions;
            var scopes = ['HL7STANDARD'];
        });

    };
    init();




	$scope.getDatatypeFromUnchanged= function(data1){
        var data= angular.copy(data1);
        var versions= data.versions;
        var version=0;
        console.log("versions ===== data ");
        console.log(versions);
        if(versions.length&&versions.length>0){
            version=versions[versions.length-1];
        }
        var name= data.name;
    // DatatypeService.getOneStandard(name, version,versions).then(function(result) {
    // 	var masterDt= angular.copy(result);
    // 	masterDt.hl7versions= data.versions;
    // 	//temporary fix
    // 	if(masterDt.hl7versions.length&&masterDt.hl7versions.length>1){
    // 		masterDt.hl7Version="[*]";
    // 	}else if(masterDt.hl7versions.length&&masterDt.hl7versions.length==1){
    // 		masterDt.hl7Version=version;
    // 	}

    //     //result.versions= versions;
    //     $scope.AddDatatypeForMaster(masterDt);
    // });

    	DatatypeService.getLastMaster(name,$scope.version1).then(function(result){
	    var masterDt= angular.copy(result);
    	masterDt.hl7versions= data.versions;
    	//temporary fix
    	// if(masterDt.hl7versions.length&&masterDt.hl7versions.length>1){
    	// 	masterDt.hl7Version="[*]";
    	// }else if(masterDt.hl7versions.length&&masterDt.hl7versions.length==1){
    	// 	masterDt.hl7Version=version;
    	// }

        //result.versions= versions;
        $scope.AddDatatypeForMaster(masterDt);
	    });

    };

    $scope.getLastExtesion= function(masterDt){
    	var ext=1;
    	if(masterDt.hl7versions){
    	var version=masterDt.hl7versions[masterDt.hl7versions.length-1];
    	}
        DatatypeService.getOneStandard(masterDt.name,version,masterDt.hl7versions).then(function(result) {

        	$scope.lastExt=result.ext;
        	console.log($scope.lastExt);
        });

    }
    $scope.setVersion=function(v){
        $scope.version1=v;
    }
    $scope.containsCurrentVersion=function(data){
        return data.versions.indexOf($scope.version1) !== -1;
    }
    $scope.AddDatatypeForMaster = function(datatype) {
            var dataToAdd = angular.copy(datatype);
            dataToAdd.id = new ObjectId().toString();
            dataToAdd.status = 'UNPUBLISHED';
            dataToAdd.scope = $rootScope.datatypeLibrary.scope;
            $scope.addedDatatypes.push(dataToAdd);

    };

    $scope.existingExtension=function(d,addedDatatypes){
    	var version1= d.hl7versions.toString();
		console.log(addedDatatypes);
    	$scope.exist=false;
    	angular.forEach($scope.addedDatatypes,function(dt){
        	var version2= dt.hl7versions.toString();

    		console.log(dt.hl7versions);
    		console.log(d.hl7versions);

    		if(dt.id!==d.id && d.name===dt.name && dt.ext===d.ext && version1==version2){

    			console.log("+++++++ found")
    			$scope.exist=true;
    		}
    	});
    	return $scope.exist;
    };


	$scope.cancel = function() {
	   $modalInstance.dismiss('cancel');
	        };

	    $scope.ok = function() {
	            $modalInstance.close($scope.addedDatatypes);
	        };
	    });

/**
 * Created by haffo on 2/13/15.
 */
angular.module('igl')
    .controller('DatatypeListCtrl', function($scope, $rootScope, Restangular, ngTreetableParams, $filter, $http, $q, $modal, $timeout, CloneDeleteSvc, ViewSettings, DatatypeService, ComponentService, MastermapSvc, FilteringSvc, DatatypeLibrarySvc, TableLibrarySvc, MessageService, TableService, blockUI, SegmentService, VersionAndUseService, CompareService) {
        $scope.accordStatus = {
            isCustomHeaderOpen: false,
            isFirstOpen: true,
            isSecondOpen: true,
            isThirdOpen: true,
            isFirstDisabled: false
        };
        $scope.tabStatus = {
            active: 1
        };
        $scope.availbleVersionOfDt = [];
        $scope.editableDT = '';
        $scope.editableVS = '';
        $scope.readonly = false;
        $scope.saved = false;
        $scope.message = false;
        $scope.datatypeCopy = null;
        $scope.viewSettings = ViewSettings;
        $scope.selectedChildren = [];
        $scope.saving = false;
        $scope.init = function() {
            $scope.accordStatus = {
                isCustomHeaderOpen: false,
                isFirstOpen: true,
                isSecondOpen: false,
                isThirdOpen: false,
                isFirstDisabled: false
            };

            $scope.tabStatus = {
                active: 1
            };

        };

        $scope.deleteConformanceStatementFromList = function(c) {
            $rootScope.datatype.conformanceStatements.splice($rootScope.datatype.conformanceStatements.indexOf(c), 1);

            $scope.setDirty();
        };

        $scope.deletePredicateFromList = function(p) {
            $rootScope.datatype.predicates.splice($rootScope.datatype.predicates.indexOf(p), 1);

            $scope.setDirty();
        };


        $scope.changeDatatypeLink = function(datatypeLink) {
            datatypeLink.isChanged = true;

            var t = $rootScope.datatypesMap[datatypeLink.id];

            if (t == null) {
                datatypeLink.name = null;
                datatypeLink.ext = null;
                datatypeLink.label = null;
            } else {
                datatypeLink.name = t.name;
                datatypeLink.ext = t.ext;
                datatypeLink.label = t.label;
            }
            console.log(datatypeLink);
        };

        $scope.dtmSliderOptions = {
            ceil: 7,
            floor: 0,
            showSelectionBar: true,
            onChange: function(id) {
                $scope.setDirty();
            },
            showTicks: true,
            getTickColor: function(value) {
                if (value < 3)
                    return 'red';
                if (value < 6)
                    return 'orange';
                if (value < 8)
                    return 'yellow';
                return '#2AE02A';
            }
        };

        $scope.refreshSlider = function() {
            setTimeout(function() {
                $scope.$broadcast('reCalcViewDimensions');
                console.log("refreshed Slider!!");
            }, 1000);
        };

        $scope.deleteComponent = function(componentToDelete, datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'DeleteComponent.html',
                controller: 'DeleteComponentCtrl',
                size: 'md',
                resolve: {
                    componentToDelete: function() {
                        return componentToDelete;
                    },
                    datatype: function() {
                        return datatype;
                    }


                }
            });
            modalInstance.result.then(function() {

                $scope.setDirty();
                try {
                    if ($scope.datatypesParams)
                        $scope.datatypesParams.refresh();
                } catch (e) {

                }
            });
        };
        $scope.testCall = function() {
            console.log($rootScope.references);
        };

        $scope.deletePredicate = function(position, datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'DeleteDatatypePredicate.html',
                controller: 'DeleteDatatypePredicateCtrl',
                size: 'md',
                resolve: {
                    position: function() {
                        return position;
                    },
                    datatype: function() {
                        return datatype;
                    }
                }
            });
            modalInstance.result.then(function() {
                $scope.setDirty();
            });
        };

        $scope.openPredicateDialog = function(node) {
            if (node.usage == 'C') $scope.managePredicate(node);
        };
        $scope.alerts = [
            { type: 'warning', msg: ' Warning: This Datatype is being deprecated, there are new versions availables' },

        ];



        $scope.closeAlert = function(index) {
            $scope.alerts.splice(index, 1);
        };

        $scope.OtoX = function(message) {
            console.log(message);
            var modalInstance = $modal.open({
                templateUrl: 'OtoX.html',
                controller: 'OtoXCtrl',
                size: 'md',
                resolve: {
                    message: function() {
                        return message;
                    }
                }
            });
            modalInstance.result.then(function() {
                $scope.setDirty();
                try {
                    if ($scope.datatypesParams)
                        $scope.datatypesParams.refresh();
                } catch (e) {

                }
            });
        };

        $scope.getAllVersionsOfDT = function(id) {
            $scope.checked = {};
            var ancestors = [];
            if (!$rootScope.versionAndUseMap[id]) {
                return "";
            }
            if ($rootScope.versionAndUseMap[id].ancestors && $rootScope.versionAndUseMap[id].ancestors.length > 0) {
                var ancestors = $rootScope.versionAndUseMap[id].ancestors;

            }
            ancestors.push($rootScope.versionAndUseMap[id].id);
            var derived = $rootScope.versionAndUseMap[id].derived;
            angular.forEach(ancestors, function(ancestor) {
                derived.push(ancestor);
            });
            var all = derived;
            console.log(all);
            VersionAndUseService.findAllByIds(all).then(function(result) {
                console.log("==========Adding Datatypes from their IDS============");
                //$rootScope.datatypes = result;
                console.log(result);
                $scope.availbleVersionOfDt = result;
                if ($scope.dynamicDt_Evolution) {

                }

            }, function(error) {
                $rootScope.msg().text = "DatatypesLoadFailed";
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
                delay.reject(false);

            });

        }

        $scope.dynamicDt_Evolution = new ngTreetableParams({
            getNodes: function(parent) {
                if ($scope.dataList !== undefined) {

                    //return parent ? parent.fields : $scope.test;
                    if (parent) {
                        if (parent.fields) {
                            return parent.fields;
                        } else if (parent.components) {
                            return parent.components;
                        } else if (parent.segments) {
                            return parent.segments;
                        } else if (parent.codes) {
                            return parent.codes;
                        }

                    } else {
                        return $scope.dataList;
                    }

                }
            },
            getTemplate: function(node) {
                return 'tree_node';
            }
        });
        $scope.compareWithCurrent = function(id) {
            $scope.checked = id;
            $rootScope.clearChanges();
            $scope.cleanState();

            DatatypeService.getOne(id).then(function(result) {
                $scope.dtChanged = false;
                $scope.vsTemplate = false;
                console.log("========dddddd");
                console.log($rootScope.datatype);
                console.log(result);
                $scope.dataList = CompareService.cmpDatatype(JSON.stringify($rootScope.datatype), JSON.stringify(result), [], [], [], []);
                console.log("$scope.dataList");
                console.log($scope.dataList);
                $scope.hideEvolution = false;
                $rootScope.clearChanges();
                $scope.cleanState();
                $scope.loadingSelection = false;
                if ($scope.dynamicDt_Evolution) {
                    $scope.dynamicDt_Evolution.refresh();
                }
            });
        };

        $scope.editableComp = '';
        $scope.editComponent = function(component) {
            $scope.editableComp = component.id;
            $scope.compName = component.name;

        };

        $scope.backComp = function() {
            $scope.editableComp = '';
        };
        $scope.applyComp = function(datatype, component, name, position) {
            blockUI.start();
            $scope.editableComp = '';
            if (component) {
                component.name = name;


            }
            if (position) {
                MessageService.updatePosition(datatype.components, component.position - 1, position - 1);
            }
            $scope.setDirty();

            if ($scope.datatypesParams)
                $scope.datatypesParams.refresh();
            $scope.Posselected = false;
            blockUI.stop();

        };
        $scope.selectPos = function() {

            $scope.Posselected = true;
        };





        $scope.selectDT = function(field, datatype) {
            if (datatype) {
                $scope.DTselected = true;
                blockUI.start();
                field.datatype.ext = JSON.parse(datatype).ext;
                field.datatype.id = JSON.parse(datatype).id;
                field.datatype.label = JSON.parse(datatype).label;
                field.datatype.name = JSON.parse(datatype).name;
                console.log(field);
                $scope.setDirty();
                // $rootScope.processElement(field);

                if ($scope.datatypesParams)
                    $scope.datatypesParams.refresh();
                $scope.editableDT = '';
                $scope.DTselected = false;
                blockUI.stop();
            } else {
                $scope.otherDT(field);
            }



        };
        $scope.otherDT = function(field) {
            var modalInstance = $modal.open({
                templateUrl: 'otherDTModal.html',
                controller: 'otherDTCtrl',
                windowClass: 'edit-VS-modal',
                resolve: {

                    datatypes: function() {
                        return $rootScope.datatypes;
                    },

                    field: function() {
                        return field;
                    }

                }
            });
            modalInstance.result.then(function(field) {
                $scope.setDirty();
                $scope.editableDT = '';
                if ($scope.datatypesParams) {
                    $scope.datatypesParams.refresh();
                }
            });

        };

        // $scope.applyDT = function(field, datatype) {
        //     blockUI.start();
        //     field.datatype.ext = JSON.parse(datatype).ext;
        //     field.datatype.id = JSON.parse(datatype).id;
        //     field.datatype.label = JSON.parse(datatype).label;
        //     field.datatype.name = JSON.parse(datatype).name;
        //     console.log(field);
        //     $scope.setDirty();
        //     // $rootScope.processElement(field);

        //     if ($scope.datatypesParams)
        //         $scope.datatypesParams.refresh();
        //     $scope.editableDT = '';
        //     $scope.DTselected = false;
        //     blockUI.stop();

        // };
        $scope.redirectSeg = function(segmentRef) {
            SegmentService.get(segmentRef.id).then(function(segment) {
                var modalInstance = $modal.open({
                    templateUrl: 'redirectCtrl.html',
                    controller: 'redirectCtrl',
                    size: 'md',
                    resolve: {
                        destination: function() {
                            return segment;
                        }
                    }



                });
                modalInstance.result.then(function() {
                    $rootScope.editSeg(segment);
                });



            });
        };
        $scope.redirectDT = function(datatype) {
            console.log(datatype);
            DatatypeService.getOne(datatype.id).then(function(datatype) {
                var modalInstance = $modal.open({
                    templateUrl: 'redirectCtrl.html',
                    controller: 'redirectCtrl',
                    size: 'md',
                    resolve: {
                        destination: function() {
                            return datatype;
                        }
                    }



                });
                modalInstance.result.then(function() {
                    $rootScope.editDatatype(datatype);
                });

            });
        };


        $scope.editDT = function(field) {
            $scope.editableDT = field.id;

            $scope.results = [];
            angular.forEach($rootScope.datatypeLibrary.children, function(dtLink) {
                if (dtLink.name && dtLink.name === field.datatype.name) {
                    $scope.results.push(dtLink);
                }
            });
        };



        $scope.backDT = function() {
            $scope.editableDT = '';
        };

        $scope.getTableLabel = function(tableLink) {
            var table = $rootScope.tablesMap[tableLink.id];
            console.log("TABLE FOUND");
            if (table && table.bindingIdentifier) {
                return $scope.getLabel(table.bindingIdentifier, table.ext);
            }
            return "";
        };
        $scope.getLabel = function(name, ext) {
            var label = name;
            if (ext && ext !== null && ext !== "") {
                label = label + "_" + ext;
            }
            return label;
        };

        $scope.editVSModal = function(component) {
            console.log(component.tables);
            console.log($rootScope.tablesMap);
            console.log($rootScope.tablesMap[component.tables[0].id]);
            var modalInstance = $modal.open({
                templateUrl: 'editVSModal.html',
                controller: 'EditVSCtrl',
                windowClass: 'edit-VS-modal',
                resolve: {

                    valueSets: function() {
                        return $rootScope.tables;
                    },

                    field: function() {
                        return component;
                    }

                }
            });
            modalInstance.result.then(function(datatype) {
                $scope.setDirty();
                if ($scope.segmentsParams) {
                    $scope.segmentsParams.refresh();
                }
            });

        };

        $scope.editVS = function(field) {
            $scope.editableVS = field.id;
            if (field.table !== null) {
                $scope.VSselected = true;
                $scope.selectedValueSet = field.table;
                console.log($scope.selectedValueSet);

            } else {
                $scope.VSselected = false;

            }
        };
        $scope.backVS = function() {
            $scope.editableVS = '';
        };

        $scope.selectVS = function(field, valueSet) {
            $scope.selectedValueSet = valueSet;
            $scope.VSselected = true;
            $scope.editableVS = '';
            if (field.table === null) {
                field.table = {
                    id: '',
                    bindingIdentifier: ''

                };
                console.log(field);

            }

            field.table.id = $scope.selectedValueSet.id;
            field.table.bindingIdentifier = $scope.selectedValueSet.bindingIdentifier;
            $scope.setDirty();
            $scope.VSselected = false;



        };
        // $scope.applyVS = function(field) {
        //     $scope.editableVS = '';
        //     if (field.table === null) {
        //         field.table = {
        //             id: '',
        //             bindingIdentifier: ''

        //         };
        //         console.log(field);

        //     }

        //     field.table.id = $scope.selectedValueSet.id;
        //     field.table.bindingIdentifier = $scope.selectedValueSet.bindingIdentifier;
        //     $scope.setDirty();
        //     $scope.VSselected = false;

        // };
        $scope.ContainUnpublished = function(element) {

            if (element && element.type && element.type === "datatype") {

                angular.forEach(element.components, function(component) {
                    component.location = element.name + "_" + element.ext + "." + component.position
                    $scope.ContainUnpublished(component);
                });


            } else if (element && element.type && element.type === "component") {

                if (element.tables && element.tables != null) {
                    angular.forEach(element.tables, function(table) {
                        if ($rootScope.tablesMap[table.id] && $rootScope.tablesMap[table.id]) {
                            if ($rootScope.tablesMap[table.id].scope !== "HL7STANDARD" && $rootScope.tablesMap[table.id].status !== "PUBLISHED") {
                                $scope.containUnpublished = true;
                                $scope.unpublishedTables.push({ table: table, location: element.location });
                                console.log($scope.unpublishedTables);
                            }
                        }
                    });
                }
                if (element.datatype !== null || element.datatype !== undefined) {


                    if ($rootScope.datatypesMap[element.datatype.id] && $rootScope.datatypesMap[element.datatype.id]) {
                        if ($rootScope.datatypesMap[element.datatype.id].status !== "PUBLISHED" && $rootScope.datatypesMap[element.datatype.id].scope !== "HL7STANDARD") {
                            console.log("Found Unpublished");
                            console.log($scope.containUnpublished);
                            $scope.containUnpublished = true;
                            $scope.unpublishedDatatypes.push({ datatype: element.datatype, location: element.location });
                        }
                    }


                }
            }
        };

        $scope.confirmPublish = function(datatypeCopy) {
            var modalInstance = $modal.open({
                templateUrl: 'ConfirmDatatypePublishCtl.html',
                controller: 'ConfirmDatatypePublishCtl',
                resolve: {
                    datatypeToPublish: function() {
                        return datatypeCopy;
                    }
                }
            });
            modalInstance.result.then(function(datatypetoPublish) {
                console.log("Saving");
                console.log($rootScope.datatype);
                console.log("IN LIBRARY");
                console.log($rootScope.datatypeLibrary);

                var ext = $rootScope.datatype.ext;

                DatatypeService.publish($rootScope.datatype).then(function(result) {
                    console.log("returning");
                    console.log(result);
                    console.log("In the map")

                    console.log($rootScope.datatypesMap[result.id])
                    var oldLink = DatatypeLibrarySvc.findOneChild(result.id, $rootScope.datatypeLibrary.children);
                    var newLink = DatatypeService.getDatatypeLink(result);
                    newLink.ext = ext;
                    DatatypeLibrarySvc.updateChild($rootScope.datatypeLibrary.id, newLink).then(function(link) {
                        DatatypeService.merge($rootScope.datatypesMap[result.id], result);
                        console.log("After Merge")
                        console.log($rootScope.datatypesMap[result.id]);


                        $rootScope.datatypesMap[result.id].status = "PUBLISHED";
                        $rootScope.datatype.status = "PUBLISHED";

                        if ($scope.editForm) {
                            console.log("Cleeaning");
                            $scope.editForm.$setPristine();
                            $scope.editForm.$dirty = false;
                            $scope.editForm.$invalid = false;

                        }
                        $rootScope.clearChanges();
                        DatatypeService.merge($rootScope.datatype, result);
                        if ($scope.datatypesParams) {
                            $scope.datatypesParams.refresh();
                        }
                        VersionAndUseService.findById(result.id).then(function(inf) {
                            $rootScope.versionAndUseMap[inf.id] = inf;
                            if ($rootScope.versionAndUseMap[inf.sourceId]) {
                                $rootScope.versionAndUseMap[inf.sourceId].deprecated = true;
                            }

                        });
                        oldLink.ext = newLink.ext;
                        oldLink.name = newLink.name;
                        $scope.saving = false;
                        //$scope.cleanState();
                    }, function(error) {
                        $scope.saving = false;
                        $rootScope.msg().text = "Sorry an error occured. Please try again";
                        $rootScope.msg().type = "danger";
                        $rootScope.msg().show = true;
                    });
                }, function(error) {
                    $scope.saving = false;
                    $rootScope.msg().text = "Sorry an error occured. Please try again";
                    $rootScope.msg().type = "danger";
                    $rootScope.msg().show = true;
                });
            });
        };

        $scope.abortPublish = function(datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'AbortPublishCtl.html',
                controller: 'AbortPublishCtl',
                resolve: {
                    datatypeToPublish: function() {
                        return datatype;
                    },
                    unpublishedDatatypes: function() {
                        return $scope.unpublishedDatatypes;
                    },
                    unpublishedTables: function() {
                        return $scope.unpublishedTables;
                    }

                }
            });

        };




        $scope.publishDatatype = function(datatype) {

            $scope.containUnpublished = false;
            $scope.unpublishedTables = [];
            $scope.unpublishedDatatypes = [];
            $scope.ContainUnpublished(datatype);

            if ($scope.containUnpublished) {
                $scope.abortPublish(datatype);
                datatype.status = "UNPUBLISHED";
            } else {
                $scope.confirmPublish(datatype);

            }
        };

        $scope.redirectVS = function(valueSet) {
            TableService.getOne(valueSet.id).then(function(valueSet) {
                var modalInstance = $modal.open({
                    templateUrl: 'redirectCtrl.html',
                    controller: 'redirectCtrl',
                    size: 'md',
                    resolve: {
                        destination: function() {
                            return valueSet;
                        }
                    }



                });
                modalInstance.result.then(function() {
                    if (!$rootScope.SharingScope) {
                        $rootScope.editTable(valueSet);
                    } else {
                        $scope.editTable(valueSet);
                    }

                });



            });
        };


        $scope.selectedVS = function() {
            return ($scope.selectedValueSet !== undefined);
        };
        $scope.unselectVS = function() {
            $scope.selectedValueSet = undefined;
            $scope.VSselected = false;

            //$scope.newSeg = undefined;
        };
        $scope.isVSActive = function(id) {
            if ($scope.selectedValueSet) {
                return $scope.selectedValueSet.id === id;
            } else {
                return false;
            }

        };





        $scope.addComponentModal = function(datatype) {
            console.log(datatype);
            var modalInstance = $modal.open({
                templateUrl: 'AddComponentModal.html',
                controller: 'AddComponentCtrl',
                windowClass: 'app-modal-window',
                resolve: {

                    valueSets: function() {
                        return $rootScope.tables;
                    },
                    datatypes: function() {
                        return $rootScope.datatypes;
                    },
                    datatype: function() {
                        return datatype;
                    },
                    messageTree: function() {
                        return $rootScope.messageTree;
                    }

                }
            });
            modalInstance.result.then(function(datatype) {
                $scope.setDirty();

                if ($scope.datatypesParams)
                    $scope.datatypesParams.refresh();
            });
        };

        $scope.copy = function(datatype) {
            CloneDeleteSvc.copyDatatype(datatype);
        };

        $scope.reset = function() {
            blockUI.start();
            DatatypeService.reset();
            $scope.cleanState();
            $rootScope.datatype = angular.copy($rootScope.datatypesMap[$rootScope.datatype.id]);

            $rootScope.references = [];
            angular.forEach($rootScope.segments, function(segment) {
                $rootScope.findDatatypeRefs($rootScope.datatype, segment, $rootScope.getSegmentLabel(segment), segment);
            });
            angular.forEach($rootScope.datatypes, function(dt) {
                $rootScope.findDatatypeRefs($rootScope.datatype, dt, $rootScope.getDatatypeLabel(dt), dt);
            });

            blockUI.stop();
        };

        $scope.recordDatatypeChange = function(type, command, id, valueType, value) {
            var datatypeFromChanges = $rootScope.findObjectInChanges("datatype", "add", $rootScope.datatype.id);
            if (datatypeFromChanges === undefined) {
                $rootScope.recordChangeForEdit2(type, command, id, valueType, value);
            }
        };

        $scope.close = function() {
            $rootScope.datatype = null;
            $scope.refreshTree();
            $scope.loadingSelection = false;
        };

        $scope.delete = function(datatype) {
            CloneDeleteSvc.deleteDatatype(datatype);
        };

        $scope.hasChildren = function(node) {
            return node && node != null && node.datatype && $rootScope.getDatatype(node.datatype.id) != undefined && $rootScope.getDatatype(node.datatype.id).components != null && $rootScope.getDatatype(node.datatype.id).components.length > 0;
        };

        $scope.validateLabel = function(label, name) {
            if (label && !label.startsWith(name)) {
                return false;
            }
            return true;
        };

        $scope.onDatatypeChange = function(node) {
            $rootScope.recordChangeForEdit2('component', 'edit', node.id, 'datatype', node.datatype);
            $scope.refreshTree(); // TODO: Refresh only the node
        };

        $scope.refreshTree = function() {
            if ($scope.datatypesParams)
                $scope.datatypesParams.refresh();
        };

        $scope.goToTable = function(table) {
            $scope.$emit('event:openTable', table);
        };

        $scope.deleteTable = function(node) {
            node.table = null;
            $rootScope.recordChangeForEdit2('component', 'edit', node.id, 'table', null);
        };

        $scope.mapTable = function(node) {
            var modalInstance = $modal.open({
                templateUrl: 'TableMappingDatatypeCtrl.html',
                controller: 'TableMappingDatatypeCtrl',
                windowClass: 'app-modal-window',
                resolve: {
                    selectedNode: function() {
                        return node;
                    }
                }
            });
            modalInstance.result.then(function(node) {
                $scope.selectedNode = node;
                $scope.setDirty();
            }, function() {});
        };

        $scope.managePredicate = function(node) {
            var modalInstance = $modal.open({
                templateUrl: 'PredicateDatatypeCtrl.html',
                controller: 'PredicateDatatypeCtrl',
                windowClass: 'app-modal-window',
                resolve: {
                    selectedNode: function() {
                        return node;
                    }
                }
            });
            modalInstance.result.then(function(dt) {
                if (dt) {
                    $rootScope.datatype.predicates = dt.predicates;
                    $scope.setDirty();
                }
            }, function() {});
        };

        $scope.manageConformanceStatement = function() {
            var modalInstance = $modal.open({
                templateUrl: 'ConformanceStatementDatatypeCtrl.html',
                controller: 'ConformanceStatementDatatypeCtrl',
                windowClass: 'app-modal-window',
                resolve: {}
            });
            modalInstance.result.then(function(dt) {
                if (dt) {
                    $scope.setDirty();
                }
            }, function() {});
        };

        $scope.isSubDT = function(component) {
            if ($rootScope.datatype != null) {
                for (var i = 0, len = $rootScope.datatype.components.length; i < len; i++) {
                    if ($rootScope.datatype.components[i].id === component.id)
                        return false;
                }
            }
            return true;
        };

        $scope.findDTByComponentId = function(componentId) {
            return $rootScope.parentsMap[componentId] ? $rootScope.parentsMap[componentId] : null;
        };

        $scope.countConformanceStatements = function(position) {
            var count = 0;
            if ($rootScope.datatype != null)
                for (var i = 0, len1 = $rootScope.datatype.conformanceStatements.length; i < len1; i++) {
                    if ($rootScope.datatype.conformanceStatements[i].constraintTarget.indexOf(position + '[') === 0)
                        count = count + 1;
                }

            return count;
        };

        $scope.countPredicate = function(position) {
            var count = 0;
            if ($rootScope.datatype != null)
                for (var i = 0, len1 = $rootScope.datatype.predicates.length; i < len1; i++) {
                    if ($rootScope.datatype.predicates[i].constraintTarget.indexOf(position + '[') === 0)
                        count = count + 1;
                }

            return count;
        };

        $scope.countPredicateOnSubComponent = function(position, componentId) {
            var dt = $scope.findDTByComponentId(componentId);
            if (dt != null)
                for (var i = 0, len1 = dt.predicates.length; i < len1; i++) {
                    if (dt.predicates[i].constraintTarget.indexOf(position + '[') === 0)
                        return 1;
                }

            return 0;
        };


        $scope.isRelevant = function(node) {
            return DatatypeService.isRelevant(node);
        };

        $scope.isBranch = function(node) {
            return DatatypeService.isBranch(node);
        };


        $scope.isVisible = function(node) {
            return DatatypeService.isVisible(node);
        };

        $scope.children = function(node) {
            return DatatypeService.getNodes(node);
        };

        $scope.getParent = function(node) {
            return DatatypeService.getParent(node);
        };

        $scope.getDatatypeLevelConfStatements = function(element) {
            return DatatypeService.getDatatypeLevelConfStatements(element);
        };

        $scope.getDatatypeLevelPredicates = function(element) {
            return DatatypeService.getDatatypeLevelPredicates(element);
        };

        $scope.isChildSelected = function(component) {
            return $scope.selectedChildren.indexOf(component) >= 0;
        };

        $scope.isChildNew = function(component) {
            return component && component != null && component.status === 'DRAFT';
        };


        $scope.selectChild = function($event, child) {
            var checkbox = $event.target;
            var action = (checkbox.checked ? 'add' : 'remove');
            updateSelected(action, child);
        };


        $scope.selectAllChildren = function($event) {
            var checkbox = $event.target;
            var action = (checkbox.checked ? 'add' : 'remove');
            for (var i = 0; i < $rootScope.datatype.components.length; i++) {
                var component = $rootScope.datatype.components[i];
                updateSelected(action, component);
            }
        };

        var updateSelected = function(action, child) {
            if (action === 'add' && !$scope.isChildSelected(child)) {
                $scope.selectedChildren.push(child);
            }
            if (action === 'remove' && $scope.isChildSelected(child)) {
                $scope.selectedChildren.splice($scope.selectedChildren.indexOf(child), 1);
            }
        };

        //something extra I couldn't resist adding :)
        $scope.isSelectedAllChildren = function() {
            return $rootScope.datatype && $rootScope.datatype != null && $rootScope.datatype.components && $scope.selectedChildren.length === $rootScope.datatype.components.length;
        };


        /**
         * TODO: update master map
         */
        $scope.createNewComponent = function() {
            if ($rootScope.datatype != null) {
                if (!$rootScope.datatype.components || $rootScope.datatype.components === null)
                    $rootScope.datatype.components = [];
                var child = ComponentService.create($rootScope.datatype.components.length + 1);
                $rootScope.datatype.components.push(child);
                //TODO update master map
                //MastermapSvc.addDatatypeObject($rootScope.datatype, [[$rootScope.igdocument.id, "ig"], [$rootScope.igdocument.profile.id, "profile"]]);
                //TODO:remove as legacy code
                $rootScope.parentsMap[child.id] = $rootScope.datatype;
                if ($scope.datatypesParams)
                    $scope.datatypesParams.refresh();
            }
        };

        /**
         * TODO: update master map
         */
        $scope.deleteComponents = function() {
            if ($rootScope.datatype != null && $scope.selectedChildren != null && $scope.selectedChildren.length > 0) {
                ComponentService.deleteList($scope.selectedChildren, $rootScope.datatype);
                //TODO update master map
                //TODO:remove as legacy code
                angular.forEach($scope.selectedChildren, function(child) {
                    delete $rootScope.parentsMap[child.id];
                });
                $scope.selectedChildren = [];
                if ($scope.datatypesParams)
                    $scope.datatypesParams.refresh();
            }
        };


        $scope.cleanState = function() {
            $scope.selectedChildren = [];
            $rootScope.addedDatatypes = [];
            $rootScope.addedTables = [];
            if ($scope.editForm) {
                $scope.editForm.$setPristine();
                $scope.editForm.$dirty = false;
            }
            $rootScope.clearChanges();
            if ($scope.datatypesParams)
                $scope.datatypesParams.refresh();
        };
        $scope.callDTDelta = function() {

            $rootScope.$emit("event:openDTDelta");
        };
        $scope.AddBindingForDatatype = function(datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'AddBindingForDatatype.html',
                controller: 'AddBindingForDatatype',
                windowClass: 'conformance-profiles-modal',
                resolve: {
                    datatype: function() {
                        return datatype;
                    }
                }
            });
            modalInstance.result.then(function() {
                $scope.setDirty();
            });
        };

        $scope.saveDatatype = function() {
            console.log("Saving");
            console.log($rootScope.datatype);
            console.log("IN LIBRARY");
            console.log($rootScope.datatypeLibrary);

            var ext = $rootScope.datatype.ext;

            DatatypeService.save($rootScope.datatype).then(function(result) {
                var oldLink = DatatypeLibrarySvc.findOneChild(result.id, $rootScope.datatypeLibrary.children);
                var newLink = DatatypeService.getDatatypeLink(result);
                newLink.ext = ext;
                DatatypeLibrarySvc.updateChild($rootScope.datatypeLibrary.id, newLink).then(function(link) {
                    DatatypeService.merge($rootScope.datatypesMap[result.id], result);
                    DatatypeService.merge($rootScope.datatype, result);
                    console.log("datatype.components");
                    console.log($scope.datatypesParams);
                    console.log($rootScope.datatype.components);
                    //  if ($scope.datatypesParams){
                    //      $scope.datatypesParams
                    //         $scope.datatypesParams.refresh();
                    //     }
                    $rootScope.clearChanges();
                    if ($scope.datatypesParams) {
                        // $scope.datatypesParams.refresh();   	
                    }
                    $rootScope.datatype.dateUpdated = result.dateUpdated;
                    $rootScope.$emit("event:updateIgDate");
                    DatatypeLibrarySvc.updateChild($rootScope.datatypeLibrary.id, newLink).then(function(link) {
                        DatatypeService.saveNewElements().then(function() {


                            oldLink.ext = newLink.ext;
                            oldLink.name = newLink.name;
                            $scope.saving = false;
                            $scope.cleanState();
                        }, function(error) {
                            $scope.saving = false;
                            $rootScope.msg().text = "Sorry an error occured. Please try again";
                            $rootScope.msg().type = "danger";
                            $rootScope.msg().show = true;
                        });
                    }, function(error) {
                        $scope.saving = false;
                        $rootScope.msg().text = "Sorry an error occured. Please try again";
                        $rootScope.msg().type = "danger";
                        $rootScope.msg().show = true;
                    });

                }, function(error) {
                    $scope.saving = false;
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
                $rootScope.saveBindingForDatatype();
            });
        }
        $scope.cancel = function() {
            //TODO: remove changes from master ma
            angular.forEach($rootScope.datatype.components, function(child) {
                if ($scope.isChildNew(child.status)) {
                    delete $rootScope.parentsMap[child.id];
                }
            });
            $rootScope.datatype = null;
            $scope.selectedChildren = [];
            $rootScope.clearChanges();
        };

        var searchById = function(id) {
            var children = $rootScope.datatypeLibrary.children;
            for (var i = 0; i < $rootScope.datatypeLibrary.children; i++) {
                if (children[i].id === id) {
                    return children[i];
                }
            }
            return null;
        };

        var indexIn = function(id, collection) {
            for (var i = 0; i < collection.length; i++) {
                if (collection[i].id === id) {
                    return i;
                }
            }
            return -1;
        };


        $scope.showSelectDatatypeFlavorDlg = function(component) {
            var modalInstance = $modal.open({
                templateUrl: 'SelectDatatypeFlavor.html',
                controller: 'SelectDatatypeFlavorCtrl',
                windowClass: 'app-modal-window',
                resolve: {
                    currentDatatype: function() {
                        return $rootScope.datatypesMap[component.datatype.id];
                    },

                    hl7Version: function() {
                        return $rootScope.igdocument.profile.metaData.hl7Version;
                    },
                    datatypeLibrary: function() {
                        return $rootScope.datatypeLibrary;
                    }
                }
            });
            modalInstance.result.then(function(datatype, ext) {
                //                MastermapSvc.deleteElementChildren(component.datatype.id, "datatype", component.id, component.type);
                //                MastermapSvc.addDatatypeObject(datatype, [[component.id, component.type]]);
                component.datatype.id = datatype.id;
                component.datatype.name = datatype.name;
                component.datatype.ext = datatype.ext;
                $rootScope.processElement(component);
                $scope.setDirty();
                if ($scope.datatypesParams)
                    $scope.datatypesParams.refresh();

            });

        };

        $scope.shareModal = function(datatype) {


            $http.get('api/usernames').then(function(response) {
                var userList = response.data;
                var filteredUserList = userList.filter(function(user) {
                    // Add accountId var
                    user.accountId = user.id;
                    var isPresent = false;
                    if (datatype.shareParticipantIds) {
                        for (var i = 0; i < datatype.shareParticipantIds.length; i++) {
                            if (datatype.shareParticipantIds[i].accountId == user.id) {
                                isPresent = true;
                            }
                        }
                    }
                    if (!isPresent) return user;
                });

                var modalTemplate = "ShareDatatypeErrorModal.html";
                if (datatype.status === "PUBLISHED") {
                    modalTemplate = "ShareDatatypeModal.html";
                }
                var modalInstance = $modal.open({
                    templateUrl: modalTemplate,
                    controller: 'ShareDatatypeCtrl',
                    size: 'lg',
                    resolve: {
                        igdocumentSelected: function() {
                            return datatype;
                        },
                        userList: function() {
                            return _.filter(filteredUserList, function(user) {
                                return user.id != $rootScope.accountId && datatype.shareParticipantIds && datatype.shareParticipantIds != null && datatype.shareParticipantIds.indexOf(user.id) == -1;
                            });
                        }
                    }
                });

                modalInstance.result.then(function(result) {
                    $scope.saveDatatypeAfterShare();
                }, function() {
                    if (modalTemplate === 'ShareDatatypeModal.html') {
                        $scope.saveDatatypeAfterShare();
                    }
                    // $log.info('Modal dismissed at: ' + new Date());
                });

            }, function(error) {
                console.log(error);
            });
        };

        $scope.saveDatatypeAfterShare = function() {

            var ext = $rootScope.datatype.ext;

            DatatypeService.save($rootScope.datatype).then(function(result) {
                var oldLink = DatatypeLibrarySvc.findOneChild(result.id, $rootScope.datatypeLibrary.children);
                var newLink = DatatypeService.getDatatypeLink(result);
                newLink.ext = ext;
                DatatypeLibrarySvc.updateChild($rootScope.datatypeLibrary.id, newLink).then(function(link) {
                    //DatatypeService.merge($rootScope.datatypesMap[result.id], result);
                    DatatypeService.merge($rootScope.datatype, result);

                    DatatypeService.saveNewElements(true).then(function() {


                        oldLink.ext = newLink.ext;
                        oldLink.name = newLink.name;
                        $scope.saving = false;
                        $scope.cleanState();
                    }, function(error) {
                        $scope.saving = false;
                    });
                }, function(error) {
                    $scope.saving = false;
                });

            }, function(error) {
                $scope.saving = false;
            });
            $rootScope.saveBindingForDatatype();
        };


        //        $scope.$watch(function(){
        //            return $rootScope.datatype;
        //        }, function() {
        //            $rootScope.recordChanged();
        //        }, true);


    });


angular.module('igl')
    .controller('DatatypeRowCtrl', function($scope, $filter) {

        $scope.init = function(node) {
            $scope.node = node;
        }

        $scope.formName = "form_" + new Date().getTime();
    });

angular.module('igl')
    .controller('SelectDatatypeFlavorCtrl', function($scope, $filter, $modalInstance, $rootScope, $http, currentDatatype, DatatypeService, $rootScope, hl7Version, ngTreetableParams, ViewSettings, DatatypeLibrarySvc, $q, datatypeLibrary, TableService) {
        $scope.resultsError = null;
        $scope.viewSettings = ViewSettings;
        $scope.resultsLoading = null;
        $scope.results = [];
        $scope.tmpResults = [].concat($scope.results);
        $scope.datatypeLibrary = datatypeLibrary;

        $scope.currentDatatype = angular.copy(currentDatatype);
        $scope.selection = { library: null, scope: null, hl7Version: hl7Version, datatype: null, name: $scope.currentDatatype != null && $scope.currentDatatype ? $scope.currentDatatype.name : null, selected: null };
        $scope.dataypesMap = {};
        $scope.datatypeFlavorParams = new ngTreetableParams({
            getNodes: function(parent) {
                return DatatypeService.getNodes(parent, $scope.selection.datatype);
            },
            getTemplate: function(node) {
                return DatatypeService.getReadTemplate(node, $scope.selection.datatype);
            }
        });

        $scope.isRelevant = function(node) {
            var rel = DatatypeService.isRelevant(node);
            return rel;
        };

        $scope.isBranch = function(node) {
            var isBran = DatatypeService.isBranch(node);
            return isBran;
        };


        $scope.isVisible = function(node) {
            var isVis = DatatypeService.isVisible(node);
            return isVis;
        };

        $scope.children = function(node) {
            var chil = DatatypeService.getNodes(node);
            return chil;
        };

        $scope.getParent = function(node) {
            var par = DatatypeService.getParent(node);
            return par;
        };

        $scope.isChildSelected = function(component) {
            return $scope.selectedChildren.indexOf(component) >= 0;
        };

        $scope.isChildNew = function(component) {
            return component && component != null && component.status === 'DRAFT';
        };


        $scope.hasChildren = function(node) {
            console.log("hasChildren==============================================================");
            console.log(node);
            return node && node != null && node.datatype && $rootScope.getDatatype(node.datatype.id) != undefined && $rootScope.getDatatype(node.datatype.id).components != null && $rootScope.getDatatype(node.datatype.id).components.length > 0;
        };

        $scope.validateLabel = function(label, name) {
            if (label && !label.startsWith(name)) {
                return false;
            }
            return true;
        };

        $scope.loadLibrariesByFlavorName = function() {
            var delay = $q.defer();
            $scope.selection.datatype = null;
            $scope.selection.selected = null;
            $scope.ext = null;
            $scope.results = [];
            $scope.tmpResults = [];
            $scope.results = $scope.results.concat(filterFlavors(datatypeLibrary, $scope.selection.name));
            $scope.tmpResults = [].concat($scope.results);
            DatatypeLibrarySvc.findLibrariesByFlavorName($scope.selection.name, 'HL7STANDARD', $scope.selection.hl7Version).then(function(libraries) {
                if (libraries != null) {
                    _.each(libraries, function(library) {
                        $scope.results = $scope.results.concat(filterFlavors(library, $scope.selection.name));
                    });
                }

                $scope.results = _.uniq($scope.results, function(item, key, a) {
                    return item.id;
                });
                $scope.tmpResults = [].concat($scope.results);

                delay.resolve(true);
            }, function(error) {
                $rootScope.msg().text = "Sorry could not load the data types";
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
                delay.reject(error);
            });
            return delay.promise;
        };

        var filterFlavors = function(library, name) {
            var results = [];
            _.each(library.children, function(link) {
                if (link.name === name) {
                    link.libraryName = library.metaData.name;
                    link.hl7Version = library.metaData.hl7Version;
                    results.push(link);
                }
            });
            return results;
        };

        $scope.isDatatypeSubDT = function(component) {
            return DatatypeService.isDatatypeSubDT(component, $scope.selection.datatype);
        };

        $scope.isSelectedDatatype = function(datatype) {
            return $scope.selection.selected != null && datatype != null && $scope.selection.selected == datatype.id;
        };

        $scope.isSelectedLibrary = function(library) {
            return $scope.selection.library != null && library != null && $scope.selection.library.id == library.id;
        };

        $scope.showSelectedDetails = function(datatype) {
            if (datatype && datatype != null) {
                $scope.selection.datatype = datatype;
                $scope.selection.datatype["type"] = "datatype";
            }
        };

        var indexIn = function(id, collection) {
            for (var i = 0; i < collection.length; i++) {
                if (collection[i].id === id) {
                    return i;
                }
            }
            return -1;
        };


        var collectNewDatatypesAndTables = function(root, datatypes) {
            $rootScope.datatypesMap[root.id] = root;
            if (indexIn(root.id, $rootScope.addedDatatypes) < 0) {
                $rootScope.addedDatatypes.push(root);
                console.log(child);
            }
            var tmpTables = [];
            angular.forEach(datatypes, function(child) {
                $rootScope.datatypesMap[child.id] = child;
                if (indexIn(child.id, $rootScope.addedDatatypes) < 0) {
                    $rootScope.addedDatatypes.push(child);
                    console.log(child);
                    $rootScope.filteredDatatypesList.push(child);
                }

                if (indexIn(child.table.id, $rootScope.addedTables) < 0) {
                    tmpTables.push(child.table.id);

                }
            });

            if (tmpTables.length > 0) {
                TableService.findAllByIds(tmpTables).then(function(tables) {
                    $rootScope.addedTables = $rootScope.addedTables.concat(tables);
                    angular.forEach(tables, function(table) {
                        $rootScope.tablesMap[table.id] = table;
                    });
                    $modalInstance.close($scope.selection.datatype);
                }, function(error) {
                    $rootScope.msg().text = "Sorry an error occured. Please try again";
                    $rootScope.msg().type = "danger";
                    $rootScope.msg().show = true;
                });
            } else {
                $modalInstance.close($scope.selection.datatype);
            }
        };


        $scope.submit = function() {
            var indexFromLibrary = indexIn($scope.selection.datatype.id, $scope.datatypeLibrary.children);
            var indexFromCollection = indexIn($scope.selection.datatype.id, $rootScope.datatypes);
            var indexFromMap = $rootScope.datatypesMap[$scope.selection.datatype.id] != undefined && $rootScope.datatypesMap[$scope.selection.datatype.id] != null ? 100 : -1;

            if (indexFromLibrary < 0 | indexFromCollection < 0 | indexFromMap < 0) {
                DatatypeService.getOne($scope.selection.datatype.id).then(function(full) {
                    DatatypeService.collectDatatypes(full.id).then(function(datatypes) {
                        $rootScope.processSegmentsTree($rootScope.segment, null);
                        $scope.ext = full.ext;
                        $scope.selection.datatype = full;
                        $scope.selection.datatype["type"] = "datatype";
                        collectNewDatatypesAndTables($scope.selection.datatype, datatypes);
                    }, function(error) {
                        $scope.loadingSelection = false;
                        $rootScope.msg().text = "Sorry could not load the data type";
                        $rootScope.msg().type = "danger";
                        $rootScope.msg().show = true;
                    });
                }, function(error) {
                    $scope.resultsLoading = false;
                    $rootScope.msg().text = "Sorry could not load the data type";
                    $rootScope.msg().type = "danger";
                    $rootScope.msg().show = true;
                });
            } else {
                $modalInstance.close($scope.selection.datatype);
            }
        };


        $scope.cancel = function() {
            $scope.resetMap();
            $modalInstance.dismiss('cancel');
        };

        $scope.getLocalDatatypeLabel = function(link) {
            return link != null ? $rootScope.getLabel(link.name, link.ext) : null;
        };


        $scope.resetMap = function() {
            if ($rootScope.addedDatatypes = null) {
                angular.forEach($rootScope.addedDatatypes, function(child) {
                    var dt = $rootScope.datatypesMap[child];
                    if (dt.id !== $scope.currentDatatype.id) {
                        delete $rootScope.datatypesMap[child];
                    }
                });
            }
        };

        $scope.loadLibrariesByFlavorName().then(function(done) {
            $scope.selection.selected = $scope.currentDatatype.id;
            $scope.showSelectedDetails($scope.currentDatatype);
        });

    });


angular.module('igl').controller('ConfirmDatatypeDeleteCtrl', function($scope, $modalInstance, dtToDelete, $rootScope, DatatypeLibrarySvc, DatatypeService, MastermapSvc, CloneDeleteSvc) {
    $scope.dtToDelete = dtToDelete;
    $scope.loading = false;
    $scope.delete = function() {
        $scope.loading = true;
        if ($scope.dtToDelete.scope === 'USER' && $scope.dtToDelete.status === 'UNPUBLISHED') {
            CloneDeleteSvc.deleteDatatypeAndDatatypeLink($scope.dtToDelete);
        } else {
            console.log("deleting");
            CloneDeleteSvc.deleteDatatypeLink($scope.dtToDelete);
        }

        $modalInstance.close($scope.dtToDelete);
        $scope.loading = false;
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});


angular.module('igl').controller('DatatypeReferencesCtrl', function($scope, $modalInstance, dtToDelete) {

    $scope.dtToDelete = dtToDelete;

    $scope.ok = function() {
        $modalInstance.close($scope.dtToDelete);
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});

angular.module('igl').controller('TableMappingDatatypeCtrl', function($scope, $modalInstance, selectedNode, $rootScope) {
    $scope.changed = false;
    $scope.selectedNode = selectedNode;
    $scope.selectedTable = null;
    if (selectedNode.table != undefined) {
        $scope.selectedTable = $rootScope.tablesMap[selectedNode.table.id];
    }

    $scope.selectTable = function(table) {
        $scope.changed = true;
        $scope.selectedTable = table;
    };


    $scope.mappingTable = function() {
        if ($scope.selectedNode.table == null || $scope.selectedNode.table == undefined) $scope.selectedNode.table = {};

        $scope.selectedNode.table.id = $scope.selectedTable.id;
        $scope.selectedNode.table.bindingIdentifier = $scope.selectedTable.bindingIdentifier;
        $rootScope.recordChanged();
        $scope.ok();
    };

    $scope.ok = function() {
        $modalInstance.close($scope.selectedNode);
    };

});


angular.module('igl').controller('ConformanceStatementDatatypeCtrl', function($scope, $modalInstance, $rootScope, $q) {
    $scope.constraintType = 'Plain';
    $scope.constraints = [];
    $scope.firstConstraint = null;
    $scope.secondConstraint = null;
    $scope.compositeType = null;
    $scope.complexConstraint = null;
    $scope.ext = null;
    if ($rootScope.igdocument) $scope.ext = $rootScope.igdocument.metaData.ext;
    $scope.newComplexConstraintId = $rootScope.calNextCSID($scope.ext, $rootScope.datatype.name + "_" + $rootScope.datatype.ext);
    $scope.newComplexConstraint = [];
    $scope.firstNodeData = null;
    $scope.secondNodeData = null;
    $scope.changed = false;
    $scope.tempComformanceStatements = [];
    angular.copy($rootScope.datatype.conformanceStatements, $scope.tempComformanceStatements);

    $scope.treeDataForContext = [];
    $scope.treeDataForContext.push(angular.copy($rootScope.datatype));
    $scope.treeDataForContext[0].pathInfoSet = [];
    $scope.generatePathInfo = function(current, positionNumber, locationName, instanceNumber, isInstanceNumberEditable, nodeName) {
        var pathInfo = {};
        pathInfo.positionNumber = positionNumber;
        pathInfo.locationName = locationName;
        pathInfo.nodeName = nodeName;
        pathInfo.instanceNumber = instanceNumber;
        pathInfo.isInstanceNumberEditable = isInstanceNumberEditable;
        current.pathInfoSet.push(pathInfo);

        if (current.type == 'datatype') {
            var dt = current;
            for (var i in dt.components) {
                var c = dt.components[i];
                c.pathInfoSet = angular.copy(current.pathInfoSet);

                var childPositionNumber = c.position;
                var childLocationName = c.position;
                var childNodeName = c.name;
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                var child = angular.copy($rootScope.datatypesMap[c.datatype.id]);
                child.id = new ObjectId().toString();
                c.child = child;
                $scope.generatePathInfo(c, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName);
            }
        } else if (current.type == 'component') {
            var dt = current.child;
            for (var i in dt.components) {
                var c = dt.components[i];
                c.pathInfoSet = angular.copy(current.pathInfoSet);
                var childPositionNumber = c.position;
                var childLocationName = c.position;
                var childNodeName = c.name;
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                var child = angular.copy($rootScope.datatypesMap[c.datatype.id]);
                child.id = new ObjectId().toString();
                c.child = child;
                $scope.generatePathInfo(c, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName);
            }
        }
    };

    $scope.generatePathInfo($scope.treeDataForContext[0], ".", ".", "1", false);

    $scope.setChanged = function() {
        $scope.changed = true;
    };

    $scope.toggleChildren = function(data) {
        data.childrenVisible = !data.childrenVisible;
        data.folderClass = data.childrenVisible ? "fa-minus" : "fa-plus";
    };

    $scope.beforeComponentDrop = function() {
        var deferred = $q.defer();

        if ($scope.draggingStatus === 'ContextTreeNodeDragging') {
            deferred.resolve();
        } else {
            deferred.reject();
        }
        return deferred.promise;
    };

    $scope.beforeNodeDrop = function() {
        var deferred = $q.defer();
        deferred.resolve();
        return deferred.promise;
    };

    $scope.afterNodeDrop = function() {
        $scope.draggingStatus = null;
        $scope.newConstraint.pathInfoSet_1 = $scope.firstNodeData.pathInfoSet;
        $scope.generateFirstPositionAndLocationPath();
    };

    $scope.afterSecondNodeDrop = function() {
        $scope.draggingStatus = null;
        $scope.newConstraint.pathInfoSet_2 = $scope.secondNodeData.pathInfoSet;
        $scope.generateSecondPositionAndLocationPath();
    };

    $scope.draggingNodeFromContextTree = function(event, ui, data) {
        $scope.draggingStatus = 'ContextTreeNodeDragging';
    };

    $scope.initConformanceStatement = function() {
        $scope.newConstraint = angular.fromJson({
            pathInfoSet_1: null,
            pathInfoSet_2: null,
            position_1: null,
            position_2: null,
            location_1: null,
            location_2: null,
            freeText: null,
            verb: null,
            ignoreCase: false,
            constraintId: $rootScope.calNextCSID($scope.ext, $rootScope.datatype.name + "_" + $rootScope.datatype.ext),
            contraintType: null,
            value: null,
            value2: null,
            valueSetId: null,
            bindingStrength: 'R',
            bindingLocation: '1'
        });
    };

    $scope.initComplexStatement = function() {
        $scope.constraints = [];
        $scope.firstConstraint = null;
        $scope.secondConstraint = null;
        $scope.compositeType = null;
        $scope.newComplexConstraintId = $rootScope.calNextCSID($scope.ext, $rootScope.datatype.name + "_" + $rootScope.datatype.ext);
    };

    $scope.initConformanceStatement();

    $scope.generateFirstPositionAndLocationPath = function() {
        if ($scope.newConstraint.pathInfoSet_1) {
            var positionPath = '';
            var locationPath = '';
            for (var i in $scope.newConstraint.pathInfoSet_1) {
                if (i > 0) {
                    var pathInfo = $scope.newConstraint.pathInfoSet_1[i];
                    positionPath = positionPath + "." + pathInfo.positionNumber + "[" + pathInfo.instanceNumber + "]";
                    locationPath = locationPath + "." + pathInfo.locationName + "[" + pathInfo.instanceNumber + "]";

                    if (i == $scope.newConstraint.pathInfoSet_1.length - 1) {
                        locationPath = locationPath + " (" + pathInfo.nodeName + ")";
                    }
                }
            }
            $scope.newConstraint.position_1 = positionPath.substr(1);
            $scope.newConstraint.location_1 = $rootScope.datatype.name + '-' + locationPath.substr(1);
        }
    };

    $scope.generateSecondPositionAndLocationPath = function() {
        if ($scope.newConstraint.pathInfoSet_2) {
            var positionPath = '';
            var locationPath = '';
            for (var i in $scope.newConstraint.pathInfoSet_2) {
                if (i > 0) {
                    var pathInfo = $scope.newConstraint.pathInfoSet_2[i];
                    positionPath = positionPath + "." + pathInfo.positionNumber + "[" + pathInfo.instanceNumber + "]";
                    locationPath = locationPath + "." + pathInfo.locationName + "[" + pathInfo.instanceNumber + "]";

                    if (i == $scope.newConstraint.pathInfoSet_2.length - 1) {
                        locationPath = locationPath + " (" + pathInfo.nodeName + ")";
                    }
                }
            }
            $scope.newConstraint.position_2 = positionPath.substr(1);
            $scope.newConstraint.location_2 = $rootScope.datatype.name + '-' + locationPath.substr(1);
        }
    };

    $scope.deleteConformanceStatement = function(conformanceStatement) {
        $scope.tempComformanceStatements.splice($scope.tempComformanceStatements.indexOf(conformanceStatement), 1);
        $scope.changed = true;
    };

    $scope.addComplexConformanceStatement = function() {
        $scope.complexConstraint = $rootScope.generateCompositeConformanceStatement($scope.compositeType, $scope.firstConstraint, $scope.secondConstraint, $scope.constraints);
        $scope.tempComformanceStatements.push($scope.complexConstraint);
        $scope.initComplexStatement();
        $scope.changed = true;
    };

    $scope.addFreeTextConformanceStatement = function() {
        var cs = $rootScope.generateFreeTextConformanceStatement($scope.newConstraint);
        $scope.tempComformanceStatements.push(cs);
        $scope.changed = true;
        $scope.initConformanceStatement();
    };

    $scope.addConformanceStatement = function() {
        var cs = $rootScope.generateConformanceStatement($scope.newConstraint);
        $scope.tempComformanceStatements.push(cs);
        $scope.changed = true;
        $scope.initConformanceStatement();
    };

    $scope.ok = function() {
        $modalInstance.close();
    };

    $scope.saveclose = function() {
        angular.copy($scope.tempComformanceStatements, $rootScope.datatype.conformanceStatements);
        $rootScope.recordChanged();
        $modalInstance.close($rootScope.datatype);
    };
});


angular.module('igl').controller('PredicateDatatypeCtrl', function($scope, $modalInstance, selectedNode, $rootScope, $q) {
    $scope.selectedNode = selectedNode;
    $scope.constraintType = 'Plain';
    $scope.constraints = [];
    $scope.firstConstraint = null;
    $scope.secondConstraint = null;
    $scope.compositeType = null;
    $scope.complexConstraint = null;
    $scope.changed = false;
    $scope.existingPredicate = null;
    $scope.tempPredicates = [];
    $scope.selectedDatatype = angular.copy($rootScope.datatype);
    $scope.predicateData = null;

    $scope.treeDataForContext = [];
    $scope.treeDataForContext.push($scope.selectedDatatype);
    $scope.treeDataForContext[0].pathInfoSet = [];
    $scope.generatePathInfo = function(current, positionNumber, locationName, instanceNumber, isInstanceNumberEditable, nodeName) {
        var pathInfo = {};
        pathInfo.positionNumber = positionNumber;
        pathInfo.locationName = locationName;
        pathInfo.nodeName = nodeName;
        pathInfo.instanceNumber = instanceNumber;
        pathInfo.isInstanceNumberEditable = isInstanceNumberEditable;
        current.pathInfoSet.push(pathInfo);

        if (current.type == 'datatype') {
            var dt = current;
            for (var i in dt.components) {
                var c = dt.components[i];
                c.pathInfoSet = angular.copy(current.pathInfoSet);

                var childPositionNumber = c.position;
                var childLocationName = c.position;
                var childNodeName = c.name;
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                var child = angular.copy($rootScope.datatypesMap[c.datatype.id]);
                child.id = new ObjectId().toString();
                c.child = child;
                $scope.generatePathInfo(c, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName);
            }
        } else if (current.type == 'component') {
            var dt = current.child;
            for (var i in dt.components) {
                var c = dt.components[i];
                c.pathInfoSet = angular.copy(current.pathInfoSet);
                var childPositionNumber = c.position;
                var childLocationName = c.position;
                var childNodeName = c.name;
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                var child = angular.copy($rootScope.datatypesMap[c.datatype.id]);
                child.id = new ObjectId().toString();
                c.child = child;
                $scope.generatePathInfo(c, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName);
            }
        }
    };

    $scope.generatePathInfo($scope.treeDataForContext[0], ".", ".", "1", false);

    $scope.toggleChildren = function(data) {
        data.childrenVisible = !data.childrenVisible;
        data.folderClass = data.childrenVisible ? "fa-minus" : "fa-plus";
    };

    $scope.beforeNodeDrop = function() {
        var deferred = $q.defer();
        deferred.resolve();
        return deferred.promise;
    };

    $scope.afterNodeDrop = function() {
        $scope.draggingStatus = null;
        $scope.newConstraint.pathInfoSet_1 = $scope.firstNodeData.pathInfoSet;
        $scope.generateFirstPositionAndLocationPath();
    };

    $scope.afterSecondNodeDrop = function() {
        $scope.draggingStatus = null;
        $scope.newConstraint.pathInfoSet_2 = $scope.secondNodeData.pathInfoSet;
        $scope.generateSecondPositionAndLocationPath();
    };

    $scope.beforePredicateDrop = function() {
        var deferred = $q.defer();

        if ($scope.draggingStatus === 'PredicateDragging') {
            $scope.predicateData = null;
            deferred.resolve();
        } else {
            deferred.reject();
        }
        return deferred.promise;
    };

    $scope.afterPredicateDrop = function() {
        $scope.draggingStatus = null;
        $scope.existingPredicate = $scope.predicateData;
        $scope.existingPredicate.constraintTarget = $scope.selectedNode.position + '[1]';
    };



    $scope.draggingPredicate = function(event, ui, nodeData) {
        $scope.draggingStatus = 'PredicateDragging';
    };

    $scope.draggingNodeFromContextTree = function(event, ui, data) {
        $scope.draggingStatus = 'ContextTreeNodeDragging';
    };

    $scope.setChanged = function() {
        $scope.changed = true;
    }

    $scope.initPredicate = function() {
        $scope.newConstraint = angular.fromJson({
            pathInfoSet_1: null,
            pathInfoSet_2: null,
            position_1: null,
            position_2: null,
            location_1: null,
            location_2: null,
            freeText: null,
            verb: null,
            ignoreCase: false,
            contraintType: null,
            value: null,
            value2: null,
            valueSetId: null,
            bindingStrength: 'R',
            bindingLocation: '1'
        });
    };

    $scope.initComplexPredicate = function() {
        $scope.constraints = [];
        $scope.firstConstraint = null;
        $scope.secondConstraint = null;
        $scope.compositeType = null;
    };

    $scope.generateFirstPositionAndLocationPath = function() {
        if ($scope.newConstraint.pathInfoSet_1) {
            var positionPath = '';
            var locationPath = '';
            for (var i in $scope.newConstraint.pathInfoSet_1) {
                if (i > 0) {
                    var pathInfo = $scope.newConstraint.pathInfoSet_1[i];
                    positionPath = positionPath + "." + pathInfo.positionNumber + "[" + pathInfo.instanceNumber + "]";
                    locationPath = locationPath + "." + pathInfo.locationName + "[" + pathInfo.instanceNumber + "]";

                    if (i == $scope.newConstraint.pathInfoSet_1.length - 1) {
                        locationPath = locationPath + " (" + pathInfo.nodeName + ")";
                    }
                }
            }

            $scope.newConstraint.position_1 = positionPath.substr(1);
            $scope.newConstraint.location_1 = $rootScope.datatype.name + '.' + locationPath.substr(1);
        }
    };

    $scope.generateSecondPositionAndLocationPath = function() {
        if ($scope.newConstraint.pathInfoSet_2) {
            var positionPath = '';
            var locationPath = '';
            for (var i in $scope.newConstraint.pathInfoSet_2) {
                if (i > 0) {
                    var pathInfo = $scope.newConstraint.pathInfoSet_2[i];
                    positionPath = positionPath + "." + pathInfo.positionNumber + "[" + pathInfo.instanceNumber + "]";
                    locationPath = locationPath + "." + pathInfo.locationName + "[" + pathInfo.instanceNumber + "]";

                    if (i == $scope.newConstraint.pathInfoSet_2.length - 1) {
                        locationPath = locationPath + " (" + pathInfo.nodeName + ")";
                    }
                }
            }

            $scope.newConstraint.position_2 = positionPath.substr(1);
            $scope.newConstraint.location_2 = $rootScope.datatype.name + '.' + locationPath.substr(1);
        }
    };

    $scope.findExistingPredicate = function() {
        for (var i = 0, len1 = $scope.selectedDatatype.predicates.length; i < len1; i++) {
            if ($scope.selectedDatatype.predicates[i].constraintTarget.indexOf($scope.selectedNode.position + '[') === 0)
                return $scope.selectedDatatype.predicates[i];
        }
    };

    $scope.deletePredicate = function() {
        $scope.existingPredicate = null;
        $scope.setChanged();
    };

    $scope.deleteTempPredicate = function(predicate) {
        $scope.tempPredicates.splice($scope.tempPredicates.indexOf(predicate), 1);
    };

    $scope.deletePredicateByTarget = function() {
        for (var i = 0, len1 = $scope.selectedDatatype.predicates.length; i < len1; i++) {
            if ($scope.selectedDatatype.predicates[i].constraintTarget.indexOf($scope.selectedNode.position + '[') === 0) {
                $scope.selectedDatatype.predicates.splice($scope.selectedDatatype.predicates.indexOf($scope.selectedDatatype.predicates[i]), 1);
                return true;
            }
        }
        return false;
    };

    $scope.addComplexPredicate = function() {
        $scope.complexConstraint = $rootScope.generateCompositePredicate($scope.compositeType, $scope.firstConstraint, $scope.secondConstraint, $scope.constraints);
        $scope.complexConstraint.constraintId = $scope.newConstraint.segment + '-' + $scope.selectedNode.position;
        $scope.tempPredicates.push($scope.complexConstraint);
        $scope.initComplexPredicate();
        $scope.changed = true;
    };

    $scope.addFreeTextPredicate = function() {
        var cp = $rootScope.generateFreeTextPredicate($scope.selectedNode.position + '[1]', $scope.newConstraint);
        $scope.tempPredicates.push(cp);
        $scope.changed = true;
        $scope.initPredicate();
    };

    $scope.addPredicate = function() {
        var cp = $rootScope.generatePredicate($scope.selectedNode.position + '[1]', $scope.newConstraint);
        $scope.tempPredicates.push(cp);
        $scope.changed = true;
        $scope.initPredicate();
    };

    $scope.ok = function() {
        $modalInstance.close();
    };

    $scope.saveclose = function() {
        $scope.deletePredicateByTarget();
        $scope.selectedDatatype.predicates.push($scope.existingPredicate);
        $rootScope.recordChanged();
        $modalInstance.close($scope.selectedDatatype);
    };

    $scope.initPredicate();
    $scope.initComplexPredicate();
    $scope.existingPredicate = $scope.findExistingPredicate();
});

angular.module('igl').controller('AddComponentCtrl', function($scope, $modalInstance, datatypes, datatype, valueSets, $rootScope, $http, ngTreetableParams, SegmentService, DatatypeLibrarySvc, MessageService, blockUI) {

    $scope.valueSets = valueSets;
    $scope.datatypes = datatypes;


    $scope.newComponent = {
        comment: "",
        confLength: "",
        datatype: {
            ext: null,
            id: "",
            label: "",
            name: "",
        },
        hide: false,
        id: "",
        maxLength: "",
        minLength: "",
        name: "",
        position: "",
        table: {
            bindingIdentifier: "",
            bindingLocation: null,
            bindingStrength: null,
            id: ""
        },
        text: "",
        type: "component",
        usage: ""


    };

    $scope.$watch('DT', function() {
        if ($scope.DT) {
            $scope.newComponent.datatype.ext = $scope.DT.ext;
            $scope.newComponent.datatype.id = $scope.DT.id;
            $scope.newComponent.datatype.name = $scope.DT.name;
            $scope.newComponent.datatype.label = $scope.DT.label;


        }
        console.log($scope.DT);

    }, true);

    $scope.$watch('VS', function() {
        if ($scope.VS) {
            $scope.newComponent.table.bindingIdentifier = $scope.VS.bindingIdentifier;
            $scope.newComponent.table.id = $scope.VS.id;


        }

    }, true);


    $scope.selectDT = function(datatype) {
        $scope.DT = datatype;
    };
    $scope.selectedDT = function() {
        return ($scope.DT !== undefined);
    };
    $scope.unselectDT = function() {
        $scope.DT = undefined;
    };
    $scope.isDTActive = function(id) {
        if ($scope.DT) {
            return $scope.DT.id === id;
        } else {
            return false;
        }

    };
    $scope.selectUsage = function(usage) {
        console.log(usage);
        if (usage === 'X' || usage === 'W') {
            $scope.newComponent.max = 0;
            $scope.newComponent.min = 0;
            $scope.disableMin = true;
            $scope.disableMax = true;

        } else if (usage === 'R') {
            $scope.newComponent.min = 1;

            $scope.disableMin = true;
            $scope.disableMax = false;
        } else if (usage === 'RE' || usage === 'O') {
            $scope.newComponent.min = 0;

            $scope.disableMin = true;
            $scope.disableMax = false;

        } else {
            $scope.disableMin = false;
            $scope.disableMax = false;

        }

    };


    $scope.selectVS = function(valueSet) {
        $scope.VS = valueSet;
    };
    $scope.selectedVS = function() {
        return ($scope.VS !== undefined);
    };
    $scope.unselectVS = function() {
        $scope.VS = undefined;
    };
    $scope.isVSActive = function(id) {
        if ($scope.VS) {
            return $scope.VS.id === id;
        } else {
            return false;
        }

    };


    $scope.addComponent = function() {
        blockUI.start();
        if ($rootScope.datatype.components.length !== 0) {
            $scope.newComponent.position = $rootScope.datatype.components[$rootScope.datatype.components.length - 1].position + 1;

        } else {
            $scope.newComponent.position = 1;
        }

        $scope.newComponent.id = new ObjectId().toString();

        if ($rootScope.datatype != null) {
            if (!$rootScope.datatype.components || $rootScope.datatype.components === null)
                $rootScope.datatype.components = [];
            $rootScope.datatype.components.push($scope.newComponent);
            MessageService.updatePosition(datatype.components, $scope.newComponent.position - 1, $scope.position - 1);





        }
        blockUI.stop();
        $modalInstance.close();

    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


});

angular.module('igl').controller('DeleteComponentCtrl', function($scope, $modalInstance, componentToDelete, datatype, $rootScope, SegmentService, blockUI) {
    $scope.componentToDelete = componentToDelete;
    $scope.loading = false;
    console.log(datatype);
    console.log($scope.componentToDelete);
    $scope.updatePosition = function(node) {
        angular.forEach(node.components, function(component) {
            component.position = node.components.indexOf(component) + 1;

        })

    };
    $scope.delete = function() {
        blockUI.start();
        $scope.loading = true;
        datatype.components.splice(componentToDelete.position - 1, 1);


        $rootScope.msg().text = "ComponentDeleteSuccess";

        $rootScope.msg().type = "success";
        $rootScope.msg().show = true;
        $rootScope.manualHandle = true;
        $scope.loading = false;
        $scope.updatePosition(datatype);
        $modalInstance.close($scope.componentToDelete);
        blockUI.stop();

    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


});

angular.module('igl').controller('cmpDatatypeCtrl', function($scope, $modal, ObjectDiff, orderByFilter, $rootScope, $q, $interval, ngTreetableParams, $http, StorageService, userInfoService, IgDocumentService, SegmentService, DatatypeService, SegmentLibrarySvc, DatatypeLibrarySvc, TableLibrarySvc, CompareService) {
    var ctrl = this;
    this.datatypeId = -1;
    $scope.dtChanged = false;
    $scope.isDeltaCalled = false;
    $scope.setDeltaToF = function() {
        console.log("HEEEEEERREEEEE");
        $scope.isDeltaCalled = false;
    }



    $scope.scopes = [{
        name: "USER",
        alias: "My IG"
    }, {
        name: "HL7STANDARD",
        alias: "Base HL7"
    }];

    $scope.getLabel = function(element) {
        if (element) {
            if (element.ext !== null) {
                return element.name + "_" + element.ext;
            } else {
                return element.name;
            }
        }

    };
    var listHL7Versions = function() {
        return $http.get('api/igdocuments/findVersions', {
            timeout: 60000
        }).then(function(response) {
            var hl7Versions = [];
            var length = response.data.length;
            for (var i = 0; i < length; i++) {
                hl7Versions.push(response.data[i]);
            }
            return hl7Versions;
        });
    };
    $scope.status = {
        isCustomHeaderOpen: false,
        isFirstOpen: true,
        isSecondOpen: true,
        isFirstDisabled: false
    };

    $scope.initt = function() {
        $scope.isDeltaCalled = true;
        $scope.dataList = [];
        listHL7Versions().then(function(versions) {
            $scope.versions = versions;
            if ($rootScope.igdocument && $rootScope.igdocument != null) {
                $scope.datatype1 = angular.copy($rootScope.datatype);

                $scope.version1 = angular.copy($scope.datatype1.hl7Version);
                $scope.scope1 = "USER";
                $scope.ig1 = angular.copy($rootScope.igdocument.metaData.title);
                ctrl.datatypeId = -1;
                $scope.variable = !$scope.variable;


                $scope.segments2 = null;
                //$scope.setIG2($scope.ig2);
                $scope.segList1 = angular.copy($rootScope.segments);
                $scope.dtList1 = angular.copy($rootScope.datatypes);
                $scope.version2 = angular.copy($scope.version1);
                console.log($scope.scopes);
                console.log($scope.scopes[1]);
            }
            //$scope.status.isFirstOpen = true;
            $scope.scope2 = "HL7STANDARD";
            if ($scope.dynamicDt_params) {
                $scope.showDelta = false;
                $scope.status.isFirstOpen = true;
                $scope.dynamicDt_params.refresh();
            }

        });



    };

    $scope.$on('event:loginConfirmed', function(event) {
        $scope.initt();
    });

    //$scope.initt();

    $rootScope.$on('event:initDatatype', function(event) {
        console.log("$scope.isDeltaCalled");
        $scope.getAllVersionsOfDT($rootScope.datatype.id);
        console.log($scope.isDeltaCalled);
        if ($scope.isDeltaCalled) {
            $scope.initt();
        }
    });
    $rootScope.$on('event:openDTDelta', function(event) {
        $scope.initt();
    });



    $scope.setVersion2 = function(vr) {
        $scope.version2 = vr;

    };
    $scope.setScope2 = function(scope) {

        $scope.scope2 = scope;
    };

    $scope.$watchGroup(['datatype1', 'datatype2'], function() {
        $scope.dtChanged = true;
        //$scope.segment1 = angular.copy($rootScope.activeSegment);
    }, true);
    $scope.$watchGroup(['version2', 'scope2', 'variable'], function() {
        $scope.igList2 = [];
        $scope.segments2 = [];
        $scope.ig2 = "";
        if ($scope.scope2 && $scope.version2) {
            IgDocumentService.getIgDocumentsByScopesAndVersion([$scope.scope2], $scope.version2).then(function(result) {
                if (result) {
                    if ($scope.scope2 === "HL7STANDARD") {
                        $scope.igDisabled2 = true;
                        $scope.ig2 = {
                            id: result[0].id,
                            title: result[0].metaData.title
                        };
                        $scope.igList2.push($scope.ig2);

                        $scope.setIG2($scope.ig2);
                    } else {
                        $scope.igDisabled2 = false;
                        for (var i = 0; i < result.length; i++) {
                            $scope.igList2.push({
                                id: result[i].id,
                                title: result[i].metaData.title,
                            });
                        }
                    }
                }
            });

        }

    }, true);
    $scope.setDatatype2 = function(datatype) {
        if (datatype === -1) {
            $scope.datatype2 = {};
        } else {
            $scope.datatype2 = $scope.datatypes2[datatype];

        }
    };
    $scope.setIG2 = function(ig) {
        if (ig) {
            IgDocumentService.getOne(ig.id).then(function(igDoc) {
                SegmentLibrarySvc.getSegmentsByLibrary(igDoc.profile.segmentLibrary.id).then(function(segments) {
                    DatatypeLibrarySvc.getDatatypesByLibrary(igDoc.profile.datatypeLibrary.id).then(function(datatypes) {
                        TableLibrarySvc.getTablesByLibrary(igDoc.profile.tableLibrary.id).then(function(tables) {
                            $scope.segments2 = [];
                            $scope.segment2 = "";
                            if (igDoc) {
                                $scope.segList2 = angular.copy(segments);
                                //$scope.segList2 = orderByFilter($scope.segList2, 'name');
                                $scope.dtList2 = angular.copy(datatypes);
                                $scope.tableList2 = angular.copy(tables);
                                //$scope.messages2 = orderByFilter(igDoc.profile.messages.children, 'name');
                                //$scope.segments2 = orderByFilter(segments, 'name');
                                $scope.datatypes2 = orderByFilter(datatypes, 'name');
                                //$scope.tables2 = orderByFilter(tables, 'bindingIdentifier');
                            }
                        });
                    });
                });

            });

            //$scope.messages2 = ($scope.findIGbyID(JSON.parse(ig).id)).profile.messages.children;

        }

    };

    $scope.hideDT = function(dt1, dt2) {

        if (dt2) {
            return !(dt1.name === dt2.name);
        } else {
            return false;
        }
    };
    $scope.disableDT = function(dt1, dt2) {

        if (dt2) {
            return (dt1.id === dt2.id);
        } else {
            return false;
        }
    };




    $scope.dynamicDt_params = new ngTreetableParams({
        getNodes: function(parent) {
            if ($scope.dataList !== undefined) {

                //return parent ? parent.fields : $scope.test;
                if (parent) {
                    if (parent.fields) {
                        return parent.fields;
                    } else if (parent.components) {
                        return parent.components;
                    } else if (parent.segments) {
                        return parent.segments;
                    } else if (parent.codes) {
                        return parent.codes;
                    }

                } else {
                    return $scope.dataList;
                }

            }
        },
        getTemplate: function(node) {
            return 'tree_node';
        }
    });
    $scope.cmpDatatype = function(datatype1, datatype2) {

        $scope.loadingSelection = true;
        $scope.dtChanged = false;
        $scope.vsTemplate = false;
        $scope.dataList = CompareService.cmpDatatype(JSON.stringify(datatype1), JSON.stringify(datatype2), $scope.dtList1, $scope.dtList2, $scope.segList1, $scope.segList2);
        console.log("hg==========");
        console.log($scope.dataList);
        $scope.loadingSelection = false;
        if ($scope.dynamicDt_params) {
            console.log($scope.dataList);
            $scope.showDelta = true;
            $scope.status.isSecondOpen = true;
            $scope.dynamicDt_params.refresh();
        }

    };
});

angular.module('igl').controller('DeleteDatatypePredicateCtrl', function($scope, $modalInstance, position, datatype, $rootScope) {
    $scope.selectedDatatype = datatype;
    $scope.position = position;
    $scope.delete = function() {
        for (var i = 0, len1 = $scope.selectedDatatype.predicates.length; i < len1; i++) {
            if ($scope.selectedDatatype.predicates[i].constraintTarget.indexOf($scope.position + '[') === 0) {
                $scope.selectedDatatype.predicates.splice($scope.selectedDatatype.predicates.indexOf($scope.selectedDatatype.predicates[i]), 1);
                $modalInstance.close();
                return;
            }
        }
        $modalInstance.close();
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});


angular.module('igl').controller('AddBindingForDatatype', function($scope, $modalInstance, $rootScope, datatype) {
    console.log($rootScope.references);
    $scope.datatype = datatype;
    $scope.selectedSegmentForBinding = null;
    $scope.selectedFieldForBinding = null;
    $scope.selectedDatatypeForBinding = null;
    $scope.selectedComponentForBinding = null;

    $scope.pathForBinding = null;
    $scope.bindingTargetType = 'DATATYPE';

    $scope.init = function() {
        $scope.selectedSegmentForBinding = null;
        $scope.selectedFieldForBinding = null;
        $scope.selectedDatatypeForBinding = null;
        $scope.selectedComponentForBinding = null;
        $scope.pathForBinding = null;
        $scope.currentField = null;
        $scope.currentComp = null;

    };

    $scope.checkDuplicated = function(path) {
        for (var i = 0; i < $rootScope.references.length; i++) {
            var ref = $rootScope.references[i];
            if (ref.path == path) return true;
        }
        return false;
    };

    $scope.selectSegment = function() {
        $scope.selectedFieldForBinding = null;
        $scope.currentField = null;
    };
    $scope.selectField = function() {
        console.log($scope.selectedFieldForBinding);
        if ($scope.selectedFieldForBinding) {
            $scope.currentField = JSON.parse($scope.selectedFieldForBinding);
            console.log($rootScope.datatypesMap[$scope.currentField.datatype.id]);

        }
    };
    $scope.selectComp = function() {
        if ($scope.selectedComponentForBinding) {
            $scope.currentComp = JSON.parse($scope.selectedComponentForBinding);

        }
    };


    $scope.selectDatatype = function() {
        $scope.selectedComponentForBinding = null;
        $scope.currentComp = null;
    };

    $scope.save = function(bindingTargetType) {
        var datatypeLink = {};
        datatypeLink.id = $scope.datatype.id;
        datatypeLink.name = $scope.datatype.bindingIdentifier;
        datatypeLink.ext = $scope.datatype.ext;
        datatypeLink.label = $scope.datatype.label;
        datatypeLink.isChanged = true;
        datatypeLink.isNew = true;

        if (bindingTargetType == 'SEGMENT') {
            $scope.selectedFieldForBinding = JSON.parse($scope.selectedFieldForBinding);
            $scope.pathForBinding = $rootScope.getSegmentLabel($scope.selectedSegmentForBinding) + '-' + $scope.selectedFieldForBinding.position;

            var ref = angular.copy($scope.selectedFieldForBinding);
            ref.path = $scope.pathForBinding;
            ref.target = angular.copy($scope.selectedSegmentForBinding);
            ref.datatypeLink = angular.copy(datatypeLink);
            $rootScope.references.push(ref);
        } else {
            $scope.selectedComponentForBinding = JSON.parse($scope.selectedComponentForBinding);
            $scope.pathForBinding = $rootScope.getDatatypeLabel($scope.selectedDatatypeForBinding) + '-' + $scope.selectedComponentForBinding.position;

            var ref = angular.copy($scope.selectedComponentForBinding);
            ref.path = $scope.pathForBinding;
            ref.target = angular.copy($scope.selectedDatatypeForBinding);
            ref.datatypeLink = angular.copy(datatypeLink);
            $rootScope.references.push(ref);
        }

        $modalInstance.close();
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});

angular.module('igl').controller('ShareDatatypeCtrl', function($scope, $modalInstance, $http, igdocumentSelected, userList, DatatypeService, $rootScope) {

    $scope.igdocumentSelected = igdocumentSelected;

    // Add participants username and fullname
    // Find share participants
    if ($scope.igdocumentSelected.shareParticipantIds && $scope.igdocumentSelected.shareParticipantIds.length > 0) {
        $scope.igdocumentSelected.shareParticipantIds.forEach(function(participant) {
            $http.get('api/shareparticipant', { params: { id: participant.accountId } })
                .then(
                    function(response) {
                        participant.username = response.data.username;
                        participant.fullname = response.data.fullname;
                    },
                    function(error) {
                        console.log(error);
                    }
                );
        });
    }
    $scope.userList = userList;
    $scope.error = "";
    $scope.tags = [];
    $scope.ok = function() {
        var idsTab = $scope.tags.map(function(user) {
            return user.accountId;
        });

        DatatypeService.share($scope.igdocumentSelected.id, idsTab, $rootScope.accountId).then(function(result) {
            // Add participants for direct view
            $scope.igdocumentSelected.shareParticipantIds = $scope.igdocumentSelected.shareParticipantIds || [];
            $scope.tags.forEach(function(tag) {
                tag.permission = $scope.selectedItem.selected;
                tag.pendingApproval = true;
                $scope.igdocumentSelected.shareParticipantIds.push(tag);
            });
            $rootScope.msg().text = "dtSharedSuccessfully";
            $rootScope.msg().type = "success";
            $rootScope.msg().show = true;
            $modalInstance.close();
        }, function(error) {
            $scope.error = error.data;
            console.log(error);
        });
    };
    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };

    $scope.selectedItem = {
        selected: "VIEW"
    };
    $scope.itemArray = ["VIEW"];

    $scope.loadUsernames = function($query) {
        return userList.filter(function(user) {
            return user.username.toLowerCase().indexOf($query.toLowerCase()) != -1;
        });
    };

    $scope.unshare = function(shareParticipant) {
        $scope.loading = false;
        DatatypeService.unshare($scope.igdocumentSelected.id, shareParticipant.accountId).then(function(res) {
            var indexOfId = $scope.igdocumentSelected.shareParticipantIds.indexOf(shareParticipant.accountId);
            if (indexOfId > -1) {
                $scope.igdocumentSelected.shareParticipantIds.splice(indexOfId, 1);
            }
            var participantIndex = -1;
            for (var i = 0; i < $scope.igdocumentSelected.shareParticipantIds.length; i++) {
                if ($scope.igdocumentSelected.shareParticipantIds[i].accountId === shareParticipant.accountId) {
                    participantIndex = i;
                    $scope.userList.push($scope.igdocumentSelected.shareParticipantIds[i]);
                    break;
                }
            }
            if (participantIndex > -1) {
                $scope.igdocumentSelected.shareParticipantIds.splice(participantIndex, 1);
            }
            $scope.loading = false;
            $rootScope.msg().text = "dtUnSharedSuccessfully";
            $rootScope.msg().type = "success";
            $rootScope.msg().show = true;
        }, function(error) {
            $rootScope.msg().text = error.data.text;
            $rootScope.msg().type = error.data.type;
            $rootScope.msg().show = true;
            $scope.loading = false;
        });
    };


});
angular.module('igl').controller('ConfirmDatatypePublishCtl', function($scope, $rootScope, $http, $modalInstance, datatypeToPublish) {

    $scope.datatypeToPublish = datatypeToPublish;
    $scope.loading = false;

    $scope.delete = function() {
        $modalInstance.close($scope.datatypeToPublish);
    };

    $scope.cancel = function() {
        $scope.datatypeToPublish.status = 'UNPUBLISHED';
        $rootScope.clearChanges();
        $modalInstance.dismiss('cancel');
    };
});

angular.module('igl').controller('AbortPublishCtl', function($scope, $rootScope, $http, $modalInstance, datatypeToPublish, unpublishedDatatypes, unpublishedTables) {

    $scope.datatypeToPublish = datatypeToPublish;
    $scope.loading = false;
    $scope.unpublishedDatatypes = unpublishedDatatypes;
    $scope.unpublishedTables = unpublishedTables;

    $scope.delete = function() {
        $modalInstance.close($scope.datatypeToPublish);
    };

    $scope.cancel = function() {
        //$scope.datatypeToPublish.status = "'UNPUBLISHED'";
        $modalInstance.dismiss('cancel');
    };
});
/**
 * Created by haffo on 1/12/15.
 */

'use strict';

angular.module('igl')
.controller('ForgottenCtrl', ['$scope', '$resource',
    function ($scope, $resource) {
        var ForgottenRequest = $resource('api/sooa/accounts/passwordreset', {username:'@username'});

        $scope.requestResetPassword =  function() {
            var resetReq = new ForgottenRequest();
            resetReq.username = $scope.username;
            resetReq.$save(function() {
                if ( resetReq.text === 'resetRequestProcessed' ) {
                    $scope.username = '';
                }
            });
        };
    }
]);

angular.module('igl').controller(
    'HL7VersionsDlgCtrl',
    function($scope, $rootScope, $modal, $log, $http, $httpBackend, userInfoService) {

        $rootScope.clickSource = {};
        $scope.selectedHL7Version = "";

        $rootScope.scrollbarWidth = $rootScope.getScrollbarWidth();

        $scope.hl7Versions = function(clickSource) {
            $rootScope.clickSource = clickSource;
            if ($rootScope.hasChanges()) {
                $rootScope.openConfirmLeaveDlg().result.then(function() {
                    $rootScope.clearChanges();
                    $rootScope.closeIGDocument();
                    $rootScope.hl7Versions = [];
                    $scope.hl7VersionsInstance();
                });
            } else {
                if (clickSource === 'btn' && $rootScope.igdocument != null) {
                    $rootScope.clearChanges();
                    $rootScope.closeIGDocument();
                }
                $rootScope.hl7Versions = [];
                $scope.hl7VersionsInstance();
            }
        };

        $scope.confirmOpen = function(igdocument) {
            return $modal.open({
                templateUrl: 'ConfirmIGDocumentOpenCtrl.html',
                controller: 'ConfirmIGDocumentOpenCtrl',
                resolve: {
                    igdocumentToOpen: function() {
                        return igdocument;
                    }
                }
            }).result.then(function(igdocument) {
                $rootScope.clearChanges();
                $scope.hl7VersionsInstance();
            }, function() {
                console.log("Changes discarded.");
            });
        };
        $scope.hl7VersionsInstance = function() {
            $scope.listHL7Versions().then(function(response) {
                var hl7Versions = [];
                var length = response.data.length;
                for (var i = 0; i < length; i++) {
                    hl7Versions.push(response.data[i]);
                }
                return $modal.open({
                    templateUrl: 'hl7VersionsDlg.html',
                    controller: 'HL7VersionsInstanceDlgCtrl',
                    windowClass: 'hl7-versions-modal',
                    resolve: {
                        hl7Versions: function() {
                            return hl7Versions;
                        },
                        hl7Version: function() {
                            console.log("$rootScope.clickSource=" + $rootScope.clickSource);
                            if ($rootScope.clickSource === "ctx") {
                                console.log("hl7Version=" + $rootScope.igdocument.profile.metaData.hl7Version);
                                return $rootScope.igdocument.profile.metaData.hl7Version;
                            } else {
                                return null;
                            }
                        }
                    }
                }).result.then(function(igdocument) {
                    $rootScope
                        .$emit(
                            'event:openIGDocumentRequest',
                            igdocument);
                    $rootScope.$broadcast('event:IgsPushed',
                        igdocument);
                });
            }, function(response) {
                $rootScope.msg().text = "Cannot load the versions. Please try again";
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
            });


        };

        $scope.listHL7Versions = function() {
            return $http.get('api/igdocuments/findVersions', {
                timeout: 60000
            });
        };


        $scope.closedCtxMenu = function(node, $index) {
            console.log("closedCtxMenu");
        };

    });

angular.module('igl').controller(
    'HL7VersionsInstanceDlgCtrl',
    function($scope, $rootScope, $modalInstance, $http, hl7Versions, ProfileAccessSvc, MessageEventsSvc, SegmentService, DatatypeService, TableService, TableLibrarySvc, SegmentLibrarySvc, DatatypeLibrarySvc, IgDocumentService, $timeout, ngTreetableParams, userInfoService, hl7Version, MessagesSvc) {

        $scope.hl7Versions = hl7Versions;
        $scope.hl7Version = hl7Version;
        $scope.selectedHL7Version = hl7Version;
        $scope.okDisabled = true;
        $scope.messageIds = [];
        $scope.messageEvents = [];
        $scope.loading = false;
        var messageEvents = [];
        $scope.messageEventsParams = null;
        $scope.scrollbarWidth = $rootScope.getScrollbarWidth();
        $scope.status = {
            isCustomHeaderOpen: false,
            isFirstOpen: true,
            isSecondOpen: true,
            isFirstDisabled: false
        };


        $scope.messageEventsParams = new ngTreetableParams({
            getNodes: function(parent) {
                return parent && parent != null ? parent.children : $scope.hl7Version != null ? MessageEventsSvc.getMessageEvents($scope.hl7Version) : [];
            },
            getTemplate: function(node) {
                return 'MessageEventsNode.html';
            }
        });


        $scope.loadIGDocumentsByVersion = function() {
            $scope.loading = true;
            $scope.eventList = [];
            $scope.selectedHL7Version = hl7Version;
            messageEvents = [];
            $timeout(function() {
                if ($scope.messageEventsParams)
                    $scope.messageEventsParams.refresh();
                $scope.loading = false;
            });
        };

        $scope.isBranch = function(node) {
            var rval = false;
            if (node.type === "message") {
                rval = true;
                MessageEventsSvc.putState(node);
            }
            return rval;
        };

        $scope.eventList = [];

        $scope.trackSelections = function(bool, event) {
            // console.log("event");
            // console.log(event);
            console.log(bool);



            if (bool) {
                $scope.eventList.push(event);
                messageEvents.push({
                    "id": event.id,
                    "children": [{
                        "name": event.name.trim(),
                        "parentStructId": event.parentStructId
                    }]
                });
            } else {
                console.log(messageEvents);
                for (var i = 0; i < messageEvents.length; i++) {

                    if (messageEvents[i].children[0].name == event.name.trim() && messageEvents[i].children[0].parentStructId == event.parentStructId) {
                        messageEvents.splice(i, 1);
                    }
                }
                for (var i = 0; i < $scope.eventList.length; i++) {
                    if ($scope.eventList[i].name == event.name && $scope.eventList[i].parentStructId == event.parentStructId) {
                        $scope.eventList.splice(i, 1);
                    }
                }
            }
            $scope.okDisabled = messageEvents.length === 0;
        };
        $scope.isChecked = function(node) {
            if ($scope.eventList.indexOf(node) !== -1) {
                return true;
            } else {
                return false;
            }
        };


        //        $scope.$watch(function () {
        //            return $rootScope.igdocument.id;
        //        }, function (newValue, oldValue) {
        //            if ($rootScope.clickSource === "ctx") {
        //                $scope.hl7Version = $rootScope.hl7Version;
        //                $scope.messageIds = ProfileAccessSvc.Messages().getMessageIds();
        //                $scope.loadIGDocumentsByVersion();
        //            }
        //        });

        $scope.ok = function() {
            // create new ig doc submitted.
            $scope.messageEvents = messageEvents;
            switch ($rootScope.clickSource) {
                case "btn":
                    {
                        if (!$scope.hl7VersionsDlgForm.$invalid) {
                            createIGDocument($scope.hl7Version, messageEvents);
                        }

                        break;
                    }
                case "ctx":
                    {
                        updateIGDocument(messageEvents);
                        break;
                    }
            }
        };

        var createIGDocument = function(hl7Version, msgEvts) {
            console.log("create Ig called");
            console.log($scope.hl7VersionsDlgForm);
            var iprw = {
                "hl7Version": hl7Version,
                "msgEvts": msgEvts,
                "metaData": $scope.hl7VersionsDlgForm.metaData,
                "accountID": userInfoService.getAccountID(),
                "timeout": 60000
            };
            $scope.okDisabled = true;
            $http.post('api/igdocuments/createIntegrationProfile', iprw)
                .then(
                    function(response) {
                        var igdocument = angular
                            .fromJson(response.data);
                        $modalInstance.close(igdocument);
                    },
                    function(response) {
                        $rootScope.msg().text = response.data;
                        $rootScope.msg().type = "danger";
                        $rootScope.msg().show = true;
                        $scope.okDisabled = false;
                    });
        };

        /**
         * TODO: Handle error from server
         *
         * @param msgIds
         */
        var updateIGDocument = function(msgEvts) {
            $rootScope.usedSegsLink = [];
            $rootScope.usedDtLink = [];
            $rootScope.usedVsLink = [];
            console.log("msgEvts");
            console.log(msgEvts);

            var events = [];

            var scope = "HL7STANDARD";
            var version = $rootScope.igdocument.profile.metaData.hl7Version;
            console.log($rootScope.igdocument);


            console.log("update Ig called");
            console.log(msgEvts);
            for (var i = 0; i < msgEvts.length; i++) {
                //events.push(msgEvts[i].children[0]);
                events.push({
                    name: msgEvts[i].children[0].name,
                    parentStructId: msgEvts[i].children[0].parentStructId,
                    scope: "HL7STANDARD",
                    hl7Version: version

                });
            }
            console.log("namesAndSctruct");
            console.log(events);

            IgDocumentService.findAndAddMessages($rootScope.igdocument.id, events).then(function(result) {
                console.log("result==========");
                console.log(result);
                var msgsId = [];
                for (var i = 0; i < result.length; i++) {
                    if (result[i].id) {
                        msgsId.push(result[i].id);
                    }

                }
                for (var i = 0; i < result.length; i++) {
                    console.log("result[i]==========");
                    console.log(result[i]);
                    //result[i].id = new ObjectId().toString();
                    $rootScope.igdocument.profile.messages.children.push(result[i]);
                    $rootScope.messagesMap[result[i].id] = result[i];
                    $rootScope.fillMaps(result[i]);
                    console.log($rootScope.usedSegsLink);
                    console.log($rootScope.usedDtLink);
                    console.log($rootScope.usedVsLink);
                }
                var usedSegsId = _.map($rootScope.usedSegsLink, function(num, key) {
                    return num.id;
                });
                var newSegmentsLink = _.difference($rootScope.usedSegsLink, $rootScope.igdocument.profile.segmentLibrary.children);

                SegmentLibrarySvc.addChildren($rootScope.igdocument.profile.segmentLibrary.id, newSegmentsLink).then(function() {

                    SegmentService.findByIds(usedSegsId).then(function(segments) {
                        for (var j = 0; j < segments.length; j++) {
                            if (!$rootScope.segmentsMap[segments[j].id]) {
                                $rootScope.fillMaps(segments[j]);
                                $rootScope.segmentsMap[segments[j].id] = segments[j];
                                $rootScope.segments.push(segments[j]);
                            }
                        }
                        var usedDtId = _.map($rootScope.usedDtLink, function(num, key) {
                            return num.id;
                        });
                        DatatypeService.get(usedDtId).then(function(datatypes) {
                            for (var j = 0; j < datatypes.length; j++) {

                                $rootScope.fillMaps(datatypes[j]);

                            }
                            var usedDtId1 = _.map($rootScope.usedDtLink, function(num, key) {
                                return num.id;
                            });
                            var newDatatypesLink = _.difference($rootScope.usedDtLink, $rootScope.igdocument.profile.datatypeLibrary.children);

                            DatatypeLibrarySvc.addChildren($rootScope.igdocument.profile.datatypeLibrary.id, newDatatypesLink).then(function() {
                                DatatypeService.get(usedDtId1).then(function(datatypes) {
                                    for (var j = 0; j < datatypes.length; j++) {
                                        if (!$rootScope.datatypesMap[datatypes[j].id]) {
                                            $rootScope.datatypesMap[datatypes[j].id] = datatypes[j];
                                            $rootScope.datatypes.push(datatypes[j]);
                                            console.log($rootScope.datatypesMap[datatypes[j].id]);
                                        }
                                    }

                                    var usedVsId = _.map($rootScope.usedVsLink, function(num, key) {
                                        return num.id;
                                    });
                                    var newTablesLink = _.difference($rootScope.usedVsLink, $rootScope.igdocument.profile.tableLibrary.children);
                                    TableLibrarySvc.addChildren($rootScope.igdocument.profile.tableLibrary.id, newTablesLink).then(function() {
                                        TableService.get(usedVsId).then(function(tables) {
                                            for (var j = 0; j < tables.length; j++) {
                                                if (!$rootScope.tablesMap[tables[j].id]) {
                                                    $rootScope.tablesMap[tables[j].id] = tables[j];
                                                    $rootScope.tables.push(tables[j]);
                                                }
                                            }


                                            for (var i = 0; i < result.length; i++) {
                                                console.log("=+++++result");
                                                console.log(result);
                                                $rootScope.processMessageTree(result[i]);
                                            }

                                        });
                                    });


                                });
                            });
                        });




                    });
                });
                console.log($rootScope.igdocument.profile.messages);
                console.log("$rootScope.segmentsMap");



                $modalInstance.dismiss('cancel');
            }, function(response) {
                $rootScope.msg().text = response.data;
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
                $scope.okDisabled = false;
            });
            $scope.okDisabled = true;
            var iprw = {
                "igdocument": $rootScope.igdocument,
                "msgEvts": msgEvts,
                "timeout": 60000
            };
            // $http.post('api/igdocuments/updateIntegrationProfile', iprw)
            //     .then(
            //     function (response) {
            //         var igdocument = angular
            //             .fromJson(response.data);
            //         $modalInstance.close(igdocument);
            //     }, function (response) {
            //         $rootScope.msg().text = response.data;
            //         $rootScope.msg().type = "danger";
            //         $rootScope.msg().show = true;
            //         $scope.okDisabled = false;
            //     });
        };

        if ($scope.hl7Version != null) {
            $scope.loadIGDocumentsByVersion();
        }

        $scope.cancel = function() {
            $modalInstance.dismiss('cancel');
        };
    });
'use strict';

/* "newcap": false */

angular.module('igl')
    .controller('IdleCtrl', function($scope, Idle, Keepalive, $modal,IdleService){
//        $scope.started = false;
//
//        function closeModals() {
//            if ($scope.warning) {
//                $scope.warning.close();
//                $scope.warning = null;
//            }
//
//            if ($scope.timedout) {
//                $scope.timedout.close();
//                $scope.timedout = null;
//            }
//        }
//
//        $scope.$on('IdleStart', function() {
//            closeModals();
//
//            $scope.warning = $modal.open({
//                templateUrl: 'warning-dialog.html',
//                windowClass: 'modal-danger'
//            });
//        });
//
//        $scope.$on('IdleEnd', function() {
//            closeModals();
//        });
//
//        $scope.$on('IdleTimeout', function() {
//            closeModals();
//            $scope.timedout = $modal.open({
//                templateUrl: 'timedout-dialog.html',
//                windowClass: 'modal-danger'
//            });
//        });
//
//        $scope.$on('Keepalive', function() {
//            IdleService.keepAlive();
//        });
//
//
//        $scope.start = function() {
//            closeModals();
//            Idle.watch();
//            $scope.started = true;
//        };
//
//        $scope.stop = function() {
//            closeModals();
//            Idle.unwatch();
//            $scope.started = false;
//
//        };
    });


/**
 * Created by haffo on 1/12/15.
 */

angular.module('igl')

.controller('IGDocumentListCtrl', function(TableService, $scope, $rootScope, $templateCache, Restangular, $http, $filter, $modal, $cookies, $timeout, userInfoService, ToCSvc, ContextMenuSvc, ProfileAccessSvc, ngTreetableParams, $interval, ViewSettings, StorageService, $q, Notification, DatatypeService, SegmentService, PcLibraryService, IgDocumentService, ElementUtils, AutoSaveService, DatatypeLibrarySvc, SegmentLibrarySvc, TableLibrarySvc, MastermapSvc, MessageService, FilteringSvc, blockUI, PcService, CompositeMessageService, VersionAndUseService) {

    $scope.loading = false;
    $scope.tocView = 'views/toc.html';
    $scope.uiGrid = {};
    $rootScope.igs = [];
    $rootScope.currentData = null;
    $scope.tmpIgs = [].concat($rootScope.igs);
    $scope.error = null;
    $scope.loadingTree = false;
    $scope.filtering = false;
    $scope.tocView = 'views/toc.html';
    $scope.print = function(param) {
        //console.log(param);
    }
    $rootScope.versionAndUseMap = {};

    $scope.loading = true;
    $scope.viewSettings = ViewSettings;
    $scope.igDocumentMsg = {};
    $scope.igDocumentConfig = {
        selectedType: null
    };
    $rootScope.usageF = false;
    $scope.nodeReady = true;
    $scope.igDocumentTypes = [{
        name: "Browse Existing Preloaded Implementation Guides",
        type: 'PRELOADED'
    }, {
        name: "Access My implementation guides",
        type: 'USER'
    }, {
        name: "Shared Implementation Guides",
        type: 'SHARED'
    }];
    $scope.loadingIGDocument = false;
    $scope.toEditIGDocumentId = null;
    $scope.verificationResult = null;
    $scope.verificationError = null;
    $scope.loadingSelection = false;
    $scope.accordi = { metaData: false, definition: true, igList: true, igDetails: false, active: { list: true, edit: false } };
    $rootScope.autoSaving = false;
    //        AutoSaveService.stop();
    $rootScope.saved = false;

    $scope.usageFilter = function() {
        blockUI.start();
        $rootScope.usageF = true;
        $('#treeTable').treetable('collapseAll');
        blockUI.stop();
        return false;

    };

    $scope.selectIgTab = function(value) {
        if (value === 1) {
            $scope.accordi.igList = false;
            $scope.accordi.igDetails = true;
        } else {
            $scope.selectIGDocumentType('USER');
            $scope.accordi.igList = true;
            $scope.accordi.igDetails = false;
        }
    };

    $scope.segmentsParams = new ngTreetableParams({
        getNodes: function(parent) {
            return SegmentService.getNodes(parent, $rootScope.segment);
        },
        getTemplate: function(node) {
            return SegmentService.getTemplate(node, $rootScope.segment);
        }
    });

    $scope.datatypesParams = new ngTreetableParams({
        getNodes: function(parent) {
            return DatatypeService.getNodes(parent, $rootScope.datatype);
        },
        getTemplate: function(node) {
            return DatatypeService.getTemplate(node, $rootScope.datatype);
        }
    });

    $rootScope.closeIGDocument = function() {
        $rootScope.clearChanges();
        $rootScope.igdocument = null;
        $rootScope.tocView = null;
        $rootScope.subview = null;

        $rootScope.isEditing = false;
        $scope.selectIgTab(0);
        $rootScope.initMaps();
        StorageService.setIgDocument(null);
    };

    $scope.getMessageParams = function() {
        return new ngTreetableParams({
            getNodes: function(parent) {
                return MessageService.getNodes(parent, $rootScope.messageTree);
            },
            getTemplate: function(node) {
                return MessageService.getTemplate(node, $rootScope.messageTree);
            }
        });
    };

    /**
     * init the controller
     */
    $scope.initIGDocuments = function() {
        $scope.loadIGDocuments();
        $scope.getScrollbarWidth();
        /**
         * On 'event:loginConfirmed', resend all the 401 requests.
         */
        $scope.$on('event:loginConfirmed', function(event) {
            $scope.loadIGDocuments();
        });

        $rootScope.$on('event:openIGDocumentRequest', function(event, igdocument) {
            $scope.selectIGDocument(igdocument);
        });

        $scope.$on('event:openDatatype', function(event, datatype) {

            $scope.selectDatatype(datatype); // Should we open in a dialog ??
        });

        $scope.$on('event:openSegment', function(event, segment) {

            $scope.selectSegment(segment); // Should we open in a dialog ??
        });

        $scope.$on('event:openMessage', function(event, message) {
            $rootScope.messageTree = null;
            $scope.selectMessage(message); // Should we open in a dialog ??
        });
        $scope.$on('event:openPc', function(event) {
            $rootScope.pcTree = null;
            $scope.selectPc(); // Should we open in a dialog ??
        });
        $scope.$on('event:openCm', function(event) {
            $rootScope.cmTree = null;
            $scope.selectCm(); // Should we open in a dialog ??
        });

        $scope.$on('event:openTable', function(event, table) {
            $scope.selectTable(table); // Should we open in a dialog ??
        });

        $scope.$on('event:openSection', function(event, section, referencer) {
            $scope.selectSection(section, referencer); // Should we open in a dialog ??
        });

        $scope.$on('event:openDocumentMetadata', function(event, metaData) {
            $scope.selectDocumentMetaData(metaData); // Should we open in a dialog ??
        });

        $scope.$on('event:openProfileMetadata', function(event, metaData) {
            $scope.selectProfileMetaData(metaData); // Should we open in a dialog ??
        });

        $rootScope.$on('event:updateIgDate', function(event, dateUpdated) {
            if (!dateUpdated || dateUpdated === null) {
                IgDocumentService.updateDate($rootScope.igdocument);
            } else {
                $rootScope.igdocument.dateUpdated = dateUpdated;
            }
        });


        $rootScope.$on('event:IgsPushed', function(event, igdocument) {

            //                console.log("event:IgsPushed=" + igdocument)
            if ($scope.igDocumentConfig.selectedType === 'USER') {
                var idx = $rootScope.igs.findIndex(function(igd) {
                    return igd.id === igdocument.id;
                });
                if (idx > -1) {
                    $timeout(function() {
                        //                            _.each($rootScope.igs, function (igd) {
                        //                                console.log("b msgs=" + igd.metaData.title + " eq=" + (igd === igdocument));
                        //                            });
                        $rootScope.igs.splice(idx, 1);
                        $scope.tmpIgs = [].concat($rootScope.igs);
                        //                            _.each($scope.tmpIgs, function (igd) {
                        //                                console.log("a msgs=" + igd.metaData.title + " eq=" + (igd === igdocument));
                        //                                console.log("msgs=" + igd.metaData.title + " len=" + igd.profile.messages.children.length);
                        //                            });
                    }, 100);
                    $rootScope.igs.push(igdocument);
                } else {
                    //                        console.log("pushed=>");
                    $rootScope.igs.push(igdocument);
                }
            } else {
                $scope.igDocumentConfig.selectedType = 'USER';
                $scope.loadIGDocuments();
            }
        });

        $rootScope.$on('event:saveAndExecLogout', function(event) {
            if ($rootScope.igdocument != null) {
                if ($rootScope.hasChanges()) {
                    $rootScope.openConfirmLeaveDlg().result.then(function() {
                        $rootScope.$emit('event:execLogout');
                    });
                } else {
                    $rootScope.$emit('event:execLogout');
                }
            } else {
                $rootScope.$emit('event:execLogout');
            }
        });
    };
    $scope.getTemplateRow = function(row) {
        $rootScope.row = row;
        return 'templateRow.html';

    }
    $scope.selectIGDocumentType = function(selectedType) {
        //console.log("selectIGDocumentType msgs=" + selectedType.metaData.title + " len=" + selectedType.profile.messages.children.length);
        $scope.igDocumentConfig.selectedType = selectedType;
        StorageService.setSelectedIgDocumentType(selectedType);
        $scope.loadIGDocuments();
    };


    $scope.selectIGDocument = function(igdocument) {
        $rootScope.igdocument = igdocument;
        $rootScope.accountId = igdocument.accountId;
        $scope.openIGDocument(igdocument);
    };

    $scope.loadIGDocuments = function() {
        var delay = $q.defer();
        $scope.igDocumentConfig.selectedType = StorageService.getSelectedIgDocumentType() != null ? StorageService.getSelectedIgDocumentType() : 'USER';
        $scope.error = null;
        $rootScope.igs = [];
        $scope.tmpIgs = [].concat($rootScope.igs);
        if (userInfoService.isAuthenticated() && !userInfoService.isPending()) {
            $scope.loading = true;
            StorageService.setSelectedIgDocumentType($scope.igDocumentConfig.selectedType);

            $http.get('api/igdocuments', { params: { "type": $scope.igDocumentConfig.selectedType } }).then(function(response) {
                console.log(response);
                $rootScope.igs = angular.fromJson(response.data);
                $scope.tmpIgs = [].concat($rootScope.igs);
                $scope.loading = false;
                delay.resolve(true);
            }, function(error) {
                $scope.loading = false;
                $scope.error = error.data;
                delay.reject(false);
            });
        } else {
            delay.reject(false);
        }
        return delay.promise;
    };

    $scope.clone = function(igdocument) {
        console.log(igdocument);
        $scope.toEditIGDocumentId = igdocument.id;
        $http.post('api/igdocuments/' + igdocument.id + '/clone').then(function(response) {
            $scope.toEditIGDocumentId = null;
            if ($scope.igDocumentConfig.selectedType === 'USER') {
                $rootScope.igs.push(angular.fromJson(response.data));
            } else {
                $scope.igDocumentConfig.selectedType = 'USER';
                $scope.loadIGDocuments();
            }
            $scope.selectIgTab(0);
            $rootScope.msg().text = "igClonedSuccess";
            $rootScope.msg().type = "success";
            $rootScope.msg().show = true;
        }, function(error) {
            $scope.toEditIGDocumentId = null;
            $rootScope.msg().text = "igClonedFailed";
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;
        });
    };

    $scope.findOne = function(id) {
        for (var i = 0; i < $rootScope.igs.length; i++) {
            if ($rootScope.igs[i].id === id) {
                return $rootScope.igs[i];
            }
        }
        return null;
    };

    var preventChangesLost = function() {
        //            if ($rootScope.hasChanges()) {
        //                if(!confirm("You have unsaved changes, Do you want to stay on the page?")) {
        //                    event.preventDefault();
        //                }
        //            }
    }

    $scope.show = function(igdocument) {
        var process = function() {
            $scope.toEditIGDocumentId = igdocument.id;
            try {
                $scope.openIGDocument(igdocument);
            } catch (e) {
                $rootScope.msg().text = "igInitFailed";
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
                $scope.loadingIGDocument = false;
                $scope.toEditIGDocumentId = null;
            }
        };

        if ($rootScope.hasChanges()) {
            $rootScope.openConfirmLeaveDlg().result.then(function() {
                process();
            });
        } else {
            process();
        }
    };
    $scope.displayFilteredTree = function() {
        console.log("IN Filterd");
        //$rootScope.loadingTree =! $rootScope.loadingTree;
        $scope.ready = false;
        $scope.tocView = 'views/tocFilterMd.html';
    }

    $scope.ready = false;

    $scope.ready = function() {
        return $scope.ready;
    }

    $scope.finishLoading = function() {

        $scope.loadingTree = false;

        $scope.setReady(true);
    }

    $scope.setReady = function(b) {

        $scope.ready = b;
    }

    $scope.setFilter = function(b) {

        $scope.filtering = b;
    }
    $scope.getFilter = function() {

        return $scope.filtering;
    }


    $scope.toggleLoading = function() {
        $scope.loadingTree = true;
    }

    $scope.showLoading = function() {
        return $scope.loadingTree;
    }

    $scope.displayRegularTree = function() {
        blockUI.start();
        console.log("IN REGULAR")
            //$rootScope.loadingTree =! $rootScope.loadingTree;
        $scope.ready = false;
        $scope.tocView = 'views/toc.html';
        blockUI.stop();

    }

    $scope.edit = function(igdocument) {
        console.log("edit msgs=" + igdocument.metaData.title + " len=" + igdocument.profile.messages.children.length);
        $scope.viewSettings.setTableReadonly(false);
        $scope.tocView = 'views/toc.html';
        $scope.show(igdocument);
    };

    $scope.view = function(igdocument) {
        $scope.viewSettings.setTableReadonly(true);
        $scope.tocView = 'views/tocReadOnly.html';
        $scope.show(igdocument);
    };


    // switcher
    $scope.enabled = true;
    $scope.onOff = true;
    $scope.yesNo = true;
    $scope.disabled = true;

    $scope.changeCallback = function() {
        console.log('This is the state of my model ' + $scope.enabled);
    };


    $scope.orderSectionsByPosition = function(sections) {
        sections = $filter('orderBy')(sections, 'sectionPosition');
        angular.forEach(sections, function(section) {
            if (section.childSections && section.childSections != null && section.childSections.length > 0) {
                section.childSections = $scope.orderSectionsByPosition(section.childSections);
            }
        });
        return sections;
    };

    $scope.orderMesagesByPositon = function(messages) {
        return $filter('orderBy')(messages, 'position');
    };

    $scope.openIGDocument = function(igdocument) {
        if (igdocument != null) {
            // Set rootscope accountId for sharing
            $rootScope.accountId = igdocument.accountId;
            $timeout(function() {
                $scope.selectIgTab(1);
                $rootScope.TreeIgs = [];
                $rootScope.TreeIgs.push(igdocument);
                $rootScope.selectedMessagesIDS = [];
                igdocument.childSections = $scope.orderSectionsByPosition(igdocument.childSections);
                igdocument.profile.messages.children = $scope.orderMesagesByPositon(igdocument.profile.messages.children);
                $rootScope.datatypeLibrary = igdocument.profile.datatypeLibrary;
                $rootScope.tableLibrary = igdocument.profile.tableLibrary;
                $rootScope.ext = igdocument.metaData.ext;
                $rootScope.selectedMessages = angular.copy(igdocument.profile.messages.children);
                $scope.loadingIGDocument = true;
                $rootScope.isEditing = true;
                $rootScope.igdocument = igdocument;
                $scope.loadCm();
                if (igdocument.profile.metaData.hl7Version != undefined || igdocument.profile.metaData.hl7Version != null) {
                    $rootScope.hl7Version = igdocument.profile.metaData.hl7Version;
                }
                $rootScope.initMaps();
                $scope.loadSegments().then(function() {
                    $rootScope.filteredSegmentsList = angular.copy($rootScope.segments);
                    //$rootScope.filteredSegmentsList=[];
                    $scope.loadDatatypes().then(function() {
                        $scope.loadVersionAndUseInfo().then(function() {
                            $rootScope.filteredDatatypesList = angular.copy($rootScope.datatypes);
                            $scope.loadTables().then(function() {
                                $scope.collectMessages();

                                $scope.messagesParams = $scope.getMessageParams();
                                $scope.loadIgDocumentMetaData();

                                $rootScope.filteredTablesList = angular.copy($rootScope.tables);
                                // Find share participants
                                if ($rootScope.igdocument.shareParticipantIds && $rootScope.igdocument.shareParticipantIds.length > 0) {
                                    $rootScope.igdocument.shareParticipants = [];
                                    $rootScope.igdocument.shareParticipantIds.forEach(function(participant) {
                                        $http.get('api/shareparticipant', { params: { id: participant.accountId } })
                                            .then(
                                                function(response) {
                                                    response.data.pendingApproval = participant.pendingApproval;
                                                    response.data.permission = participant.permission;
                                                    $rootScope.igdocument.shareParticipants.push(response.data);
                                                },
                                                function(error) {
                                                    console.log(error);
                                                }
                                            );
                                    });
                                }
                                $scope.loadPc().then(function() {}, function() {});
                            }, function() {});
                        }, function() {});
                    }, function() {});
                }, function() {});
            }, function() {});
        }

    };


    $rootScope.getMessagesFromIDS = function(selectedMessagesIDS, ig) {
        $rootScope.selectedMessages = []

    }

    $scope.loadIgDocumentMetaData = function() {
        if (!$rootScope.config || $rootScope.config === null) {
            $http.get('api/igdocuments/config').then(function(response) {
                $rootScope.config = angular.fromJson(response.data);
                $scope.loadingIGDocument = false;
                $scope.toEditIGDocumentId = null;
                $scope.selectDocumentMetaData();
            }, function(error) {
                $scope.loadingIGDocument = false;
                $scope.toEditIGDocumentId = null;
            });
        } else {
            $scope.loadingIGDocument = false;
            $scope.toEditIGDocumentId = null;
            $scope.selectDocumentMetaData();
        }
    };

    $scope.loadDatatypes = function() {
        var delay = $q.defer();
        $rootScope.igdocument.profile.datatypeLibrary.type = "datatypes";
        DatatypeLibrarySvc.getDatatypesByLibrary($rootScope.igdocument.profile.datatypeLibrary.id).then(function(children) {
            $rootScope.datatypes = children;
            $rootScope.datatypesMap = {};
            angular.forEach(children, function(child) {
                this[child.id] = child;
            }, $rootScope.datatypesMap);
            delay.resolve(true);
        }, function(error) {
            $rootScope.msg().text = "DatatypesLoadFailed";
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;
            delay.reject(false);

        });
        return delay.promise;
    };

    $scope.loadVersionAndUseInfo = function() {
        var delay = $q.defer();
        var dtIds = [];
        for (var i = 0; i < $rootScope.datatypeLibrary.children.length; i++) {
            dtIds.push($rootScope.datatypeLibrary.children[i].id);
            //console.log(0)
        }
        VersionAndUseService.findAll().then(function(result) {
            console.log("==========Adding Datatypes from their IDS============");
            //$rootScope.datatypes = result;
            console.log(result);
            angular.forEach(result, function(info) {
                $rootScope.versionAndUseMap[info.id] = info;
            });
            delay.resolve(true);

        }, function(error) {
            $rootScope.msg().text = "DatatypesLoadFailed";
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;
            delay.reject(false);

        });
        return delay.promise;
    };

    $scope.loadSegments = function() {
        var delay = $q.defer();
        $rootScope.igdocument.profile.segmentLibrary.type = "segments";
        SegmentLibrarySvc.getSegmentsByLibrary($rootScope.igdocument.profile.segmentLibrary.id).then(function(children) {
            $rootScope.segments = children;
            $rootScope.segmentsMap = {};
            angular.forEach(children, function(child) {
                this[child.id] = child;
            }, $rootScope.segmentsMap);
            delay.resolve(true);
        }, function(error) {
            $rootScope.msg().text = "SegmentsLoadFailed";
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;
            delay.reject(false);
        });
        return delay.promise;
    };


    $scope.loadPc = function() {
        var delay = $q.defer();
        if ($rootScope.igdocument.profile.profileComponentLibrary) {
            PcLibraryService.getProfileComponentLibrary($rootScope.igdocument.profile.profileComponentLibrary.id).then(function(lib) {
                PcLibraryService.getProfileComponentsByLibrary($rootScope.igdocument.profile.profileComponentLibrary.id).then(function(pcs) {
                    console.log("++++++++++++++++++++++++++++++++++");
                    console.log(pcs);
                    $rootScope.profileComponentLib = lib
                    $rootScope.profileComponents = pcs;
                    $rootScope.profileComponentsMap = {};
                    angular.forEach(lib.children, function(child) {
                        this[child.id] = child;
                    }, $rootScope.profileComponentsMap);
                    delay.resolve(true);
                }, function(error) {
                    $rootScope.msg().text = "ProfileComplonentLoadFail";
                    $rootScope.msg().type = "danger";
                    $rootScope.msg().show = true;
                    delay.reject(false);
                });
            });
        }
        return delay.promise;
    };
    $scope.loadCm = function() {

        if ($rootScope.igdocument.profile.compositeMessages) {
            $rootScope.compositeMessages = $rootScope.igdocument.profile.compositeMessages.children;
        }


    };
    $scope.loadTables = function() {
        var delay = $q.defer();
        $rootScope.igdocument.profile.tableLibrary.type = "tables";




        TableLibrarySvc.getTablesByLibrary($rootScope.igdocument.profile.tableLibrary.id).then(function(children) {
            $rootScope.tables = children;
            $rootScope.tablesMap = {};
            angular.forEach(children, function(child) {
                this[child.id] = child;
            }, $rootScope.tablesMap);
            delay.resolve(true);
        }, function(error) {
            $rootScope.msg().text = "TablesLoadFailed";
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;
            delay.reject(false);
        });
        return delay.promise;

    };


    $scope.loadFilter = function() {
        $rootScope.$emit('event:loadFilter', $rootScope.igdocument);
    };

    $scope.loadMastermap = function() {
        //            $rootScope.$emit('event:loadMastermap', $rootScope.igdocument);
        //            MastermapSvc.parseIg($rootScope.igdocument);
    };


    $scope.collectTables = function() {
        $rootScope.tables = $rootScope.igdocument.profile.tableLibrary.children;
        $rootScope.tablesMap = {};
        angular.forEach($rootScope.igdocument.profile.tableLibrary.children, function(child) {
            this[child.id] = child;
            if (child.displayName) {
                child.label = child.displayName;
            }
            angular.forEach(child.codes, function(code) {
                if (code.displayName) {
                    code.label = code.displayName;
                }
            });
        }, $rootScope.tablesMap);
    };

    $scope.collectMessages = function() {
        $rootScope.messagesMap = {};
        $rootScope.messages = $rootScope.igdocument.profile.messages;
        angular.forEach($rootScope.igdocument.profile.messages.children, function(child) {
            if (child != null) {
                this[child.id] = child;
                var cnt = 0;
                angular.forEach(child.children, function(segmentRefOrGroup) {
                    $rootScope.processElement(segmentRefOrGroup);
                });
            }
        }, $rootScope.messagesMap);
    };

    $scope.collectData = function(node, segRefOrGroups, segments, datatypes) {
        if (node) {
            if (node.type === 'message') {
                angular.forEach(node.children, function(segmentRefOrGroup) {
                    $scope.collectData(segmentRefOrGroup, segRefOrGroups, segments, datatypes);
                });
            } else if (node.type === 'group') {
                segRefOrGroups.push(node);
                if (node.children) {
                    angular.forEach(node.children, function(segmentRefOrGroup) {
                        $scope.collectData(segmentRefOrGroup, segRefOrGroups, segments, datatypes);
                    });
                }
                segRefOrGroups.push({ name: node.name, "type": "end-group" });
            } else if (node.type === 'segment') {
                if (segments.indexOf(node) === -1) {
                    segments.push(node);
                }
                angular.forEach(node.fields, function(field) {
                    $scope.collectData(field, segRefOrGroups, segments, datatypes);
                });
            } else if (node.type === 'segmentRef') {
                segRefOrGroups.push(node);
                $scope.collectData($rootScope.segmentsMap[node.ref.id], segRefOrGroups, segments, datatypes);
            } else if (node.type === 'component' || node.type === 'subcomponent' || node.type === 'field') {
                $scope.collectData($rootScope.datatypesMap[node.datatype.id], segRefOrGroups, segments, datatypes);
            } else if (node.type === 'datatype') {
                if (datatypes.indexOf(node) === -1) {
                    datatypes.push(node);
                }
                if (node.components) {
                    angular.forEach(node.children, function(component) {
                        $scope.collectData(component, segRefOrGroups, segments, datatypes);
                    });
                }
            }
        }
    };

    $scope.confirmDelete = function(igdocument) {
        var modalInstance = $modal.open({
            templateUrl: 'ConfirmIGDocumentDeleteCtrl.html',
            controller: 'ConfirmIGDocumentDeleteCtrl',
            resolve: {
                igdocumentToDelete: function() {
                    return igdocument;
                }
            }
        });
        modalInstance.result.then(function(igdocument) {
            $scope.igdocumentToDelete = igdocument;
            var idxP = _.findIndex($rootScope.igs, function(child) {
                return child.id === igdocument.id;
            });
            $rootScope.igs.splice(idxP, 1);
            $scope.tmpIgs = [].concat($rootScope.igs);
        });
    };

    $scope.confirmClose = function() {
        var modalInstance = $modal.open({
            templateUrl: 'ConfirmIGDocumentCloseCtrl.html',
            controller: 'ConfirmIGDocumentCloseCtrl'
        });
        modalInstance.result.then(function() {
            $rootScope.clearChanges();
        }, function() {});
    };
    $rootScope.deleteProfileComponent = function(pcLibId, profileComponent) {
        var modalInstance = $modal.open({
            templateUrl: 'DeleteProfileComponentCtrl.html',
            controller: 'DeleteProfileComponentCtrl',
            resolve: {
                profileComponentToDelete: function() {
                    return profileComponent;
                },
                pcLibId: function() {
                    return pcLibId;
                }
            }
        });
        modalInstance.result.then(function(profileComponent) {

        }, function() {});
    };

    $rootScope.cantDeletePc = function(profileComponent) {
        var modalInstance = $modal.open({
            templateUrl: 'CantDeletePcCtrl.html',
            controller: 'CantDeletePcCtrl',
            resolve: {
                profileComponent: function() {
                    return profileComponent;
                },

            }
        });
        modalInstance.result.then(function(profileComponent) {

        }, function() {});
    };

    $scope.confirmOpen = function(igdocument) {
        var modalInstance = $modal.open({
            templateUrl: 'ConfirmIGDocumentOpenCtrl.html',
            controller: 'ConfirmIGDocumentOpenCtrl',
            resolve: {
                igdocumentToOpen: function() {
                    return igdocument;
                }
            }
        });
        modalInstance.result.then(function(igdocument) {
            $rootScope.clearChanges();
            $scope.openIGDocument(igdocument);
        }, function() {});
    };


    $scope.selectMessagesForExport = function(igdocument) {
        var modalInstance = $modal.open({
            templateUrl: 'SelectMessagesForExportCtrl.html',
            controller: 'SelectMessagesForExportCtrl',
            windowClass: 'conformance-profiles-modal',
            resolve: {
                igdocumentToSelect: function() {
                    return igdocument;
                }
            }
        });
        modalInstance.result.then(function() {}, function() {});
    };

    $scope.addSegments = function(hl7Version) {

        var addSegmentInstance = $modal.open({
            templateUrl: 'AddSegmentDlg.html',
            controller: 'AddSegmentDlgCtl',
            windowClass: 'conformance-profiles-modal',
            resolve: {
                hl7Version: function() {
                    return $scope.hl7Version;
                }

            }
        }).result.then(function(results) {
            var ids = [];
            angular.forEach(results, function(result) {
                ids.push(result.id);
            });

        });

    };



    $rootScope.addHL7Table = function(selectedTableLibary, hl7Version) {
        var modalInstance = $modal.open({
            templateUrl: 'AddHL7TableOpenCtrl.html',
            controller: 'AddHL7TableOpenCtrl',
            windowClass: 'conformance-profiles-modal',
            resolve: {
                selectedTableLibary: function() {
                    return selectedTableLibary;
                },
                hl7Version: function() {
                    return hl7Version;
                }
            }
        });
        modalInstance.result.then(function() {}, function() {});
    };

    $scope.addDatatypes = function(hl7Version) {
        var scopes = ['HL7STANDARD'];

        DatatypeService.getDataTypesByScopesAndVersion(scopes, $scope.hl7Version).then(function(datatypes) {
            DatatypeLibrarySvc.getDataTypeLibraryByScope('MASTER').then(function(masterLib) {
                DatatypeLibrarySvc.getDataTypeLibraryByScope('USER').then(function(userDtLib) {


                    console.log("userDtLib");
                    console.log(userDtLib);

                    console.log("addDatatype scopes=" + scopes.length);
                    var addDatatypeInstance = $modal.open({
                        templateUrl: 'AddHL7Datatype.html',
                        controller: 'AddDatatypeDlgCtl',
                        size: 'lg',
                        windowClass: 'addDatatype',
                        resolve: {
                            hl7Version: function() {
                                return $scope.hl7Version;
                            },
                            datatypes: function() {

                                return datatypes;
                            },
                            masterLib: function() {

                                return masterLib;
                            },
                            userDtLib: function() {
                                return userDtLib;
                            }

                        }
                    }).result.then(function(results) {
                        var ids = [];
                        angular.forEach(results, function(result) {
                            ids.push(result.id);
                        });
                    });
                });
            });
        });
    };

    $scope.addMasterDatatype = function() {
        console.log("=========versionwwww=======");
        var scopes = ['MASTER'];

        DatatypeService.getPublishedMaster($rootScope.igdocument.profile.metaData.hl7Version).then(function(result) {
            var addDatatypeInstance = $modal.open({
                templateUrl: 'AddDatatypeDlg.html',
                controller: 'AddDatatypeDlgCtl',
                size: 'lg',
                windowClass: 'flavor-modal-window',
                resolve: {
                    hl7Version: function() {
                        return $rootScope.igdocument.profile.metaData.hl7Version;
                    },
                    datatypes: function() {
                        console.log("datatypes");
                        console.log(result);

                        return result;
                    }
                }
            }).result.then(function(results) {
                var ids = [];
                angular.forEach(results, function(result) {
                    ids.push(result.id);
                });
            });
        });
    };
    $scope.createProfileComponent = function() {

        var createPCInstance = $modal.open({
            templateUrl: 'createProfileComponent.html',
            controller: 'createProfileComponentCtrl',

            resolve: {
                // PcLibrary: function() {
                //     return $rootScope.igdocument.profile.profileComponentLibrary;
                // }

            }
        }).result.then(function(results) {
            console.log("results");
            console.log(results);
            $rootScope.editPC(results)
            if ($scope.profileComponentParams)
                $scope.profileComponentParams.refresh();
            if ($scope.applyPcToParams)
                $scope.applyPcToParams.refresh();
        });

    };
    $scope.createCompositeMessage = function() {
        var createCMInstance = $modal.open({
            templateUrl: 'createCompositeMessage.html',
            controller: 'createCompositeMessageCtrl',
            size: 'lg',
            windowClass: 'conformance-profiles-modal',
            resolve: {
                // PcLibrary: function() {
                //     return $rootScope.igdocument.profile.profileComponentLibrary;
                // }

            }
        }).result.then(function(results) {
            console.log("results");
            console.log(results);
            $rootScope.editCM(results)
                // if ($scope.profileComponentParams)
                //     $scope.profileComponentParams.refresh();
                // if ($scope.applyPcToParams)
                //     $scope.applyPcToParams.refresh();
        });

    };

    $scope.exportAsMessages = function(id, mids) {
        blockUI.start();
        var form = document.createElement("form");
        form.action = $rootScope.api('api/igdocuments/' + id + '/export/pdf/' + mids);
        form.method = "POST";
        form.target = "_target";
        var csrfInput = document.createElement("input");
        csrfInput.name = "X-XSRF-TOKEN";
        csrfInput.value = $cookies['XSRF-TOKEN'];
        form.appendChild(csrfInput);
        form.style.display = 'none';
        document.body.appendChild(form);
        form.submit();
        blockUI.stop();
    };

    $scope.exportAs = function(format) {
        if ($rootScope.igdocument != null) {
            IgDocumentService.exportAs($rootScope.igdocument, format);
        }
    };

    $scope.exportAsWithLayout = function(format, layout) {
        if ($rootScope.igdocument != null) {
            IgDocumentService.exportAsWithLayout($rootScope.igdocument, format, layout);
        }
    };

    $scope.exportDelta = function(id, format) {
        blockUI.start();
        var form = document.createElement("form");
        form.action = $rootScope.api('api/igdocuments/' + id + '/delta/' + format);
        form.method = "POST";
        form.target = "_target";
        var csrfInput = document.createElement("input");
        csrfInput.name = "X-XSRF-TOKEN";
        csrfInput.value = $cookies['XSRF-TOKEN'];
        form.appendChild(csrfInput);
        form.style.display = 'none';
        document.body.appendChild(form);
        form.submit();
        blockUI.stop();
    };

    $scope.close = function() {
        if ($rootScope.hasChanges()) {
            $rootScope.openConfirmLeaveDlg().result.then(function() {
                $rootScope.closeIGDocument();
            });
        } else {
            $rootScope.closeIGDocument();
        }
    };

    $scope.gotoSection = function(obj, type) {
        $rootScope.section['data'] = obj;
        $rootScope.section['type'] = type;
    };

    $scope.exportChanges = function() {
        blockUI.start();
        var form = document.createElement("form");
        form.action = 'api/igdocuments/export/changes';
        form.method = "POST";
        form.target = "_target";
        var input = document.createElement("textarea");
        input.name = "content";
        input.value = angular.fromJson($rootScope.changes);
        form.appendChild(input);
        var csrfInput = document.createElement("input");
        csrfInput.name = "X-XSRF-TOKEN";
        csrfInput.value = $cookies['XSRF-TOKEN'];
        form.appendChild(csrfInput);
        form.style.display = 'none';
        document.body.appendChild(form);
        form.submit();
        blockUI.stop();
    };

    $scope.viewChanges = function(changes) {
        var modalInstance = $modal.open({
            templateUrl: 'ViewIGChangesCtrl.html',
            controller: 'ViewIGChangesCtrl',
            resolve: {
                changes: function() {
                    return changes;
                }
            }
        });
        modalInstance.result.then(function(changes) {
            $scope.changes = changes;
        }, function() {});
    };


    $scope.reset = function() {
        $rootScope.changes = {};
        $rootScope.closeIGDocument();
    };


    $scope.initIGDocument = function() {
        $scope.loading = true;
        if ($rootScope.igdocument != null && $rootScope.igdocument != undefined)
            $scope.gotoSection($rootScope.igdocument.metaData, 'metaData');
        $scope.loading = false;

    };

    $scope.createGuide = function() {
        $scope.isVersionSelect = true;
    };

    $scope.listHL7Versions = function() {
        var hl7Versions = [];
        $http.get('api/igdocuments/hl7/findVersions', {
            timeout: 60000
        }).then(
            function(response) {
                var len = response.data.length;
                for (var i = 0; i < len; i++) {
                    hl7Versions.push(response.data[i]);
                }
            });
        return hl7Versions;
    };

    $scope.showSelected = function(node) {
        $scope.selectedNode = node;
    };

    $scope.selectSegment = function(segment) {
        $rootScope.Activate(segment.id);
        $rootScope.subview = "EditSegments.html";
        if (segment && segment != null) {
            $scope.loadingSelection = true;
            blockUI.start();
            $timeout(
                function() {
                    try {
                        SegmentService.get(segment.id).then(function(result) {
                            $rootScope.segment = angular.copy(segment);
                            $rootScope.$emit("event:initSegment");

                            $rootScope.currentData = $rootScope.segment;
                            $rootScope.segment.ext = $rootScope.getSegmentExtension($rootScope.segment);
                            $rootScope.segment["type"] = "segment";
                            $rootScope.tableWidth = null;
                            $rootScope.scrollbarWidth = $rootScope.getScrollbarWidth();
                            $rootScope.csWidth = $rootScope.getDynamicWidth(1, 3, 990);
                            $rootScope.predWidth = $rootScope.getDynamicWidth(1, 3, 990);
                            $rootScope.commentWidth = $rootScope.getDynamicWidth(1, 3, 990);
                            $scope.loadingSelection = false;
                            try {
                                if ($scope.segmentsParams)
                                    $scope.segmentsParams.refresh();
                            } catch (e) {

                            }

                            $rootScope.references = [];
                            angular.forEach($rootScope.igdocument.profile.messages.children, function(message) {
                                $rootScope.findSegmentRefs($rootScope.segment, message, '', '', message);
                            });
                            $scope.loadingSelection = false;
                            $rootScope.$emit("event:initEditArea");
                            blockUI.stop();
                        }, function(error) {
                            $scope.loadingSelection = false;
                            $rootScope.msg().text = error.data.text;
                            $rootScope.msg().type = error.data.type;
                            $rootScope.msg().show = true;
                            blockUI.stop();
                        });
                    } catch (e) {
                        $scope.loadingSelection = false;
                        $rootScope.msg().text = "An error occured. DEBUG: \n" + e;
                        $rootScope.msg().type = "danger";
                        $rootScope.msg().show = true;
                        blockUI.stop();
                    }
                }, 100);
        }
    };

    $scope.selectDocumentMetaData = function() {
        $rootScope.subview = "EditDocumentMetadata.html";
        $scope.loadingSelection = true;
        blockUI.start();
        $rootScope.metaData = angular.copy($rootScope.igdocument.metaData);
        $rootScope.currentData = $rootScope.igdocument;
        $timeout(
            function() {
                $scope.loadingSelection = false;
                $rootScope.$emit("event:initEditArea");
                blockUI.stop();
            }, 100);
    };

    $scope.selectProfileMetaData = function() {
        $rootScope.subview = "EditProfileMetadata.html";
        $rootScope.metaData = angular.copy($rootScope.igdocument.profile.metaData);
        console.log(metaData);
        $rootScope.currentData = $rootScope.igdocument.profile;
        $scope.loadingSelection = true;
        blockUI.start();
        $timeout(
            function() {
                $scope.loadingSelection = false;
                $rootScope.$emit("event:initEditArea");
                blockUI.stop();
            }, 100);
    };

    $scope.selectDatatype = function(datatype) {
        console.log(datatype);
        $rootScope.Activate(datatype.id);
        $rootScope.subview = "EditDatatypes.html";
        if (datatype && datatype != null) {
            $scope.loadingSelection = true;
            blockUI.start();
            $timeout(
                function() {
                    try {
                        DatatypeService.getOne(datatype.id).then(function(result) {
                            $rootScope.datatype = angular.copy(result);
                            $rootScope.$emit("event:initDatatype");

                            $rootScope.currentData = datatype;

                            $rootScope.datatype.ext = $rootScope.getDatatypeExtension($rootScope.datatype);
                            $scope.loadingSelection = false;
                            $rootScope.datatype["type"] = "datatype";
                            $rootScope.tableWidth = null;
                            $rootScope.scrollbarWidth = $rootScope.getScrollbarWidth();
                            $rootScope.csWidth = $rootScope.getDynamicWidth(1, 3, 890);
                            $rootScope.predWidth = $rootScope.getDynamicWidth(1, 3, 890);
                            $rootScope.commentWidth = $rootScope.getDynamicWidth(1, 3, 890);
                            $scope.loadingSelection = false;
                            try {
                                if ($scope.datatypesParams)
                                    $scope.datatypesParams.refresh();
                            } catch (e) {

                            }
                            $rootScope.references = [];
                            $rootScope.tmpReferences = [].concat($rootScope.references);
                            angular.forEach($rootScope.segments, function(segment) {
                                if (segment && segment != null) {
                                    $rootScope.findDatatypeRefs($rootScope.datatype, segment, $rootScope.getSegmentLabel(segment), segment);
                                }
                            });
                            angular.forEach($rootScope.datatypes, function(dt) {
                                if (dt && dt != null && dt.id !== $rootScope.datatype.id) $rootScope.findDatatypeRefs(datatype, dt, $rootScope.getDatatypeLabel(dt), dt);
                            });

                            $rootScope.tmpReferences = [].concat($rootScope.references);

                            $rootScope.$emit("event:initEditArea");

                            blockUI.stop();
                        }, function(error) {
                            $scope.loadingSelection = false;
                            $rootScope.msg().text = error.data.text;
                            $rootScope.msg().type = error.data.type;
                            $rootScope.msg().show = true;
                            blockUI.stop();
                        });
                    } catch (e) {
                        $scope.loadingSelection = false;
                        $rootScope.msg().text = "An error occured. DEBUG: \n" + e;
                        $rootScope.msg().type = "danger";
                        $rootScope.msg().show = true;
                        blockUI.stop();
                    }
                }, 100);

            setTimeout(function() {
                $scope.$broadcast('reCalcViewDimensions');
                console.log("refreshed Slider!!");
            }, 1000);
        }
    };

    $scope.selectMessage = function(message) {
        $rootScope.Activate(message.id);
        $rootScope.subview = "EditMessages.html";
        $scope.loadingSelection = true;
        blockUI.start();
        $timeout(
            function() {
                try {
                    $rootScope.originalMessage = message;
                    $rootScope.message = angular.copy(message);
                    $rootScope.$emit("event:initMessage");

                    $rootScope.currentData = $rootScope.message;
                    $rootScope.processMessageTree($rootScope.message);
                    $rootScope.tableWidth = null;
                    $rootScope.scrollbarWidth = $rootScope.getScrollbarWidth();
                    $rootScope.csWidth = $rootScope.getDynamicWidth(1, 3, 630);
                    $rootScope.predWidth = $rootScope.getDynamicWidth(1, 3, 630);
                    $rootScope.commentWidth = $rootScope.getDynamicWidth(1, 3, 630);
                    $scope.loadingSelection = false;
                    try {
                        if ($scope.messagesParams)
                            $scope.messagesParams.refresh();
                    } catch (e) {

                    }
                    $rootScope.$emit("event:initEditArea");
                    blockUI.stop();
                } catch (e) {
                    $scope.loadingSelection = false;
                    $rootScope.msg().text = "An error occured. DEBUG: \n" + e;
                    $rootScope.msg().type = "danger";
                    $rootScope.msg().show = true;
                    blockUI.stop();
                }
            }, 100);
    };
    $scope.applyPcToParams = new ngTreetableParams({
        getNodes: function(parent) {
            if ($rootScope.profileComponent.appliedTo && $rootScope.profileComponent.appliedTo.length > 0) {
                console.log("==========");
                console.log($rootScope.profileComponent);
                return $rootScope.profileComponent.appliedTo;


            }
        },
        getTemplate: function(node) {
            return 'applyPcToTable';
        }
    });
    $scope.profileComponentParams = new ngTreetableParams({
        getNodes: function(parent) {
            if ($rootScope.igdocument.profile.profileComponentLibrary !== undefined) {
                console.log("$rootScope.profileComponent");

                console.log($rootScope.profileComponent);
                return $rootScope.profileComponent.children;
                // return $rootScope.profileComponent.children;
                // if (parent) {
                //     if (parent.fields) {
                //         return parent.fields;
                //     } else if (parent.components) {
                //         return parent.components;
                //     } else if (parent.segments) {
                //         return parent.segments;
                //     } else if (parent.codes) {
                //         return parent.codes;
                //     }

                // } else {
                // console.log($rootScope.igdocument.profile.profileComponentLibrary.children);
                // return $rootScope.igdocument.profile.profileComponentLibrary.children;
                // }

            }
        },
        getTemplate: function(node) {
            return 'profileComponentTable';
        }
    });
    $scope.selectPc = function() {
        console.log("=++++++++====");
        console.log($rootScope.profileComponents);
        $rootScope.Activate($rootScope.profileComponent.id);
        $rootScope.subview = "EditProfileComponent.html";
        $scope.loadingSelection = true;
        blockUI.start();
        $timeout(
            function() {
                try {



                    $rootScope.originalPcLib = $rootScope.igdocument.profile.profileComponentLibrary;
                    //$rootScope.profileComponentLib = angular.copy($rootScope.igdocument.profile.profileComponentLibrary);
                    $rootScope.currentData = $rootScope.profileComponentLib;
                    //$rootScope.processMessageTree($rootScope.message);
                    $rootScope.tableWidth = null;
                    $rootScope.scrollbarWidth = $rootScope.getScrollbarWidth();
                    $rootScope.csWidth = $rootScope.getDynamicWidth(1, 3, 630);
                    $rootScope.predWidth = $rootScope.getDynamicWidth(1, 3, 630);
                    $rootScope.commentWidth = $rootScope.getDynamicWidth(1, 3, 630);
                    $scope.loadingSelection = false;
                    try {
                        if ($scope.profileComponentParams)
                            $scope.profileComponentParams.refresh();
                        if ($scope.applyPcToParams)
                            $scope.applyPcToParams.refresh();
                    } catch (e) {

                    }
                    $rootScope.$emit("event:initEditArea");
                    blockUI.stop();
                } catch (e) {
                    $scope.loadingSelection = false;
                    $rootScope.msg().text = "An error occured. DEBUG: \n" + e;
                    $rootScope.msg().type = "danger";
                    $rootScope.msg().show = true;
                    blockUI.stop();
                }
            }, 100);
    };
    $scope.compositeMessageParams = new ngTreetableParams({
        getNodes: function(parent) {
            if ($rootScope.igdocument.profile.compositeMessages !== undefined) {
                console.log("$rootScope.compositeMessages");

                console.log($rootScope.compositeMessage);

                if (parent) {
                    if (parent.ref) {
                        return parent.ref.fields;
                    } else if (parent.datatype) {
                        return parent.datatype.components;
                    } else if (parent.children) {
                        return parent.children
                    }

                } else {
                    return $rootScope.compositeMessage.children;
                }
                // return $rootScope.profileComponent.children;
                // if (parent) {
                //     if (parent.fields) {
                //         return parent.fields;
                //     } else if (parent.components) {
                //         return parent.components;
                //     } else if (parent.segments) {
                //         return parent.segments;
                //     } else if (parent.codes) {
                //         return parent.codes;
                //     }

                // } else {
                // console.log($rootScope.igdocument.profile.profileComponentLibrary.children);
                // return $rootScope.igdocument.profile.profileComponentLibrary.children;
                // }

            }
        },
        getTemplate: function(node) {
            return 'compositeMessageTable';
        }
    });
    $scope.selectCm = function() {
        CompositeMessageService.getSegOrGrp($rootScope.compositeMessage.children).then(function(children) {
            console.log("=++++++++=/////////////////===");
            $rootScope.compositeMessage.children = children;
            console.log($rootScope.compositeMessage);
            $rootScope.Activate($rootScope.compositeMessage.id);
            $rootScope.subview = "EditCompositeMessage.html";
            $scope.loadingSelection = true;
            blockUI.start();
            $timeout(
                function() {
                    try {



                        // $rootScope.originalCmLib = $rootScope.igdocument.profile.profileComponentLibrary;
                        //$rootScope.profileComponentLib = angular.copy($rootScope.igdocument.profile.profileComponentLibrary);
                        // $rootScope.currentData = $rootScope.profileComponentLib;
                        //$rootScope.processMessageTree($rootScope.message);
                        $rootScope.tableWidth = null;
                        $rootScope.scrollbarWidth = $rootScope.getScrollbarWidth();
                        $rootScope.csWidth = $rootScope.getDynamicWidth(1, 3, 630);
                        $rootScope.predWidth = $rootScope.getDynamicWidth(1, 3, 630);
                        $rootScope.commentWidth = $rootScope.getDynamicWidth(1, 3, 630);
                        $scope.loadingSelection = false;
                        try {
                            if ($scope.compositeMessageParams)
                                $scope.compositeMessageParams.refresh();
                            // if ($scope.applyPcToParams)
                            //     $scope.applyPcToParams.refresh();
                        } catch (e) {

                        }
                        $rootScope.$emit("event:initEditArea");
                        blockUI.stop();
                    } catch (e) {
                        $scope.loadingSelection = false;
                        $rootScope.msg().text = "An error occured. DEBUG: \n" + e;
                        $rootScope.msg().type = "danger";
                        $rootScope.msg().show = true;
                        blockUI.stop();
                    }
                }, 100);
        });


    };

    $scope.selectTable = function(t) {
        $rootScope.Activate(t.id);
        var table = angular.copy(t);
        if ($scope.viewSettings.tableReadonly || table.status == 'PUBLISHED') {
            $rootScope.subview = "ReadValueSets.html";
        } else {
            $rootScope.subview = "EditValueSets.html";
        }
        $scope.loadingSelection = true;
        blockUI.start();
        try {
            TableService.getOne(table.id).then(function(tbl) {
                $rootScope.table = tbl;
                $rootScope.$emit("event:initTable");
                $rootScope.currentData = $rootScope.table;
                $rootScope.codeSystems = [];
                for (var i = 0; i < $rootScope.table.codes.length; i++) {
                    if ($rootScope.codeSystems.indexOf($rootScope.table.codes[i].codeSystem) < 0) {
                        if ($rootScope.table.codes[i].codeSystem && $rootScope.table.codes[i].codeSystem !== '') {
                            $rootScope.codeSystems.push($rootScope.table.codes[i].codeSystem);
                        }
                    }
                }
                $rootScope.table.smallCodes = $rootScope.table.codes.slice(0,1000);
                $rootScope.references = [];
                angular.forEach($rootScope.segments, function(segment) {
                    $rootScope.findTableRefs($rootScope.table, segment, $rootScope.getSegmentLabel(segment), segment);
                });
                angular.forEach($rootScope.datatypes, function(dt) {
                    $rootScope.findTableRefs($rootScope.table, dt, $rootScope.getDatatypeLabel(dt), dt);
                });
                $scope.loadingSelection = false;
                $rootScope.$emit("event:initEditArea");
                blockUI.stop();
            }, function(errr) {
                $scope.loadingSelection = false;
                $rootScope.msg().text = errr.data.text;
                $rootScope.msg().type = errr.data.type;
                $rootScope.msg().show = true;
                blockUI.stop();
            });
        } catch (e) {
            $scope.loadingSelection = false;
            $rootScope.msg().text = "An error occured. DEBUG: \n" + e;
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;
            blockUI.stop();
        }

        //            $timeout(
        //                function() {
        //                    $rootScope.table = table;
        //                    $rootScope.$emit("event:initTable");
        //                    $rootScope.currentData = $rootScope.table;
        //                    $rootScope.codeSystems = [];
        //                    for (var i = 0; i < $rootScope.table.codes.length; i++) {
        //                        if ($rootScope.codeSystems.indexOf($rootScope.table.codes[i].codeSystem) < 0) {
        //                            if ($rootScope.table.codes[i].codeSystem && $rootScope.table.codes[i].codeSystem !== '') {
        //                                $rootScope.codeSystems.push($rootScope.table.codes[i].codeSystem);
        //                            }
        //                        }
        //                    }
        //                    $rootScope.references = [];
        //                    angular.forEach($rootScope.segments, function(segment) {
        //                        $rootScope.findTableRefs($rootScope.table, segment, $rootScope.getSegmentLabel(segment));
        //                    });
        //                    angular.forEach($rootScope.datatypes, function(dt) {
        //                        $rootScope.findTableRefs($rootScope.table, dt, $rootScope.getDatatypeLabel(dt));
        //                    });
        //                    $rootScope.tmpReferences = [].concat($rootScope.references);
        //                    $scope.loadingSelection = false;
        //                    $rootScope.$emit("event:initEditArea");
        //                    blockUI.stop();
        //                }, 100);


    };

    $scope.selectSection = function(section) {
        if (section.sectionContents === null || section.sectionContents === undefined) {
            section.sectionContents = "";
            console.log(section);
        }
        $rootScope.subview = "EditSections.html";
        $scope.loadingSelection = true;
        blockUI.start();

        $timeout(
            function() {
                try {
                    $rootScope.section = angular.copy(section);
                    $rootScope.currentData = $rootScope.section;
                    $rootScope.originalSection = section;
                    $scope.loadingSelection = false;
                    $rootScope.$emit("event:initEditArea");
                    blockUI.stop();
                } catch (e) {
                    $scope.loadingSelection = false;
                    $rootScope.msg().text = "An error occured. DEBUG: \n" + e;
                    $rootScope.msg().type = "danger";
                    $rootScope.msg().show = true;
                    blockUI.stop();
                }
            }, 100);
    };

    $scope.getFullName = function() {
        if (userInfoService.isAuthenticated() === true) {
            return userInfoService.getFullName();
        }
        return '';
    };

    $scope.shareModal = function(igdocument) {
        $http.get('api/usernames').then(function(response) {
            var userList = response.data;
            var filteredUserList = userList.filter(function(user) {
                var isPresent = false;
                if (igdocument.shareParticipants) {
                    for (var i = 0; i < igdocument.shareParticipants.length; i++) {
                        if (igdocument.shareParticipants[i].id == user.id) {
                            isPresent = true;
                        }
                    }
                }
                if (!isPresent) return user;
            });
            var modalInstance = $modal.open({
                templateUrl: 'ShareIGDocumentModal.html',
                controller: 'ShareIGDocumentCtrl',
                size: 'lg',
                resolve: {
                    igdocumentSelected: function() {
                        return igdocument;
                    },
                    userList: function() {
                        return _.filter(filteredUserList, function(user) {

                            return user.id != igdocument.accountId && igdocument.shareParticipantIds && igdocument.shareParticipantIds != null && igdocument.shareParticipantIds.indexOf(user.id) == -1;
                        });

                    }
                }
            });
        }, function(error) {

            console.log(error);
        });
    };


    $scope.unshareModal = function(igdocument, shareParticipant) {
        var modalInstance = $modal.open({
            templateUrl: 'ConfirmIGDocumentUnshareCtrl.html',
            controller: 'UnShareIGDocumentCtrl',
            resolve: {
                igdocumentSelected: function() {
                    return igdocument;
                },
                shareParticipant: function() {

                    return shareParticipant;
                }
            }
        });
    };

    $scope.confirmShareDocument = function(igdocument) {
        $http.get('api/shareconfimation/' + igdocument.id).then(function(response) {
            $rootScope.msg().text = "igSharedConfirmationSuccessful";
            $rootScope.msg().type = "success";
            $rootScope.msg().show = true;
            $scope.loadIGDocuments();
        }, function(error) {
            $rootScope.msg().text = "igSharedConfirmationFailed";
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;
            console.log(error);
        });
    };

    $scope.rejectShareDocument = function(igdocument) {
        $http.get('api/sharereject/' + igdocument.id).then(function(response) {
            $rootScope.msg().text = "igSharedRejectedSuccessfully";
            $rootScope.msg().type = "success";
            $rootScope.msg().show = true;
            $scope.loadIGDocuments();
        }, function(error) {
            $rootScope.msg().text = "igSharedRejectFailed";
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;
            console.log(error);
        });
    };

    $scope.customExportModal = function() {
        var modalInstance = $modal.open({
            templateUrl: 'CustomExportModal.html',
            controller: 'CustomExportCtrl',
            resolve: {}
        });
    };

});


angular.module('igl').controller('ViewIGChangesCtrl', function($scope, $modalInstance, changes, $rootScope, $http) {
    $scope.changes = changes;
    $scope.loading = false;
    $scope.exportChanges = function() {
        $scope.loading = true;
        var form = document.createElement("form");
        form.action = 'api/igdocuments/export/changes';
        form.method = "POST";
        form.target = "_target";
        form.style.display = 'none';
        form.params = document.body.appendChild(form);
        form.submit();
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});

angular.module('igl').controller('DeleteProfileComponentCtrl', function($scope, $modalInstance, pcLibId, profileComponentToDelete, $rootScope, $http, PcService) {
    $scope.profileComponentToDelete = profileComponentToDelete;
    $scope.loading = false;
    $scope.delete = function() {
        $scope.loading = true;
        PcService.delete(pcLibId, $scope.profileComponentToDelete).then(function(profileComponentLib) {
            console.log(profileComponentLib);
            $rootScope.igdocument.profile.profileComponentLibrary = profileComponentLib;
            if ($rootScope.profileComponent && $rootScope.profileComponent.id === $scope.profileComponentToDelete.id) {
                $rootScope.profileComponent = null;
                $rootScope.subview = null;
            }
            $modalInstance.close();

        });

    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});


angular.module('igl').controller('CantDeletePcCtrl', function($scope, $modalInstance, profileComponent, $rootScope, $http, PcService) {
    $scope.profileComponent = profileComponent;
    $scope.loading = false;
    // $scope.delete = function() {
    //     $scope.loading = true;
    //     PcService.delete(pcLibId, $scope.profileComponentToDelete).then(function(profileComponentLib) {
    //         console.log(profileComponentLib);
    //         $rootScope.igdocument.profile.profileComponentLibrary = profileComponentLib;
    //         if ($rootScope.profileComponent && $rootScope.profileComponent.id === $scope.profileComponentToDelete.id) {
    //             $rootScope.profileComponent = null;
    //             $rootScope.subview = null;
    //         }
    //         $modalInstance.close();

    //     });

    // };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});







angular.module('igl').controller('ConfirmIGDocumentDeleteCtrl', function($scope, $modalInstance, igdocumentToDelete, $rootScope, $http) {
    $scope.igdocumentToDelete = igdocumentToDelete;
    $scope.loading = false;
    $scope.delete = function() {
        $scope.loading = true;
        $http.post($rootScope.api('api/igdocuments/' + $scope.igdocumentToDelete.id + '/delete')).then(function(response) {
            var index = $rootScope.igs.indexOf($scope.igdocumentToDelete);
            if (index > -1) $rootScope.igs.splice(index, 1);
            $rootScope.backUp = null;
            if ($scope.igdocumentToDelete === $rootScope.igdocument) {
                $rootScope.closeIGDocument();
            }

            $rootScope.msg().text = "igDeleteSuccess";
            $rootScope.msg().type = "success";
            $rootScope.msg().show = true;
            $rootScope.manualHandle = true;
            $scope.igdocumentToDelete = null;
            $scope.loading = false;
            $modalInstance.close($scope.igdocumentToDelete);

        }, function(error) {
            $scope.error = error;
            $scope.loading = false;
            $rootScope.msg().text = "igDeleteFailed";
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;
            //            $modalInstance.dismiss('cancel');


            // waitingDialog.hide();
        });
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});


angular.module('igl').controller('ConfirmIGDocumentCloseCtrl', function($scope, $modalInstance, $rootScope, $http) {
    $scope.loading = false;
    $scope.discardChangesAndClose = function() {
        $scope.loading = true;
        $http.get('api/igdocuments/' + $rootScope.igdocument.id, { timeout: 60000 }).then(function(response) {
            var index = $rootScope.igs.indexOf($rootScope.igdocument);
            $rootScope.igs[index] = angular.fromJson(response.data);
            $scope.loading = false;
            $scope.clear();
        }, function(error) {
            $scope.loading = false;
            $rootScope.msg().text = "igResetFailed";
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;

            $modalInstance.dismiss('cancel');
        });
    };

    $scope.clear = function() {
        $rootScope.closeIGDocument();
        $modalInstance.close();
    };

    $scope.ConfirmIGDocumentOpenCtrl = function() {
        $scope.loading = true;
        var changes = angular.toJson($rootScope.changes);
        var data = { "changes": changes, "igDocument": $rootScope.igdocument };
        $http.post('api/igdocuments/save', data, { timeout: 60000 }).then(function(response) {
            var saveResponse = angular.fromJson(response.data);
            $rootScope.igdocument.metaData.date = saveResponse.date;
            $rootScope.igdocument.metaData.version = saveResponse.version;
            $scope.loading = false;
            $scope.clear();
        }, function(error) {
            $rootScope.msg().text = "igSaveFailed";
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;

            $scope.loading = false;
            $modalInstance.dismiss('cancel');
        });
    };
    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});


angular.module('igl').controller('CreateNewIGAlertCtrl', function($scope, $rootScope, $http, $modalInstance) {
    $scope.close = function() {
        $modalInstance.dismiss('cancel');
    };
});

angular.module('igl').controller('ConfirmIGDocumentOpenCtrl', function($scope, $modalInstance, igdocumentToOpen, $rootScope, $http) {
    $scope.igdocumentToOpen = igdocumentToOpen;
    $scope.loading = false;

    $scope.discardChangesAndOpen = function() {
        $scope.loading = true;
        $http.get('api/igdocuments/' + $rootScope.igdocument.id, { timeout: 60000 }).then(function(response) {
            var index = $rootScope.igs.indexOf($rootScope.igdocument);
            $rootScope.igs[index] = angular.fromJson(response.data);
            $scope.loading = false;
            $modalInstance.close($scope.igdocumentToOpen);
        }, function(error) {
            $scope.loading = false;
            $rootScope.msg().text = "igResetFailed";
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;

            $modalInstance.dismiss('cancel');
        });
    };

    $scope.saveChangesAndOpen = function() {
        $scope.loading = true;
        var changes = angular.toJson($rootScope.changes);
        var data = { "changes": changes, "igDocument": $rootScope.igdocument };
        $http.post('api/igdocuments/save', data, { timeout: 60000 }).then(function(response) {
            var saveResponse = angular.fromJson(response.data);
            $rootScope.igdocument.metaData.date = saveResponse.date;
            $rootScope.igdocument.metaData.version = saveResponse.version;
            $scope.loading = false;
            $modalInstance.close($scope.igdocumentToOpen);
        }, function(error) {
            $rootScope.msg().text = "igSaveFailed";
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;
            $scope.loading = false;
            $modalInstance.dismiss('cancel');
        });
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});

angular.module('igl').controller('DocumentMetaDataCtrl', function($scope, $rootScope, $http, IgDocumentService, blockUI) {
    $scope.saving = false;
    $scope.saved = false;
    $scope.uploader = {};

    $scope.successUpload = function($file, $message, $data) {
        $scope.editForm.$dirty = true;
        var link = JSON.parse($message);
        $rootScope.metaData.coverPicture = link.link;
    };

    $scope.removeCover = function() {
        $scope.editForm.$dirty = true;
        $rootScope.metaData.coverPicture = null;
    };

    $scope.save = function() {
        $scope.saving = true;
        $scope.saved = false;
        if ($rootScope.igdocument != null && $rootScope.metaData != null) {

            IgDocumentService.saveMetadata($rootScope.igdocument.id, $rootScope.metaData).then(function(dateUpdated) {
                $scope.saving = false;
                $scope.saved = true;
                $rootScope.igdocument.metaData = angular.copy($rootScope.metaData);
                $rootScope.igdocument.dateUpdated = dateUpdated;
                if ($scope.editForm) {
                    $scope.editForm.$setPristine();
                    $scope.editForm.$dirty = false;
                }
                $rootScope.clearChanges();
                $rootScope.msg().text = "documentMetaDataSaved";
                $rootScope.msg().type = "success";
                $rootScope.msg().show = true;

            }, function(error) {
                $scope.saving = false;
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
                $scope.saved = false;

            });
        }
    };
    $scope.reset = function() {
        blockUI.start();
        $scope.editForm.$dirty = false;
        $scope.editForm.$setPristine();
        $scope.uploader.flow.cancel();
        $rootScope.clearChanges();
        $rootScope.metaData = angular.copy($rootScope.igdocument.metaData);
        blockUI.stop();
    };
});

angular.module('igl').controller('ProfileMetaDataCtrl', function($scope, $rootScope, $http, ProfileSvc, blockUI) {
    $scope.saving = false;
    $scope.saved = false;
    $scope.save = function() {
        $scope.saving = true;
        $scope.saved = false;
        if ($rootScope.igdocument != null && $rootScope.metaData != null) {

            ProfileSvc.saveMetaData($rootScope.igdocument.id, $rootScope.metaData).then(function(dateUpdated) {
                $scope.saving = false;
                $scope.saved = true;
                $rootScope.igdocument.profile.metaData = angular.copy($rootScope.metaData);
                $rootScope.igdocument.dateUpdated = dateUpdated;
                $scope.editForm.$setPristine();
                $scope.editForm.$dirty = false;
                $rootScope.clearChanges();
                $rootScope.msg().text = "messageInfrasctructureSaved";
                $rootScope.msg().type = "success";
                $rootScope.msg().show = true;

            }, function(error) {
                $scope.saving = false;
                $scope.saved = false;
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        }
    };
    $scope.reset = function() {
        blockUI.start();
        $scope.editForm.$dirty = false;
        $scope.editForm.$setPristine();
        $rootScope.clearChanges();
        $rootScope.metaData = angular.copy($rootScope.igdocument.profile.metaData);
        blockUI.stop();

    };
});


angular.module('igl').controller('SelectMessagesForExportCtrl', function($scope, $modalInstance, igdocumentToSelect, $rootScope, $http, $cookies, ExportSvc) {
    $scope.igdocumentToSelect = igdocumentToSelect;
    $scope.xmlFormat = 'Validation';
    $scope.selectedMessagesIDs = [];
    $scope.loading = false;


    $scope.trackSelections = function(bool, id) {
        if (bool) {
            $scope.selectedMessagesIDs.push(id);
        } else {
            for (var i = 0; i < $scope.selectedMessagesIDs.length; i++) {
                if ($scope.selectedMessagesIDs[i].id == id) {
                    $scope.selectedMessagesIDs.splice(i, 1);
                }
            }
        }
    };


    $scope.exportAsZIPforSelectedMessages = function() {
        $scope.loading = true;
        ExportSvc.exportAsXMLByMessageIds($scope.igdocumentToSelect.id, $scope.selectedMessagesIDs, $scope.xmlFormat);
        $scope.loading = false;
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});

angular.module('igl').controller('AddHL7TableOpenCtrl', function($scope, $modalInstance, selectedTableLibary, hl7Version, $rootScope, $http, $cookies, TableLibrarySvc, TableService) {
    $scope.loading = false;
    $scope.selectedTableLibary = selectedTableLibary;
    $scope.selectedHL7Version = hl7Version;
    $scope.searchText = '';
    $scope.hl7Versions = [];
    $scope.hl7Tables = null;
    $scope.selectedTables = [];

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };

    $scope.listHL7Versions = function() {
        return $http.get('api/igdocuments/findVersions', {
            timeout: 60000
        }).then(function(response) {
            var hl7Versions = [];
            var length = response.data.length;
            for (var i = 0; i < length; i++) {
                hl7Versions.push(response.data[i]);
            }
            $scope.hl7Versions = hl7Versions;
        });
    };

    $scope.loadTablesByVersion = function(hl7Version) {
        $scope.loading = true;
        $scope.selectedHL7Version = hl7Version;
        return $http.get('api/igdocuments/' + hl7Version + "/tables", {
            timeout: 60000
        }).then(function(response) {
            $scope.hl7Tables = [];
            angular.forEach(response.data, function(table) {
                if (!$scope.isAlreadyIn(table)) {
                    $scope.hl7Tables.push(table);
                }
            });
            $scope.loading = false;
        });
    };



    $scope.isAlreadyIn = function(table) {
        if ($rootScope.tablesMap[table.id] == null) return false;
        return true;
    };

    $scope.addTable = function(table) {
        $scope.selectedTables.push(table);
    };

    $scope.deleteTable = function(table) {
        var index = $scope.selectedTables.indexOf(table);
        if (index > -1) $scope.selectedTables.splice(index, 1);
    };


    $scope.save = function() {
        var childrenLinks = [];
        for (var i = 0; i < $scope.selectedTables.length; i++) {
            var newLink = angular.fromJson({
                id: $scope.selectedTables[i].id,
                bindingIdentifier: $scope.selectedTables[i].bindingIdentifier
            });
            $scope.selectedTableLibary.children.push(newLink);
            childrenLinks.push(newLink);
            var addedTable = $scope.selectedTables[i];
            $rootScope.tables.splice(0, 0, addedTable);
            $rootScope.tablesMap[addedTable.id] = addedTable;
        }
        TableLibrarySvc.addChildren($scope.selectedTableLibary.id, childrenLinks).then(function(link) {

            if ($scope.editForm) {
                $scope.editForm.$setPristine();
                $scope.editForm.$dirty = false;
            }
            $rootScope.clearChanges();
            $rootScope.msg().text = "tableSaved";
            $rootScope.msg().type = "success";
            $rootScope.msg().show = true;

        }, function(error) {
            $scope.saving = false;
            $rootScope.msg().text = error.data.text;
            $rootScope.msg().type = error.data.type;
            $rootScope.msg().show = true;
        });


        $modalInstance.dismiss('cancel');
    };

    function positionElements(chidren) {
        var sorted = _.sortBy(chidren, "sectionPosition");
        var start = sorted[0].sectionPosition;
        _.each(sorted, function(sortee) {
            sortee.sectionPosition = start++;
        });
        return sorted;
    };

    $scope.listHL7Versions();

    $scope.loadTablesByVersion($scope.selectedHL7Version);
});

angular.module('igl').controller('AddCSVTableOpenCtrl', function($scope, $modalInstance, selectedTableLibary, $rootScope, $http, $cookies, TableLibrarySvc, TableService, IgDocumentService) {
    $scope.loading = false;
    $scope.selectedTableLibary = selectedTableLibary;
    $scope.importedTable = null;
    $scope.selectedFileName = null;
    $scope.data = null;
    $scope.isInValild = false;
    $scope.erorrMessages = [];
    $scope.validateForSelectedFile = function(files) {
        $scope.isInValild = false;
        var f = document.getElementById('csvValueSetFile').files[0];
        var reader = new FileReader();
        reader.onloadend = function(e) {
            $scope.data = Papa.parse(e.target.result);

            if ($scope.data.errors.length > 0) {
                $scope.isInValild = true;
                angular.forEach($scope.data.errors, function(e) {
                    $scope.erorrMessages.push(e.message);
                });
            }

            var index = 0;
            $scope.importedTable = {};
            $scope.importedTable.scope = 'USER';
            $scope.importedTable.codes = [];
            $scope.importedTable.libIds = [];
            angular.forEach($scope.data.data, function(row) {
                index = index + 1;

                if (index > 1 && index < 11) {
                    if (row[1] != '') {
                        switch (row[0]) {
                            case 'Mapping Identifier':
                                $scope.importedTable.bindingIdentifier = row[1];
                                break;
                            case 'Name':
                                $scope.importedTable.name = row[1];
                                break;
                            case 'Description':
                                $scope.importedTable.description = row[1];
                                break;
                            case 'OID':
                                $scope.importedTable.oid = row[1];
                                break;
                            case 'Version':
                                $scope.importedTable.version = row[1];
                                break;
                            case 'Extensibility':
                                $scope.importedTable.extensibility = row[1];
                                break;
                            case 'Stability':
                                $scope.importedTable.stability = row[1];
                                break;
                            case 'Content Definition':
                                $scope.importedTable.contentDefinition = row[1];
                                break;
                            case 'Comment':
                                $scope.importedTable.comment = row[1];
                        }
                    }
                } else if (index > 13) {

                    var code = {};
                    code.value = row[0];
                    code.label = row[1];
                    code.codeSystem = row[2];
                    code.codeUsage = row[3];
                    code.comments = row[4];

                    if (code.value != null && code.value != "") $scope.importedTable.codes.push(code);
                }
            });

            if ($scope.importedTable.bindingIdentifier == null || $scope.importedTable.bindingIdentifier == '') {
                $scope.isInValild = true;
                $scope.erorrMessages.push('No Binding Identifier');
            }

            if ($scope.importedTable.name == null || $scope.importedTable.name == '') {
                $scope.isInValild = true;
                $scope.erorrMessages.push('No Name');
            }

            var errorElm = $("#errorMessageForCSV");
            var csvSaveButton = $("#csvSaveButton");
            errorElm.empty();

            if ($scope.isInValild) {
                errorElm.append('<span>' + files[0].name + ' is invalid!</span>');
                angular.forEach($scope.erorrMessages, function(e) {
                    errorElm.append("<li>" + e + "</li>");
                    csvSaveButton.prop('disabled', true);
                });
            } else {
                errorElm.append('<span>' + files[0].name + ' is valid!</span>');
                csvSaveButton.prop('disabled', false);
            }

        };

        reader.readAsBinaryString(f);
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


    $scope.save = function() {
        $scope.importedTable.bindingIdentifier = $rootScope.createNewFlavorName($scope.importedTable.bindingIdentifier);
        $scope.importedTable.libIds.push($scope.selectedTableLibary.id);
        $scope.importedTable.newTable = true;

        TableService.save($scope.importedTable).then(function(result) {
            var newTable = result;
            var newLink = {};
            newLink.bindingIdentifier = newTable.bindingIdentifier;
            newLink.id = newTable.id;

            TableLibrarySvc.addChild($scope.selectedTableLibary.id, newLink).then(function(link) {
                $scope.selectedTableLibary.children.splice(0, 0, newLink);
                $rootScope.tables.splice(0, 0, newTable);
                $rootScope.table = newTable;
                $rootScope.tablesMap[newTable.id] = newTable;

                $rootScope.codeSystems = [];

                if ($rootScope.filteredTablesList && $rootScope.filteredTablesList != null) {
                    $rootScope.filteredTablesList.push(newTable);
                    $rootScope.filteredTablesList = _.uniq($rootScope.filteredTablesList);
                }
                $rootScope.$broadcast('event:openTable', newTable);
            }, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });

        }, function(error) {
            $rootScope.msg().text = error.data.text;
            $rootScope.msg().type = error.data.type;
            $rootScope.msg().show = true;
        });

        $modalInstance.dismiss('cancel');
    };

    function positionElements(chidren) {
        var sorted = _.sortBy(chidren, "sectionPosition");
        var start = sorted[0].sectionPosition;
        _.each(sorted, function(sortee) {
            sortee.sectionPosition = start++;
        });
        return sorted;
    }
});

angular.module('igl').controller('AddPHINVADSTableOpenCtrl', function($scope, $modalInstance, selectedTableLibary, $rootScope, $http, $cookies, TableLibrarySvc, TableService) {
    $scope.loading = false;
    $scope.selectedTableLibary = selectedTableLibary;
    $scope.searchText = '';
    $scope.hl7Tables = null;
    $scope.preloadedPhinvadsTables = [];
    $scope.phinvadsTables = [];
    $scope.selectedTables = [];

    $scope.loadPhinvads = function() {
        $scope.loading = true;
        return $http.get('api/igdocuments/PHINVADS/tables', {
            timeout: 600000
        }).then(function(response) {
            $scope.preloadedPhinvadsTables = response.data;
            $scope.loading = false;
        });
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };

    $scope.searchPhinvads = function(searchText) {
        $scope.loading = true;
        $scope.searchText = searchText;
        return $http.get('api/igdocuments/' + searchText + "/PHINVADS/tables", {
            timeout: 600000
        }).then(function(response) {
            $scope.phinvadsTables = response.data;
            $scope.loading = false;
        });
    };

    $scope.isAlreadyIn = function(table) {
        if ($rootScope.tablesMap[table.id] == null) return false;
        return true;
    };

    $scope.isAlreadySelected = function(table) {
        var index = _.findIndex($scope.selectedTables, function(child) {
            return child.id === table.id;
        });
        if (index == -1) return false;
        return true;
    };

    $scope.addTable = function(table) {
        $scope.selectedTables.push(table);
    };

    $scope.deleteTable = function(table) {
        var index = $scope.selectedTables.indexOf(table);
        if (index > -1) $scope.selectedTables.splice(index, 1);
    };

    $scope.save = function() {
        var childrenLinks = [];
        for (var i = 0; i < $scope.selectedTables.length; i++) {
            $http.get('api/tables/' + $scope.selectedTables[i].id, {
                timeout: 600000
            }).then(function(response) {
                var addedTable = response.data;
                $rootScope.tables.splice(0, 0, addedTable);
                $rootScope.tablesMap[addedTable.id] = addedTable;
            });

            var newLink = angular.fromJson({
                id: $scope.selectedTables[i].id,
                bindingIdentifier: $scope.selectedTables[i].bindingIdentifier
            });
            $scope.selectedTableLibary.children.push(newLink);
            childrenLinks.push(newLink);
        }
        TableLibrarySvc.addChildren($scope.selectedTableLibary.id, childrenLinks).then(function(link) {

            if ($scope.editForm) {
                $scope.editForm.$setPristine();
                $scope.editForm.$dirty = false;
            }
            $rootScope.clearChanges();
            $rootScope.msg().text = "tableSaved";
            $rootScope.msg().type = "success";
            $rootScope.msg().show = true;

        }, function(error) {
            $scope.saving = false;
            $rootScope.msg().text = error.data.text;
            $rootScope.msg().type = error.data.type;
            $rootScope.msg().show = true;
        });


        $modalInstance.dismiss('cancel');
    };


    $scope.loadPhinvads();
});


angular.module('igl').controller('AddDatatypeDlgCtl',
    function($scope, $rootScope, $modalInstance, hl7Version, datatypes, masterLib, userDtLib, DatatypeLibrarySvc, DatatypeService, TableLibrarySvc, TableService, $http) {

        //$scope.hl7Version = hl7Version;
        //$scope.hl7Datatypes = datatypes;

        $scope.newDts = [];
        $scope.checkedExt = true;
        $scope.NocheckedExt = true;
        $scope.masterLib = [];
        $scope.userDtLib = userDtLib;
        $scope.masterLib = masterLib;
        $scope.selectedDatatypes = [];
        // for (var i = 0; i < $scope.masterDts.length; i++) {
        //     if (!$rootScope.datatypesMap[$scope.masterDts[i].id]) {
        //         $scope.masterDatatypes.push($scope.masterDts[i]);
        //     }
        // }
        $scope.selectUserDtLib = function(usrLib) {
            console.log(usrLib);
            DatatypeLibrarySvc.getDatatypesByLibrary(usrLib.id).then(function(datatypes) {
                $scope.userDatatypes = datatypes;
                $scope.userDatatypes = _.where(datatypes, { scope: "USER", status: "PUBLISHED" });
            });
        };
        $scope.selectMasterDtLib = function(masLib) {
            console.log(masLib);
            DatatypeLibrarySvc.getDatatypesByLibrary(masLib.id).then(function(datatypes) {
                $scope.masterDatatypes = _.where(datatypes, { scope: "MASTER", status: "PUBLISHED" });
                //$scope.masterDatatypes = datatypes;
                console.log($scope.masterDatatypes);
            });
        };
        var listHL7Versions = function() {
            return $http.get('api/igdocuments/findVersions', {
                timeout: 60000
            }).then(function(response) {
                var hl7Versions = [];
                var length = response.data.length;
                for (var i = 0; i < length; i++) {
                    hl7Versions.push(response.data[i]);
                }
                console.log(hl7Versions);
                return hl7Versions;
            });
        };

        var init = function() {
            listHL7Versions().then(function(versions) {
                //$scope.versions = versions;
                var v = [];
                for (var i = 0; i < versions.length; i++) {
                    if (versions.indexOf(hl7Version) <= i) {
                        v.push(versions[i]);
                    }
                }

                $scope.version1 = hl7Version;
                $scope.versions = v;
                var scopes = ['HL7STANDARD'];
                DatatypeService.getDataTypesByScopesAndVersion(scopes, hl7Version).then(function(result) {
                    console.log("result");
                    console.log(result);
                    $scope.hl7Datatypes = result;

                    // $scope.hl7Segments = result.filter(function(current) {
                    //     return $rootScope.segments.filter(function(current_b) {
                    //         return current_b.id == current.id;
                    //     }).length == 0
                    // });




                    console.log("addSegment scopes=" + scopes.length);


                });
            });

        };
        init();
        $scope.setVersion = function(version) {
            $scope.version1 = version;
            var scopes = ['HL7STANDARD'];
            DatatypeService.getDataTypesByScopesAndVersion(scopes, version).then(function(result) {
                console.log("result");
                console.log(result);
                $scope.hl7Datatypes = result;

                // $scope.hl7Segments = result.filter(function(current) {
                //     return $rootScope.segments.filter(function(current_b) {
                //         return current_b.id == current.id;
                //     }).length == 0
                // });






            });
        }





        $scope.addDt = function(datatype) {
            console.log(datatype);
            $scope.selectedDatatypes.push(datatype);

        };
        $scope.checkExist = function(datatype) {

            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
                if ($scope.selectedDatatypes[i].id === datatype.id) {
                    return true;
                }
            }
            for (var i = 0; i < $rootScope.datatypes.length; i++) {
                if ($rootScope.datatypes[i].id === datatype.id) {
                    return true;
                }
            }
            return false;
        }
        $scope.checkExt = function(datatype) {
            $scope.checkedExt = true;
            $scope.NocheckedExt = true;
            if (datatype.ext === "") {
                $scope.NocheckedExt = false;
                return $scope.NocheckedExt;
            }
            for (var i = 0; i < $rootScope.datatypes.length; i++) {
                if ($rootScope.datatypes[i].name === datatype.name && $rootScope.datatypes[i].ext === datatype.ext) {
                    $scope.checkedExt = false;
                    return $scope.checkedExt;
                }
            }
            console.log($scope.selectedDatatypes.indexOf(datatype));
            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
                if ($scope.selectedDatatypes.indexOf(datatype) !== i) {
                    if ($scope.selectedDatatypes[i].name === datatype.name && $scope.selectedDatatypes[i].ext === datatype.ext) {
                        $scope.checkedExt = false;
                        return $scope.checkedExt;
                    }
                }

            }

            return $scope.checkedExt;
        };

        $scope.addDtFlv = function(datatype) {
            var newDatatype = angular.copy(datatype);

            newDatatype.ext = $rootScope.createNewExtension(newDatatype.ext);
            newDatatype.scope = 'USER';
            newDatatype.status = 'UNPUBLISHED';
            newDatatype.participants = [];
            newDatatype.id = new ObjectId().toString();
            newDatatype.libIds = [];
            newDatatype.libIds.push($rootScope.igdocument.profile.datatypeLibrary.id);
            if (datatype.scope === 'MASTER') {
                console.log("merging");
                //newDatatype.hl7versions=[$rootScope.igdocument.profile.metaData.hl7Version];
                var temp = [];
                temp.push($rootScope.igdocument.profile.metaData.hl7Version);
                newDatatype.hl7versions = temp;
                newDatatype.hl7Version = $rootScope.igdocument.profile.metaData.hl7Version;
                DatatypeService.getOneStandard(datatype.name, newDatatype.hl7Version, newDatatype.hl7versions).then(function(standard) {
                    $rootScope.mergeEmptyProperty(newDatatype, standard);
                });
            }



            if (newDatatype.components != undefined && newDatatype.components != null && newDatatype.components.length != 0) {
                for (var i = 0; i < newDatatype.components.length; i++) {
                    newDatatype.components[i].id = new ObjectId().toString();
                }
            }

            var predicates = newDatatype['predicates'];
            if (predicates != undefined && predicates != null && predicates.length != 0) {
                angular.forEach(predicates, function(predicate) {
                    predicate.id = new ObjectId().toString();
                });
            }

            var conformanceStatements = newDatatype['conformanceStatements'];
            if (conformanceStatements != undefined && conformanceStatements != null && conformanceStatements.length != 0) {
                angular.forEach(conformanceStatements, function(conformanceStatement) {
                    conformanceStatement.id = new ObjectId().toString();
                });
            }
            $scope.selectedDatatypes.push(newDatatype);
            console.log($scope.selectedDatatypes)
        }
        $scope.deleteDt = function(datatype) {
            var index = $scope.selectedDatatypes.indexOf(datatype);
            if (index > -1) $scope.selectedDatatypes.splice(index, 1);
        };
        var secretEmptyKey = '[$empty$]'

        $scope.hl7Datatypes = datatypes.filter(function(current) {
            return $rootScope.datatypes.filter(function(current_b) {
                return current_b.id == current.id;
            }).length == 0
        });


        $scope.dtComparator = function(datatype, viewValue) {
            if (datatype) {
                console.log(datatype.name);
                console.log(datatype);
            }
            return viewValue === secretEmptyKey || (datatype && ('' + datatype.name).toLowerCase().indexOf(('' + viewValue).toLowerCase()) > -1);
        };


        $scope.isInDts = function(datatype) {

            if ($scope.hl7Datatypes.indexOf(datatype) === -1) {
                return false;
            } else {
                return true;
            }

        }


        $scope.selectDT = function(datatype) {
            console.log(datatype);
            $scope.newDatatype = datatype;
        };
        $scope.selected = function() {
            return ($scope.newDatatype !== undefined);
        };
        $scope.unselect = function() {
            $scope.newDatatype = undefined;
        };
        $scope.isActive = function(id) {
            if ($scope.newDatatype) {
                return $scope.newDatatype.id === id;
            } else {
                return false;
            }
        };


        $scope.ok = function() {
            console.log($scope.selectedDatatypes);
            $scope.selectFlv = [];
            var newLinks = [];
            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
                if ($scope.selectedDatatypes[i].scope === 'USER') {
                    $scope.selectFlv.push($scope.selectedDatatypes[i]);
                } else {
                    newLinks.push({
                        id: $scope.selectedDatatypes[i].id,
                        name: $scope.selectedDatatypes[i].name
                    })
                }
            }
            $rootScope.usedDtLink = [];
            $rootScope.usedVsLink = [];
            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
                $rootScope.fillMaps($scope.selectedDatatypes[i]);
            }
            DatatypeService.saves($scope.selectFlv).then(function(result) {
                for (var i = 0; i < result.length; i++) {
                    newLinks.push({
                        id: result[i].id,
                        name: result[i].name,
                        ext: result[i].ext
                    })
                }
                DatatypeLibrarySvc.addChildren($rootScope.igdocument.profile.datatypeLibrary.id, newLinks).then(function(link) {
                    for (var i = 0; i < newLinks.length; i++) {
                        $rootScope.igdocument.profile.datatypeLibrary.children.splice(0, 0, newLinks[i]);
                    }
                    for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
                        $rootScope.datatypes.splice(0, 0, $scope.selectedDatatypes[i]);
                    }
                    for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
                        $rootScope.datatypesMap[$scope.selectedDatatypes[i].id] = $scope.selectedDatatypes[i];
                    }
                    var usedDtId1 = _.map($rootScope.usedDtLink, function(num, key) {
                        return num.id;
                    });

                    DatatypeService.get(usedDtId1).then(function(datatypes) {
                        for (var j = 0; j < datatypes.length; j++) {
                            if (!$rootScope.datatypesMap[datatypes[j].id]) {

                                $rootScope.datatypesMap[datatypes[j].id] = datatypes[j];
                                $rootScope.datatypes.push(datatypes[j]);
                                $rootScope.processElement(datatypes[j]);
                            }
                        }

                        var usedVsId = _.map($rootScope.usedVsLink, function(num, key) {
                            return num.id;
                        });
                        console.log("$rootScope.usedVsLink");

                        console.log($rootScope.usedVsLink);
                        var newTablesLink = _.difference($rootScope.usedVsLink, $rootScope.igdocument.profile.tableLibrary.children);
                        console.log(newTablesLink);

                        TableLibrarySvc.addChildren($rootScope.igdocument.profile.tableLibrary.id, newTablesLink).then(function() {
                            $rootScope.igdocument.profile.tableLibrary.children = _.union(newTablesLink, $rootScope.igdocument.profile.tableLibrary.children);

                            TableService.get(usedVsId).then(function(tables) {
                                for (var j = 0; j < tables.length; j++) {
                                    if (!$rootScope.tablesMap[tables[j].id]) {
                                        $rootScope.tablesMap[tables[j].id] = tables[j];
                                        $rootScope.tables.push(tables[j]);
                                        $rootScope.processElement(tables[j]);

                                    }
                                }

                                for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
                                    $rootScope.processElement($scope.selectedDatatypes[i]);
                                }
                                //$rootScope.processElement($scope.newSegment);

                            });
                        });
                    });


                    //$rootScope.processElement($scope.newDatatype);
                    // $rootScope.filteredDatatypesList.push($scope.newDatatype);
                    // $rootScope.filteredDatatypesList = _.uniq($rootScope.filteredDatatypesList);
                    // $rootScope.$broadcast('event:openDatatype', $scope.newDatatype);
                    $rootScope.msg().text = "datatypeAdded";
                    $rootScope.msg().type = "success";
                    $rootScope.msg().show = true;
                    $modalInstance.close(datatypes);
                });

            }, function(error) {
                $rootScope.saving = false;
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });


        };

        $scope.cancel = function() {
            $modalInstance.dismiss('cancel');
        };
    });

angular.module('igl').controller('AddMasterDatatypes',
    function($scope, $rootScope, $modalInstance, datatypes, DatatypeLibrarySvc, DatatypeService) {
        $scope.version = $rootScope.igdocument.profile.metaData.hl7Version;
        $scope.scopes = ["MASTER"];
        $scope.masterDatatypes = [];
        $scope.newDts = [];
        DatatypeService.getPublishedMaster().then(function(result) {
            $scope.masterDatatypes = result;

        });



        $scope.ok = function() {
            var newLink = angular.fromJson({
                id: $scope.newDatatype.id,
                name: $scope.newDatatype.name
            });

            DatatypeLibrarySvc.addChild($rootScope.igdocument.profile.datatypeLibrary.id, newLink).then(function(link) {
                $rootScope.igdocument.profile.datatypeLibrary.children.splice(0, 0, newLink);
                $rootScope.datatypes.splice(0, 0, $scope.newDatatype);
                $rootScope.datatype = $scope.newDatatype;
                $rootScope.datatypesMap[$scope.newDatatype.id] = $scope.newDatatype;
                $rootScope.processElement($scope.newDatatype);
                $rootScope.filteredDatatypesList.push($scope.newDatatype);
                $rootScope.filteredDatatypesList = _.uniq($rootScope.filteredDatatypesList);
                $rootScope.$broadcast('event:openDatatype', $scope.newDatatype);
                $rootScope.msg().text = "datatypeAdded";
                $rootScope.msg().type = "success";
                $rootScope.msg().show = true;
                $modalInstance.close(datatypes);
            }, function(error) {
                $rootScope.saving = false;
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        };

        $scope.cancel = function() {
            $modalInstance.dismiss('cancel');
        };
    });


angular.module('igl').controller('AddSegmentDlgCtl',
    function($scope, $rootScope, $modalInstance, hl7Version, $http, SegmentService, SegmentLibrarySvc, DatatypeService, DatatypeLibrarySvc, TableService, TableLibrarySvc, IgDocumentService) {

        $scope.selectedSegments = [];
        $scope.checkedExt = true;
        $scope.NocheckedExt = true;

        $scope.addseg = function(segment) {
            $scope.selectedSegments.push(segment);
            console.log($scope.selectedSegments);

        };
        $scope.checkExist = function(segment) {
            // if ($scope.selectedSegments.indexOf(segment) !== -1) {
            //     return true;
            // }
            for (var i = 0; i < $scope.selectedSegments.length; i++) {
                if ($scope.selectedSegments[i].id === segment.id) {
                    return true;
                }
            }
            return false;
        }
        $scope.checkExt = function(segment) {
            console.log(segment);
            $scope.checkedExt = true;
            $scope.NocheckedExt = true;
            if (segment.ext === "") {
                $scope.NocheckedExt = false;
                return $scope.NocheckedExt;
            }
            for (var i = 0; i < $rootScope.segments.length; i++) {
                if ($rootScope.segments[i].name === segment.name && $rootScope.segments[i].ext === segment.ext) {
                    $scope.checkedExt = false;
                    return $scope.checkedExt;
                }
            }
            console.log($scope.selectedSegments.indexOf(segment));
            for (var i = 0; i < $scope.selectedSegments.length; i++) {
                if ($scope.selectedSegments.indexOf(segment) !== i) {
                    if ($scope.selectedSegments[i].name === segment.name && $scope.selectedSegments[i].ext === segment.ext) {
                        $scope.checkedExt = false;
                        return $scope.checkedExt;
                    }
                }

            }

            return $scope.checkedExt;
        };
        $scope.addsegFlv = function(segment) {
            var newSegment = angular.copy(segment);
            newSegment.participants = [];
            newSegment.scope = 'USER';
            newSegment.id = new ObjectId().toString();
            newSegment.libIds = [];
            newSegment.libIds.push($rootScope.igdocument.profile.segmentLibrary.id);
            newSegment.ext = $rootScope.createNewExtension(newSegment.ext);

            if (newSegment.fields != undefined && newSegment.fields != null && newSegment.fields.length != 0) {
                for (var i = 0; i < newSegment.fields.length; i++) {
                    newSegment.fields[i].id = new ObjectId().toString();
                }
            }


            var dynamicMappings = newSegment['dynamicMappings'];
            if (dynamicMappings != undefined && dynamicMappings != null && dynamicMappings.length != 0) {
                angular.forEach(dynamicMappings, function(dynamicMapping) {
                    dynamicMapping.id = new ObjectId().toString();
                    angular.forEach(dynamicMapping.mappings, function(mapping) {
                        mapping.id = new ObjectId().toString();
                    });
                });
            }
            $scope.selectedSegments.push(newSegment);
        }
        $scope.deleteSeg = function(segment) {
            var index = $scope.selectedSegments.indexOf(segment);
            if (index > -1) $scope.selectedSegments.splice(index, 1);
        };

        var listHL7Versions = function() {
            return $http.get('api/igdocuments/findVersions', {
                timeout: 60000
            }).then(function(response) {
                var hl7Versions = [];
                var length = response.data.length;
                for (var i = 0; i < length; i++) {
                    hl7Versions.push(response.data[i]);
                }
                console.log(hl7Versions);
                return hl7Versions;
            });
        };


        var init = function() {
            listHL7Versions().then(function(versions) {
                //$scope.versions = versions;
                var v = [];
                for (var i = 0; i < versions.length; i++) {
                    if (versions.indexOf(hl7Version) <= i) {
                        v.push(versions[i]);
                    }
                }

                $scope.version1 = hl7Version;
                $scope.versions = v;
                var scopes = ['HL7STANDARD'];
                SegmentService.getSegmentsByScopesAndVersion(scopes, hl7Version).then(function(result) {
                    console.log("result");
                    console.log(result);

                    $scope.hl7Segments = result.filter(function(current) {
                        return $rootScope.segments.filter(function(current_b) {
                            return current_b.id == current.id;
                        }).length == 0
                    });




                    console.log("addSegment scopes=" + scopes.length);


                });
            });

        };
        init();
        var secretEmptyKey = '[$empty$]'
        $scope.segComparator = function(seg, viewValue) {

            return viewValue === secretEmptyKey || ('' + seg).toLowerCase().indexOf(('' + viewValue).toLowerCase()) > -1;
        };



        $scope.setVersion = function(version) {
            console.log($scope.selectedSegments);
            $scope.version1 = version;
            var scopes = ['HL7STANDARD'];
            SegmentService.getSegmentsByScopesAndVersion(scopes, version).then(function(result) {
                console.log("result");
                console.log(result);

                $scope.hl7Segments = result.filter(function(current) {
                    return $rootScope.segments.filter(function(current_b) {
                        return current_b.id == current.id;
                    }).length == 0
                });




                console.log("addSegment scopes=" + scopes.length);


            });
        }

        console.log("=----");
        console.log($scope.hl7Segments);
        $scope.isInSegs = function(segment) {

            if (segment && $scope.hl7Segments.indexOf(segment) === -1) {
                return false;
            } else {
                return true;
            }

        };
        $scope.selectSeg = function(segment) {
            $scope.newSegment = segment;
        };
        $scope.selected = function() {
            return ($scope.newSegment !== undefined);
        };
        $scope.unselect = function() {
            $scope.newSegment = undefined;
        };
        $scope.isActive = function(id) {
            if ($scope.newSegment) {
                return $scope.newSegment.id === id;
            } else {
                return false;
            }
        };


        $scope.ok = function() {
            // var newLink = angular.fromJson({
            //     id: $scope.newSegment.id,
            //     name: $scope.newSegment.name
            // });

            $scope.selectFlv = [];
            var newLinks = [];
            for (var i = 0; i < $scope.selectedSegments.length; i++) {
                if ($scope.selectedSegments[i].scope === 'USER') {
                    $scope.selectFlv.push($scope.selectedSegments[i]);
                } else {
                    newLinks.push({
                        id: $scope.selectedSegments[i].id,
                        name: $scope.selectedSegments[i].name
                    })
                }
            }

            // for (var i = 0; i < $scope.selectedSegments.length; i++) {
            //     newLinks.push({
            //         id: $scope.selectedSegments[i].id,
            //         name: $scope.selectedSegments[i].name
            //     })
            // }


            console.log("newLinks");
            console.log(newLinks);
            $rootScope.usedDtLink = [];
            $rootScope.usedVsLink = [];
            for (var i = 0; i < $scope.selectedSegments.length; i++) {
                $rootScope.fillMaps($scope.selectedSegments[i]);
            }
            SegmentService.saves($scope.selectFlv).then(function(result) {
                    for (var i = 0; i < result.length; i++) {
                        newLinks.push({
                            id: result[i].id,
                            name: result[i].name,
                            ext: result[i].ext
                        })
                    }
                    console.log("result");
                    console.log(result);
                    SegmentLibrarySvc.addChildren($rootScope.igdocument.profile.segmentLibrary.id, newLinks).then(function(link) {
                        // $rootScope.igdocument.profile.segmentLibrary.children.splice(0, 0, newLinks);
                        for (var i = 0; i < newLinks.length; i++) {
                            $rootScope.igdocument.profile.segmentLibrary.children.splice(0, 0, newLinks[i]);
                        }
                        //$rootScope.segments.splice(0, 0, $scope.selectedSegments);
                        for (var i = 0; i < $scope.selectedSegments.length; i++) {
                            $rootScope.segments.splice(0, 0, $scope.selectedSegments[i]);
                        }
                        //$rootScope.segment = $scope.newSegment;
                        //$rootScope.segmentsMap[$scope.newSegment.id] = $scope.newSegment;
                        for (var i = 0; i < $scope.selectedSegments.length; i++) {
                            $rootScope.segmentsMap[$scope.selectedSegments[i].id] = $scope.selectedSegments[i];
                        }
                        //TODO MasterMap need to add Segment

                        //                  MastermapSvc.addSegmentObject(newSegment, [[$rootScope.igdocument.id, "ig"], [$rootScope.igdocument.profile.id, "profile"]]);
                        // $rootScope.filteredSegmentsList.push($scope.newSegment);
                        // $rootScope.filteredSegmentsList = _.uniq($rootScope.filteredSegmentsList);
                        // $rootScope.$broadcast('event:openSegment', $scope.newSegment);
                        $rootScope.msg().text = "segmentAdded";
                        $rootScope.msg().type = "success";
                        $rootScope.msg().show = true;
                        $modalInstance.close();
                        var usedDtId = _.map($rootScope.usedDtLink, function(num, key) {
                            return num.id;
                        });
                        DatatypeService.get(usedDtId).then(function(datatypes) {
                            for (var j = 0; j < datatypes.length; j++) {

                                $rootScope.fillMaps(datatypes[j]);

                            }
                            var usedDtId1 = _.map($rootScope.usedDtLink, function(num, key) {
                                return num.id;
                            });
                            var newDatatypesLink = _.difference($rootScope.usedDtLink, $rootScope.igdocument.profile.datatypeLibrary.children);
                            DatatypeLibrarySvc.addChildren($rootScope.igdocument.profile.datatypeLibrary.id, newDatatypesLink).then(function() {
                                $rootScope.igdocument.profile.datatypeLibrary.children = _.union(newDatatypesLink, $rootScope.igdocument.profile.datatypeLibrary.children);

                                DatatypeService.get(usedDtId1).then(function(datatypes) {
                                    for (var j = 0; j < datatypes.length; j++) {
                                        if (!$rootScope.datatypesMap[datatypes[j].id]) {

                                            $rootScope.datatypesMap[datatypes[j].id] = datatypes[j];
                                            $rootScope.datatypes.push(datatypes[j]);
                                            $rootScope.processElement(datatypes[j]);
                                        }
                                    }

                                    var usedVsId = _.map($rootScope.usedVsLink, function(num, key) {
                                        return num.id;
                                    });
                                    console.log("$rootScope.usedVsLink");

                                    console.log($rootScope.usedVsLink);
                                    var newTablesLink = _.difference($rootScope.usedVsLink, $rootScope.igdocument.profile.tableLibrary.children);
                                    console.log(newTablesLink);

                                    TableLibrarySvc.addChildren($rootScope.igdocument.profile.tableLibrary.id, newTablesLink).then(function() {
                                        $rootScope.igdocument.profile.tableLibrary.children = _.union(newTablesLink, $rootScope.igdocument.profile.tableLibrary.children);

                                        TableService.get(usedVsId).then(function(tables) {
                                            for (var j = 0; j < tables.length; j++) {
                                                if (!$rootScope.tablesMap[tables[j].id]) {
                                                    $rootScope.tablesMap[tables[j].id] = tables[j];
                                                    $rootScope.tables.push(tables[j]);
                                                    $rootScope.processElement(tables[j]);

                                                }
                                            }


                                            $rootScope.processElement($scope.newSegment);

                                        });
                                    });


                                });
                            });
                        });

                    })
                },
                function(error) {
                    $scope.saving = false;
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                })

        };

        $scope.cancel = function() {
            $modalInstance.dismiss('cancel');
        };
    });

angular.module('igl').controller('ShareIGDocumentCtrl', function($scope, $modalInstance, $http, igdocumentSelected, userList, IgDocumentService, $rootScope) {

    $scope.igdocumentSelected = igdocumentSelected;
    $scope.userList = userList;
    $scope.error = "";
    $scope.ok = function() {
        var idsTab = $scope.tags.map(function(user) {
            return user.id;
        });
        IgDocumentService.share($scope.igdocumentSelected.id, idsTab).then(function(result) {

            // Add participants for direct view
            $scope.igdocumentSelected.shareParticipants = $scope.igdocumentSelected.shareParticipants || [];
            $scope.tags.forEach(function(tag) {
                tag.permission = $scope.selectedItem.selected;
                tag.pendingApproval = true;
                $scope.igdocumentSelected.shareParticipants.push(tag);
            });
            $rootScope.msg().text = "igSharedSuccessfully";
            $rootScope.msg().type = "success";
            $rootScope.msg().show = true;
            $modalInstance.close();
        }, function(error) {
            $scope.error = error.data;
            console.log(error);
        });
    };
    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
    $scope.tags = [];
    $scope.selectedItem = {
        selected: "VIEW"
    };
    $scope.itemArray = ["VIEW"];

    $scope.tags = [];
    $scope.loadUsernames = function($query) {
        return userList.filter(function(user) {
            return user.username.toLowerCase().indexOf($query.toLowerCase()) != -1;
        });
    };

    $scope.unshare = function(shareParticipant) {
        $scope.loading = false;
        IgDocumentService.unshare($scope.igdocumentSelected.id, shareParticipant.id).then(function(res) {

            var indexOfId = $scope.igdocumentSelected.shareParticipantIds.indexOf(shareParticipant.id);
            if (indexOfId > -1) {
                $scope.igdocumentSelected.shareParticipantIds.splice(indexOfId, 1);
            }
            var participantIndex = -1;
            for (var i = 0; i < $scope.igdocumentSelected.shareParticipants.length; i++) {
                if ($scope.igdocumentSelected.shareParticipants[i].id === shareParticipant.id) {
                    participantIndex = i;
                    $scope.userList.push($scope.igdocumentSelected.shareParticipants[i]);
                    break;
                }
            }
            if (participantIndex > -1) {
                $scope.igdocumentSelected.shareParticipants.splice(participantIndex, 1);
            }
            $scope.loading = false;
            $rootScope.msg().text = "igUnSharedSuccessfully";
            $rootScope.msg().type = "success";
            $rootScope.msg().show = true;
        }, function(error) {

            $rootScope.msg().text = error.data.text;
            $rootScope.msg().type = error.data.type;
            $rootScope.msg().show = true;
            $scope.loading = false;
        });
    };


});

angular.module('igl').controller('UnShareIGDocumentCtrl', function($scope, $modalInstance, $http, igdocumentSelected, shareParticipant, IgDocumentService, $rootScope) {

    $scope.igdocumentSelected = igdocumentSelected;
    $scope.shareParticipant = shareParticipant;
    $scope.error = "";
    $scope.loading = false;
    $scope.ok = function() {
        $scope.loading = true;
        IgDocumentService.unshare(igdocumentSelected.id, shareParticipant.id).then(function(res) {

            var indexOfId = igdocumentSelected.shareParticipantIds.indexOf(shareParticipant.id);
            if (indexOfId > -1) {
                igdocumentSelected.shareParticipantIds.splice(indexOfId, 1);
            }
            var participantIndex = -1;
            for (var i = 0; i < igdocumentSelected.shareParticipants.length; i++) {
                if (igdocumentSelected.shareParticipants[i].id === shareParticipant.id) {
                    participantIndex = i;
                    break;
                }
            }
            if (participantIndex > -1) {
                igdocumentSelected.shareParticipants.splice(participantIndex, 1);
            }
            $scope.loading = false;
            $rootScope.msg().text = "igUnSharedSuccessfully";
            $rootScope.msg().type = "success";
            $rootScope.msg().show = true;
            $modalInstance.close();
        }, function(error) {

            $rootScope.msg().text = error.data.text;
            $rootScope.msg().type = error.data.type;
            $rootScope.msg().show = true;
            $scope.loading = false;
        });
    };
    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});

angular.module('igl').controller('createProfileComponentCtrl',
    function($scope, $rootScope, $modalInstance, $http, PcService, IgDocumentService) {
        $scope.create = function() {
            var newPC = {
                name: $scope.name,
                description: $scope.description,
                comment: $scope.comment,
                appliedTo: [],
                children: []
            };
            console.log(newPC);

            //add save function

            IgDocumentService.saveProfileComponent($rootScope.igdocument.id, newPC).then(function(profileC) {
                $rootScope.profileComponent = profileC;
                console.log(profileC);

                $rootScope.igdocument.profile.profileComponentLibrary.children.push(profileC);
                $rootScope.profileComponents.push(profileC);
                $scope.Activate(profileC.id);
                $modalInstance.close(profileC);

            });







        };

        $scope.cancel = function() {
            $modalInstance.dismiss('cancel');
        };
    });


angular.module('igl').controller('createCompositeMessageCtrl',
    function($scope, $rootScope, $modalInstance, $http, $filter, PcService, IgDocumentService, CompositeMessageService) {




        $scope.pcList = [];
        $scope.baseProfiles = $rootScope.messages.children;
        $scope.pcs = $rootScope.profileComponents;
        $scope.position = 1;

        // $scope.start = function(event, ui, bp) {
        //     $scope.compositeMessage = bp;
        // };
        // $scope.baseProfileOption = {
        //     activate: function(event, ui) {
        //     }
        // };

        $scope.selectBaseProfile = function(baseP) {
            $scope.baseP = angular.copy(baseP);
        };
        $scope.checkExist = function(pc) {
            for (var i = 0; i < $scope.pcList.length; i++) {
                if ($scope.pcList[i].id === pc.id) {
                    return true;
                }
            }
            return false;
        };
        $scope.removePc = function(pc) {
            var positionToRemove = pc.position;
            var index = $scope.pcList.indexOf(pc);
            if (index > -1) $scope.pcList.splice(index, 1);
            for (var i = 0; i < $scope.pcList.length; i++) {
                if ($scope.pcList[i].position >= positionToRemove) {
                    $scope.pcList[i].position = $scope.pcList[i].position - 1;
                }
            }
            $scope.position = $scope.position - 1;

        };
        $scope.selectPC = function(pc) {
            console.log(pc);
            pc.position = angular.copy($scope.position);
            $scope.pcList.push(pc);
            $scope.position = $scope.position + 1;
        };


        $scope.create = function() {
            $scope.baseP.id = new ObjectId().toString();

            var processFields = function(fields) {
                for (var i = 0; i < fields.length; i++) {
                    fields[i].datatype = angular.copy($rootScope.datatypesMap[fields[i].datatype.id]);
                    if (fields[i].datatype.components.length > 0) {
                        fields[i].datatype.components = processFields(fields[i].datatype.components);
                    }
                    for (var j = 0; j < fields[i].tables.length; j++) {
                        fields[i].tables[j] = angular.copy($rootScope.tablesMap[fields[i].tables[j].id]);
                    }

                }
                return fields;
            };
            var processMessage = function(message) {
                for (var i = 0; i < message.children.length; i++) {
                    message.children[i].id = new ObjectId().toString();
                    if (message.children[i].type === "segmentRef") {
                        message.children[i].ref = angular.copy($rootScope.segmentsMap[message.children[i].ref.id]);
                        message.children[i].ref.fields = processFields(message.children[i].ref.fields);
                    } else if (message.children[i].type === "group") {
                        processMessage(message.children[i]);
                    }

                }
                return message;
            };

            var message = angular.copy($scope.baseP);

            var getObjectFromPath = function(pathType, path, message) {
                var splitPath = path.split(".");
                if (pathType === "pathExp") {
                    console.log("exp");
                    console.log(splitPath);
                    for (var i = 1; i < splitPath.length; i++) {
                        console.log(splitPath[i]);
                    }
                } else {
                    console.log("noExp");
                    console.log(splitPath);
                    if (splitPath[0] === message.structID) {
                        console.log("can");
                    } else {
                        console.log("cant");

                    }
                    for (var i = 1; i < splitPath.length; i++) {
                        console.log(splitPath[i]);

                    }

                }
            };

            $scope.Map = [];
            var buildMap = function(parentPath, element) {
                var path = "";
                if (element.type === "segmentRef") {
                    path = parentPath + '.' + element.position;
                    $scope.Map[path] = element;
                } else if (element.type === "group" || element.type === "message") {
                    for (var i = 0; i < element.children.length; i++) {
                        if (element.children[i].type === "group") {
                            grpPath = parentPath + '.' + element.children[i].position;
                            path = parentPath + '.' + element.children[i].name;

                            $scope.Map[grpPath] = element.children[i];
                            buildMap(path, element.children[i]);
                        } else if (element.children[i].type === "segmentRef") {
                            segPath = parentPath + '.' + element.children[i].position;
                            path = parentPath + '.' + element.children[i].ref.label;
                            $scope.Map[segPath] = element.children[i];
                            buildMap(path, element.children[i].ref);
                            // buildMap(path, element.children[i]);
                        }
                    }
                } else if (element.type === "segment") {
                    for (var i = 0; i < element.fields.length; i++) {
                        fieldPath = parentPath + '.' + element.fields[i].position;
                        $scope.Map[fieldPath] = element.fields[i];
                        buildMap(fieldPath, element.fields[i].datatype);
                    }
                } else if (element.type === "datatype") {
                    for (var i = 0; i < element.components.length; i++) {
                        componentPath = parentPath + '.' + element.components[i].position;
                        $scope.Map[componentPath] = element.components[i];
                        buildMap(componentPath, element.components[i].datatype);
                    }
                }
                // for (var i = 0; i < element.children.length; i++) {
                //     if (element.children[i].type === "group") {
                //         $scope.Map[path] = element.children[i];
                //         buildMap(path, element.children[i]);
                //     } else if (element.children[i].type === "segmentRef") {
                //         $scope.Map[path] = element.children[i];

                //     }
                // }
            };

            var processedMsg = processMessage(message);
            buildMap(processedMsg.structID, processedMsg);

            var getSegs = function(list, segLabel, resultList) {


                for (var i = 0; i < list.children.length; i++) {
                    if (list.children[i].type === "segmentRef") {
                        if (list.children[i].ref.label === segLabel) {
                            resultList.push(list.children[i]);
                        }

                    } else {
                        getSegs(list.children[i], segLabel, resultList);
                    }
                }
                return resultList;
            };




            var orderedList = $filter('orderBy')($scope.pcList, 'position');
            console.log(orderedList);
            for (var i = 0; i < orderedList.length; i++) {

                for (var j = 0; j < orderedList[i].children.length; j++) {
                    if (orderedList[i].children[j].pathExp) {
                        var resultList = [];
                        var label = orderedList[i].children[j].path.split('.');
                        var segList = getSegs(processedMsg, label[0], resultList);
                        for (var k = 0; k < segList.length; k++) {
                            if (orderedList[i].children[j].type === "segment") {
                                if (orderedList[i].children[j].attributes.usage) {
                                    segList[k].usage = orderedList[i].children[j].attributes.usage;
                                }
                                if (orderedList[i].children[j].attributes.min) {
                                    segList[k].min = orderedList[i].children[j].attributes.min;
                                }
                                if (orderedList[i].children[j].attributes.max) {
                                    segList[k].max = orderedList[i].children[j].attributes.max;
                                }
                            } else if (orderedList[i].children[j].type === "field") {

                                if (orderedList[i].children[j].attributes.usage) {
                                    segList[k].ref.fields[label[1] - 1].usage = orderedList[i].children[j].attributes.usage;
                                }
                                if (orderedList[i].children[j].attributes.min) {
                                    segList[k].ref.fields[label[1] - 1].min = orderedList[i].children[j].attributes.min;
                                }
                                if (orderedList[i].children[j].attributes.max) {
                                    segList[k].ref.fields[label[1] - 1].max = orderedList[i].children[j].attributes.max;
                                }
                                if (orderedList[i].children[j].attributes.confLength) {
                                    segList[k].ref.fields[label[1] - 1].confLength = orderedList[i].children[j].attributes.confLength;
                                }
                                if (orderedList[i].children[j].attributes.minLength) {
                                    segList[k].ref.fields[label[1] - 1].minLength = orderedList[i].children[j].attributes.minLength;
                                }
                                if (orderedList[i].children[j].attributes.maxLength) {
                                    segList[k].ref.fields[label[1] - 1].maxLength = orderedList[i].children[j].attributes.maxLength;
                                }
                                if (orderedList[i].children[j].attributes.minLength) {
                                    segList[k].ref.fields[label[1] - 1].minLength = orderedList[i].children[j].attributes.minLength;
                                }
                                if (orderedList[i].children[j].attributes.datatype) {
                                    segList[k].ref.fields[label[1] - 1].datatype = angular.copy($rootScope.datatypesMap[orderedList[i].children[j].attributes.datatype.id]);
                                }
                                if (orderedList[i].children[j].attributes.tables) {
                                    segList[k].ref.fields[label[1] - 1].tables = [];
                                    for (var k = 0; k < orderedList[i].children[j].attributes.tables.length; k++) {
                                        segList[k].ref.fields[label[1] - 1].tables.push(angular.copy($rootScope.tablesMap[orderedList[i].children[j].attributes.tables[k].id]));

                                    }
                                }
                            } else if (orderedList[i].children[j].type === "component") {

                                if (label.length === 3) {
                                    var comp = segList[k].ref.fields[label[1] - 1].datatype.components[label[2] - 1];
                                } else if (label.length === 4) {
                                    var comp = segList[k].ref.fields[label[1] - 1].datatype.components[label[2] - 1].datatype.components[label[3] - 1];
                                }
                                if (orderedList[i].children[j].attributes.usage) {
                                    comp.usage = orderedList[i].children[j].attributes.usage;
                                }
                                if (orderedList[i].children[j].attributes.min) {
                                    comp.min = orderedList[i].children[j].attributes.min;
                                }
                                if (orderedList[i].children[j].attributes.max) {
                                    comp.max = orderedList[i].children[j].attributes.max;
                                }
                                if (orderedList[i].children[j].attributes.confLength) {
                                    comp.confLength = orderedList[i].children[j].attributes.confLength;
                                }
                                if (orderedList[i].children[j].attributes.minLength) {
                                    comp.minLength = orderedList[i].children[j].attributes.minLength;
                                }
                                if (orderedList[i].children[j].attributes.maxLength) {
                                    comp.maxLength = orderedList[i].children[j].attributes.maxLength;
                                }
                                if (orderedList[i].children[j].attributes.minLength) {
                                    comp.minLength = orderedList[i].children[j].attributes.minLength;
                                }
                                if (orderedList[i].children[j].attributes.datatype) {
                                    comp.datatype = angular.copy($rootScope.datatypesMap[orderedList[i].children[j].attributes.datatype.id]);
                                }
                                if (orderedList[i].children[j].attributes.tables) {
                                    comp.tables = [];
                                    for (var k = 0; k < orderedList[i].children[j].attributes.tables.length; k++) {
                                        comp.tables.push(angular.copy($rootScope.tablesMap[orderedList[i].children[j].attributes.tables[k].id]));

                                    }
                                }

                            }
                        }



                        //getObjectFromPath("pathExp", orderedList[i].children[j].pathExp, processedMsg);
                    } else {
                        //getObjectFromPath("path", orderedList[i].children[j].path, processedMsg);


                        if (orderedList[i].children[j].attributes.usage) {
                            console.log($scope.Map[orderedList[i].children[j].path]);
                            $scope.Map[orderedList[i].children[j].path].usage = orderedList[i].children[j].attributes.usage;
                        }
                        if (orderedList[i].children[j].attributes.min) {
                            $scope.Map[orderedList[i].children[j].path].min = orderedList[i].children[j].attributes.min;
                        }
                        if (orderedList[i].children[j].attributes.max) {
                            $scope.Map[orderedList[i].children[j].path].max = orderedList[i].children[j].attributes.max;
                        }
                        if (orderedList[i].children[j].attributes.confLength) {
                            $scope.Map[orderedList[i].children[j].path].confLength = orderedList[i].children[j].attributes.confLength;
                        }
                        if (orderedList[i].children[j].attributes.minLength) {
                            $scope.Map[orderedList[i].children[j].path].minLength = orderedList[i].children[j].attributes.minLength;
                        }
                        if (orderedList[i].children[j].attributes.maxLength) {
                            $scope.Map[orderedList[i].children[j].path].maxLength = orderedList[i].children[j].attributes.maxLength;
                        }
                        if (orderedList[i].children[j].attributes.minLength) {
                            $scope.Map[orderedList[i].children[j].path].minLength = orderedList[i].children[j].attributes.minLength;
                        }
                        if (orderedList[i].children[j].attributes.datatype) {
                            $scope.Map[orderedList[i].children[j].path].datatype = angular.copy($rootScope.datatypesMap[orderedList[i].children[j].attributes.datatype.id]);
                        }
                        if (orderedList[i].children[j].attributes.tables) {
                            $scope.Map[orderedList[i].children[j].path].tables = [];
                            for (var k = 0; k < orderedList[i].children[j].attributes.tables.length; k++) {
                                $scope.Map[orderedList[i].children[j].path].tables.push(angular.copy($rootScope.tablesMap[orderedList[i].children[j].attributes.tables[k].id]));

                            }
                        }
                    }

                }
            }

            processedMsg.id = new ObjectId().toString();
            var profileComponents = [];
            for (var t = 0; t < $scope.pcList.length; t++) {
                if ($scope.pcList[t].appliedTo === null) {
                    $scope.pcList[t].appliedTo = [];
                }
                if (processedMsg.appliedPcs === null) {
                    processedMsg.appliedPcs = [];
                }
                processedMsg.appliedPcs.push({
                    id: $scope.pcList[t].id,
                    name: $scope.pcList[t].name,
                    pcDate: $scope.pcList[t].dateUpdated,
                    position: $scope.pcList[t].position
                });
                $scope.pcList[t].appliedTo.push({
                    id: processedMsg.id,
                    name: processedMsg.name,
                    pcDate: $scope.pcList[t].dateUpdated,
                    position: $scope.pcList[t].position
                });
                var pComponent = angular.copy($scope.pcList[t]);
                delete pComponent.position;
                profileComponents.push(pComponent);
            }


            CompositeMessageService.SaveGroupOrSegment(processedMsg.children).then(function(grpOrSeg) {

                CompositeMessageService.create(processedMsg, $rootScope.igdocument.id).then(function(compositeM) {
                    console.log("=================================");
                    console.log(profileComponents)
                    PcService.saveAll(profileComponents).then(function(pcs) {
                        $rootScope.igdocument.profile.compositeMessages.children.push(compositeM);
                        $modalInstance.close(compositeM);
                    });



                });
            });


        };

        $scope.cancel = function() {
            $modalInstance.dismiss('cancel');
        };

    });

angular.module('igl').controller('CustomExportCtrl', function($scope, $modalInstance, $http, IgDocumentService, $rootScope) {
    $scope.selectedType = {};
    $scope.exportType = [{
        type: "XML",
        layout: []
    }, {
        type: "Word",
        layout: ["Compact", "Verbose"]
    }, {
        type: "HTML",
        layout: ["Compact", "Verbose"]
    }];

    $scope.selectedLayout = {};


    $scope.ok = function() {
        if ($scope.selectedType.selected) {
            if ($scope.selectedType.selected === "XML") {
                $scope.exportAs($scope.selectedType.selected);
            } else {
                if ($scope.selectedLayout.selected) {
                    $scope.exportAsWithLayout($scope.selectedType.selected, $scope.selectedLayout.selected);
                } else {
                    $scope.exportAs($scope.selectedType.selected);
                }
            }
        }
        $modalInstance.close();
    };
    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});
'use strict';

angular.module('igl').controller('IssueCtrl', ['$scope', '$resource',
    function ($scope, $resource) {
        var Issue = $resource('api/sooa/issues/:id');

        $scope.clearIssue = function() {
            $scope.issue.title = '';
            $scope.issue.description = '';
            $scope.issue.email = '';
        };

        $scope.submitIssue = function() {
            var issueToReport = new Issue($scope.issue);
            issueToReport.$save(function() {
                if ( issueToReport.text === '') {
                    $scope.clearIssue();
                }
            });
        };
    }
]);

'use strict';

angular.module('igl').controller('MainCtrl', ['$document', '$scope', '$rootScope', 'i18n', '$location', 'userInfoService', '$modal', 'Restangular', '$filter', 'base64', '$http', 'Idle', 'IdleService', 'AutoSaveService', 'StorageService', 'ViewSettings', 'DatatypeService', 'SegmentService', 'MessageService', 'ElementUtils', 'SectionSvc','VersionAndUseService','$q','DatatypeLibrarySvc','CloneDeleteSvc'
,'TableService','TableLibrarySvc', function($document, $scope, $rootScope, i18n, $location, userInfoService, $modal, Restangular, $filter, base64, $http, Idle, IdleService, AutoSaveService, StorageService, ViewSettings, DatatypeService, SegmentService, MessageService, ElementUtils, SectionSvc,VersionAndUseService,$q,DatatypeLibrarySvc,CloneDeleteSvc,TableService,TableLibrarySvc) {
        // This line fetches the info from the server if the user is currently
        // logged in.
        // If success, the app is updated according to the role.

        //     $(document).keydown(function(e) {
        //     var nodeName = e.target.nodeName.toLowerCase();

        //     if (e.which === 8) {
        //         if ((nodeName === 'input' && e.target.type === 'text') ||
        //             nodeName === 'textarea') {
        //             // do nothing
        //         } else {
        //             e.preventDefault();
        //         }
        //     }
        // });
		$rootScope.versionAndUseMap={};
        userInfoService.loadFromServer();
        $rootScope.loginDialog = null;

        $rootScope.csWidth = null;
        $rootScope.predWidth = null;
        $rootScope.tableWidth = null;
        $rootScope.commentWidth = null;
        $scope.viewSettings = ViewSettings;
        $rootScope.addedSegments = [];
        $rootScope.dateFormat= 'MM/dd/yyyy HH:mm';
        $scope.state = false;

        $scope.toggleState = function() {
            $scope.state = !$scope.state;
        };

        $scope.language = function() {
            return i18n.language;
        };

        $scope.setLanguage = function(lang) {
            i18n.setLanguage(lang);
        };

        $scope.activeWhen = function(value) {
            return value ? 'active' : '';
        };
        $scope.activeIfInList = function(value, pathsList) {
            var found = false;
            if (angular.isArray(pathsList) === false) {
                return '';
            }
            var i = 0;
            while ((i < pathsList.length) && (found === false)) {
                if (pathsList[i] === value) {
                    return 'active';
                }
                i++;
            }
            return '';
        };
        $rootScope.setCardinalities = function(obj) {
            if (obj.usage === 'R') {
                obj.min = 1;
            } else if (obj.usage === 'X' || obj.usage === 'BW') {
                obj.min = 0;
                obj.max = 0;
            } else if (obj.usage === 'O') {
                obj.min = 0;

            }

        };
        $scope.path = function() {
            return $location.url();
        };
        
        $scope.login = function() {
            // ////console.log("in login");
            $scope.$emit('event:loginRequest', $scope.username, $scope.password);
        };

        $scope.loginReq = function() {
            // ////console.log("in loginReq");
            if ($rootScope.loginMessage()) {
                $rootScope.loginMessage().text = "";
                $rootScope.loginMessage().show = false;
            }
            $scope.$emit('event:loginRequired');
        };

        $scope.logout = function() {
            if ($rootScope.igdocument && $rootScope.igdocument != null && $rootScope.hasChanges()) {
                var modalInstance = $modal.open({
                    templateUrl: 'ConfirmLogout.html',
                    controller: 'ConfirmLogoutCtrl'
                });
                modalInstance.result.then(function() {
                    $scope.execLogout();
                }, function() {});
            } else {
                $scope.execLogout();
            }
        };

        $scope.execLogout = function() {
            userInfoService.setCurrentUser(null);
            $scope.username = $scope.password = null;
            $scope.$emit('event:logoutRequest');
            StorageService.remove(StorageService.IG_DOCUMENT);
            $rootScope.initMaps();
            $rootScope.igdocument = null;
            AutoSaveService.stop();
            if ($location.path() === '/compare') {
                $location.url('/compare');
            } else {
                $location.url('/ig');
            }
        };
        
        $scope.cancel = function() {
            $scope.$emit('event:loginCancel');
        };

        $scope.isAuthenticated = function() {
            return userInfoService.isAuthenticated();
        };

        $scope.isPending = function() {
            return userInfoService.isPending();
        };


        $scope.isSupervisor = function() {
            return userInfoService.isSupervisor();
        };

        $scope.isVendor = function() {
            return userInfoService.isAuthorizedVendor();
        };

        $scope.isAuthor = function() {
            return userInfoService.isAuthor();
        };

        $scope.isCustomer = function() {
            return userInfoService.isCustomer();
        };

        $scope.isAdmin = function() {
            return userInfoService.isAdmin();
        };


        $scope.getAccountID = function(accountId) {
            return userInfoService.getAccountID();
        };
        

        $scope.getRoleAsString = function() {
            if ($scope.isAuthor() === true) {
                return 'author';
            }
            if ($scope.isSupervisor() === true) {
                return 'Supervisor';
            }
            if ($scope.isAdmin() === true) {
                return 'Admin';
            }
            return 'undefined';
        };

        $scope.getUsername = function() {
            if (userInfoService.isAuthenticated() === true) {
                return userInfoService.getUsername();
            }
            return '';
        };

        $rootScope.showLoginDialog = function(username, password) {

            if ($rootScope.loginDialog && $rootScope.loginDialog != null && $rootScope.loginDialog.opened) {
                $rootScope.loginDialog.dismiss('cancel');
            }

            $rootScope.loginDialog = $modal.open({
                backdrop: 'static',
                keyboard: 'false',
                controller: 'LoginCtrl',
                size: 'lg',
                templateUrl: 'views/account/login.html',
                resolve: {
                    user: function() {
                        return { username: $scope.username, password: $scope.password };
                    }
                }
            });

            $rootScope.loginDialog.result.then(function(result) {
                if (result) {
                    $scope.username = result.username;
                    $scope.password = result.password;
                    $scope.login();
                } else {
                    $scope.cancel();
                }
            });
        };

        $rootScope.started = false;

        Idle.watch();

        $rootScope.$on('IdleStart', function() {
            closeModals();
            $rootScope.warning = $modal.open({
                templateUrl: 'warning-dialog.html',
                windowClass: 'modal-danger'
            });
        });

        $rootScope.$on('IdleEnd', function() {
            closeModals();
        });

        $rootScope.$on('IdleTimeout', function() {
            closeModals();
            if ($scope.isAuthenticated()) {
                if ($rootScope.igdocument && $rootScope.igdocument != null && $rootScope.hasChanges()) {
                    $rootScope.$emit('event:saveAndExecLogout');
                } else {
                    $rootScope.$emit('event:execLogout');
                }
            }
            $rootScope.timedout = $modal.open({
                templateUrl: 'timedout-dialog.html',
                windowClass: 'modal-danger'
            });
        });

        $scope.$on('Keepalive', function() {
            if ($scope.isAuthenticated()) {
                IdleService.keepAlive();
            }
        });

        $rootScope.$on('event:execLogout', function() {
            $scope.execLogout();
        });

        function closeModals() {
            if ($rootScope.warning) {
                $rootScope.warning.close();
                $rootScope.warning = null;
            }

            if ($rootScope.timedout) {
                $rootScope.timedout.close();
                $rootScope.timedout = null;
            }
        };

        $rootScope.start = function() {
            closeModals();
            Idle.watch();
            $rootScope.started = true;
        };

        $rootScope.stop = function() {
            closeModals();
            Idle.unwatch();
            $rootScope.started = false;

        };
        $rootScope.setCardinalities = function(obj) {
            if (obj.usage === 'R') {
                obj.min = 1;
            } else if (obj.usage === 'X' || obj.usage === 'BW') {
                obj.min = 0;
                obj.max = 0;
            } else if (obj.usage === 'O') {
                obj.min = 0;

            }

        };


        $scope.checkForIE = function() {
            var BrowserDetect = {
                init: function() {
                    this.browser = this.searchString(this.dataBrowser) || 'An unknown browser';
                    this.version = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || 'an unknown version';
                    this.OS = this.searchString(this.dataOS) || 'an unknown OS';
                },
                searchString: function(data) {
                    for (var i = 0; i < data.length; i++) {
                        var dataString = data[i].string;
                        var dataProp = data[i].prop;
                        this.versionSearchString = data[i].versionSearch || data[i].identity;
                        if (dataString) {
                            if (dataString.indexOf(data[i].subString) !== -1) {
                                return data[i].identity;
                            }
                        } else if (dataProp) {
                            return data[i].identity;
                        }
                    }
                },
                searchVersion: function(dataString) {
                    var index = dataString.indexOf(this.versionSearchString);
                    if (index === -1) {
                        return;
                    }
                    return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
                },
                dataBrowser: [{
                    string: navigator.userAgent,
                    subString: 'Chrome',
                    identity: 'Chrome'
                }, {
                    string: navigator.userAgent,
                    subString: 'OmniWeb',
                    versionSearch: 'OmniWeb/',
                    identity: 'OmniWeb'
                }, {
                    string: navigator.vendor,
                    subString: 'Apple',
                    identity: 'Safari',
                    versionSearch: 'Version'
                }, {
                    prop: window.opera,
                    identity: 'Opera',
                    versionSearch: 'Version'
                }, {
                    string: navigator.vendor,
                    subString: 'iCab',
                    identity: 'iCab'
                }, {
                    string: navigator.vendor,
                    subString: 'KDE',
                    identity: 'Konqueror'
                }, {
                    string: navigator.userAgent,
                    subString: 'Firefox',
                    identity: 'Firefox'
                }, {
                    string: navigator.vendor,
                    subString: 'Camino',
                    identity: 'Camino'
                }, { // for newer Netscapes (6+)
                    string: navigator.userAgent,
                    subString: 'Netscape',
                    identity: 'Netscape'
                }, {
                    string: navigator.userAgent,
                    subString: 'MSIE',
                    identity: 'Explorer',
                    versionSearch: 'MSIE'
                }, {
                    string: navigator.userAgent,
                    subString: 'Gecko',
                    identity: 'Mozilla',
                    versionSearch: 'rv'
                }, { // for older Netscapes (4-)
                    string: navigator.userAgent,
                    subString: 'Mozilla',
                    identity: 'Netscape',
                    versionSearch: 'Mozilla'
                }],
                dataOS: [{
                    string: navigator.platform,
                    subString: 'Win',
                    identity: 'Windows'
                }, {
                    string: navigator.platform,
                    subString: 'Mac',
                    identity: 'Mac'
                }, {
                    string: navigator.userAgent,
                    subString: 'iPhone',
                    identity: 'iPhone/iPod'
                }, {
                    string: navigator.platform,
                    subString: 'Linux',
                    identity: 'Linux'
                }]

            };
            BrowserDetect.init();

            if (BrowserDetect.browser === 'Explorer') {
                var title = 'You are using Internet Explorer';
                var msg = 'This site is not yet optimized with Internet Explorer. For the best user experience, please use Chrome, Firefox or Safari. Thank you for your patience.';
                var btns = [
                    { result: 'ok', label: 'OK', cssClass: 'btn' }
                ];

                // $dialog.messageBox(title, msg, btns).open();


            }
        };

 
        $rootScope.readonly = false;
        $rootScope.igdocument = null; // current igdocument
        $rootScope.message = null; // current message
        $rootScope.datatype = null; // current datatype

        $rootScope.pages = ['list', 'edit', 'read'];
        $rootScope.context = { page: $rootScope.pages[0] };
        $rootScope.messagesMap = {}; // Map for Message;key:id, value:object
        $rootScope.segmentsMap = {}; // Map for Segment;key:id, value:object
        $rootScope.datatypesMap = {}; // Map for Datatype; key:id, value:object
        $rootScope.tablesMap = {}; // Map for tables; key:id, value:object
        $rootScope.segments = []; // list of segments of the selected messages
        $rootScope.datatypes = []; // list of datatypes of the selected messages
        $rootScope.segmentPredicates = []; // list of segment level predicates of
        // the selected messages
        $rootScope.segmentConformanceStatements = []; // list of segment level
        // Conformance Statements of
        // the selected messages
        $rootScope.datatypePredicates = []; // list of segment level predicates of
        // the selected messages
        $rootScope.datatypeConformanceStatements = []; // list of segment level
        // Conformance Statements of
        // the selected messages
        $rootScope.tables = []; // list of tables of the selected messages
        $rootScope.postfixCloneTable = 'CA';
        $rootScope.newCodeFakeId = 0;
        $rootScope.newTableFakeId = 0;
        $rootScope.newPredicateFakeId = 0;
        $rootScope.newConformanceStatementFakeId = 0;
        $rootScope.segment = null;
        $rootScope.config = null;
        $rootScope.messagesData = [];
        $rootScope.messages = []; // list of messages
        $rootScope.customIgs = [];
        $rootScope.preloadedIgs = [];
        $rootScope.changes = {};
        $rootScope.generalInfo = { type: null, 'message': null };
        $rootScope.references = []; // collection of element referencing a datatype
        $rootScope.tmpReferences = [];
        // to delete
        $rootScope.section = {};
        $rootScope.conformanceStatementIdList = [];
        $rootScope.parentsMap = {};
        $rootScope.igChanged = false;


        $rootScope.messageTree = null;

        $scope.scrollbarWidth = 0;


        // TODO: remove
        $rootScope.selectIGDocumentTab = function(value) {
            // $rootScope.igdocumentTabs[0] = false;
            // $rootScope.igdocumentTabs[1] = false;
            // $rootScope.igdocumentTabs[2] = false;
            // $rootScope.igdocumentTabs[3] = false;
            // $rootScope.igdocumentTabs[4] = false;
            // $rootScope.igdocumentTabs[5] = false;
            // $rootScope.igdocumentTabs[value] = true;
        };

        $scope.getScrollbarWidth = function() {
            if ($scope.scrollbarWidth == 0) {
                var outer = document.createElement("div");
                outer.style.visibility = "hidden";
                outer.style.width = "100px";
                outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

                document.body.appendChild(outer);

                var widthNoScroll = outer.offsetWidth;
                // force scrollbars
                outer.style.overflow = "scroll";

                // add innerdiv
                var inner = document.createElement("div");
                inner.style.width = "100%";
                outer.appendChild(inner);

                var widthWithScroll = inner.offsetWidth;

                // remove divs
                outer.parentNode.removeChild(outer);

                $scope.scrollbarWidth = widthNoScroll - widthWithScroll;
            }

            return $scope.scrollbarWidth;
        };
        $rootScope.initMaps = function() {
            $rootScope.segment = null;
            $rootScope.datatype = null;
            $rootScope.message = null;
            $rootScope.table = null;
            $rootScope.codeSystems = [];
            $rootScope.messagesMap = {};
            $rootScope.segmentsMap = {};
            $rootScope.datatypesMap = {};
            $rootScope.tablesMap = {};
            $rootScope.segments = [];
            $rootScope.tables = [];
            $rootScope.segmentPredicates = [];
            $rootScope.segmentConformanceStatements = [];
            $rootScope.datatypePredicates = [];
            $rootScope.datatypeConformanceStatements = [];
            $rootScope.datatypes = [];
            $rootScope.messages = [];
            $rootScope.messagesData = [];
            $rootScope.newCodeFakeId = 0;
            $rootScope.newTableFakeId = 0;
            $rootScope.newPredicateFakeId = 0;
            $rootScope.newConformanceStatementFakeId = 0;
            $rootScope.clearChanges();
            $rootScope.parentsMap = [];
            $rootScope.conformanceStatementIdList = [];

            $rootScope.messageTree = null;
        };

        $rootScope.$watch(function() {
            return $location.path();
        }, function(newLocation, oldLocation) {
            $rootScope.setActive(newLocation);
        });
        
        $rootScope.isPublishedMaster= function(dtLink){
        	DatatypeService.getOneDatatype(dtLink.id).then(function(datatype){
        		console.log("called")
        		return datatype.status=="PUBLISHED"&& datatype.scope=="MASTER";
        	});
        }

        $rootScope.api = function(value) {
            return value;
        };


        $rootScope.isActive = function(path) {
            return path === $rootScope.activePath;
        };

        $rootScope.setActive = function(path) {
            if (path === '' || path === '/') {
                $location.path('/home');
            } else {
                $rootScope.activePath = path;
            }
        };

        $rootScope.clearChanges = function(path) {
            // $rootScope.changes = {};
            $rootScope.igChanged = false;
        };

        $rootScope.hasChanges = function() {
            // return Object.getOwnPropertyNames($rootScope.changes).length !== 0;
            return $rootScope.igChanged;
        };

        $rootScope.recordChanged = function() {
            $rootScope.igChanged = true;
        };


        $rootScope.recordChange = function(object, changeType) {
            // var type = object.type;


            // if($rootScope.changes[type] === undefined){
            // $rootScope.changes[type] = {};
            // }

            // if($rootScope.changes[type][object.id] === undefined){
            // $rootScope.changes[type][object.id] = {};
            // }

            // if(changeType === "datatype"){
            // $rootScope.changes[type][object.id][changeType] = object[changeType].id;
            // }else{
            // $rootScope.changes[type][object.id][changeType] = object[changeType];
            // }

            // ////console.log("Change is " + $rootScope.changes[type][object.id][changeType]);
            $rootScope.recordChanged();
        };
        $rootScope.addHL7Table = function(selectedTableLibary, hl7Version) {
            var modalInstance = $modal.open({
                templateUrl: 'AddHL7TableOpenCtrl.html',
                controller: 'AddHL7TableOpenCtrl',
                windowClass: 'conformance-profiles-modal',
                resolve: {
                    selectedTableLibary: function() {
                        return selectedTableLibary;
                    },
                    hl7Version: function() {
                        return hl7Version;
                    }
                }
            });
            modalInstance.result.then(function() {}, function() {});
        };

        $rootScope.recordChange2 = function(type, id, attr, value) {
            // if($rootScope.changes[type] === undefined){
            // $rootScope.changes[type] = {};
            // }
            // if($rootScope.changes[type][id] === undefined){
            // $rootScope.changes[type][id] = {};
            // }
            // if(attr != null) {
            // $rootScope.changes[type][id][attr] = value;
            // }else {
            // $rootScope.changes[type][id] = value;
            // }
            $rootScope.recordChanged();
        };

        $rootScope.recordChangeForEdit = function(object, changeType) {
            // var type = object.type;

            // if($rootScope.changes[type] === undefined){
            // $rootScope.changes[type] = {};
            // }

            // if($rootScope.changes[type]['edit'] === undefined){
            // $rootScope.changes[type]['edit'] = {};
            // }

            // if($rootScope.changes[type]['edit'][object.id] === undefined){
            // $rootScope.changes[type]['edit'][object.id] = {};
            // }
            // $rootScope.changes[type]['edit'][object.id][changeType] = object[changeType];
            $rootScope.recordChanged();
        };

        $rootScope.recordChangeForEdit2 = function(type, command, id, valueType, value) {
            // var obj = $rootScope.findObjectInChanges(type, "add", id);
            // if (obj === undefined) { // not a new object
            // if ($rootScope.changes[type] === undefined) {
            // $rootScope.changes[type] = {};
            // }
            // if ($rootScope.changes[type][command] === undefined) {
            // $rootScope.changes[type][command] = [];
            // }
            // if (valueType !== type) {
            // var obj = $rootScope.findObjectInChanges(type, command, id);
            // if (obj === undefined) {
            // obj = {id: id};
            // $rootScope.changes[type][command].push(obj);
            // }
            // obj[valueType] = value;
            // } else {
            // $rootScope.changes[type][command].push(value);
            // }
            // }
            $rootScope.recordChanged();
        };

        $rootScope.recordDelete = function(type, command, id) {
            //            if (id < 0) { // new object
            //                $rootScope.removeObjectFromChanges(type, "add", id);
            //            } else {
            //                $rootScope.removeObjectFromChanges(type, "edit", id);
            // if ($rootScope.changes[type] === undefined) {
            // $rootScope.changes[type] = {};
            // }
            // if ($rootScope.changes[type][command] === undefined) {
            // $rootScope.changes[type][command] = [];
            // }

            // if ($rootScope.changes[type]["delete"] === undefined) {
            // $rootScope.changes[type]["delete"] = [];
            // }

            // $rootScope.changes[type]["delete"].push({id:id});
            //$rootScope.recordChanged();
            //}

            // if($rootScope.changes[type]) { //clean the changes object
            // if ($rootScope.changes[type]["add"] && $rootScope.changes[type]["add"].length
            // === 0) {
            // delete $rootScope.changes[type]["add"];
            // }
            // if ($rootScope.changes[type]["edit"] &&
            // $rootScope.changes[type]["edit"].length === 0) {
            // delete $rootScope.changes[type]["edit"];
            // }

            // if (Object.getOwnPropertyNames($rootScope.changes[type]).length === 0) {
            // delete $rootScope.changes[type];
            // }
            // }
        };


        $rootScope.findObjectInChanges = function(type, command, id) {
            if ($rootScope.changes[type] !== undefined && $rootScope.changes[type][command] !== undefined) {
                for (var i = 0; i < $rootScope.changes[type][command].length; i++) {
                    var tmp = $rootScope.changes[type][command][i];
                    if (tmp.id === id) {
                        return tmp;
                    }
                }
            }
            return undefined;
        };
        $rootScope.redirectVS = function(valueSet) {
            TableService.getOne(valueSet.id).then(function(valueSet) {
                var modalInstance = $modal.open({
                    templateUrl: 'redirectCtrl.html',
                    controller: 'redirectCtrl',
                    size: 'md',
                    resolve: {
                        destination: function() {
                            return valueSet;
                        }
                    }



                });
                modalInstance.result.then(function() {
                	if(!$rootScope.SharingScope){
                		$rootScope.editTable(valueSet);
                	}
                	else{
                		$rootScope.hideToc=true;
                		$scope.hideToc=true;
                		$scope.editTable(valueSet);
                	}
                    
                });



            });
        };

        $rootScope.isNewObject = function(type, command, id) {
            if ($rootScope.changes[type] !== undefined && $rootScope.changes[type][command] !== undefined) {
                for (var i = 0; i < $rootScope.changes[type][command].length; i++) {
                    var tmp = $rootScope.changes[type][command][i];
                    if (tmp.id === id) {
                        return true;
                    }
                }
            }
            return false;
        };


        $rootScope.removeObjectFromChanges = function(type, command, id) {
            if ($rootScope.changes[type] !== undefined && $rootScope.changes[type][command] !== undefined) {
                for (var i = 0; i < $rootScope.changes[type][command].length; i++) {
                    var tmp = $rootScope.changes[type][command][i];
                    if (tmp.id === id) {
                        $rootScope.changes[type][command].splice(i, 1);
                    }
                }
            }
            return undefined;
        };


        Restangular.setBaseUrl('api/');
        // Restangular.setResponseExtractor(function(response, operation) {
        // return response.data;
        // });

        $rootScope.showError = function(error) {
            var modalInstance = $modal.open({
                templateUrl: 'ErrorDlgDetails.html',
                controller: 'ErrorDetailsCtrl',
                resolve: {
                    error: function() {
                        return error;
                    }
                }
            });
            modalInstance.result.then(function(error) {
                $rootScope.error = error;
            }, function() {});
        };


        $rootScope.apply = function(label) { // FIXME. weak check
            return label != undefined && label != null && (label.indexOf('_') !== -1 || label.indexOf('-') !== -1);
        };

        $rootScope.isFlavor = function(label) { // FIXME. weak check
            return label != undefined && label != null && (label.indexOf('_') !== -1 || label.indexOf('-') !== -1);
        };

        $rootScope.getDatatype = function(id) {
            //console.log("WAAAAAAAAAAA HEREREEEEEEEEEEEE");
            return $rootScope.datatypesMap && $rootScope.datatypesMap[id];
        };

        $rootScope.calNextCSID = function(ext, flavorName) {
            var prefix = '';
            if (ext != null && ext !== '') {
                prefix = ext;
            } else if (flavorName != null && flavorName !== '') {
                prefix = flavorName;
            } else {
                prefix = 'Default';
            }

            return $rootScope.createNewFlavorName(prefix);
        };

        $rootScope.usedSegsLink = [];
        $rootScope.usedDtLink = [];
        $rootScope.usedVsLink = [];
        $rootScope.fillMaps = function(element) {
            if (element != undefined && element != null) {
                if (element.type === "message") {
                    for (var i = 0; i < element.children.length; i++) {
                        $rootScope.fillMaps(element.children[i]);
                    }
                } else if (element.type === "segmentRef") {
                    $rootScope.usedSegsLink.push(element.ref);
                } else if (element.type === "group" && element.children) {
                    for (var i = 0; i < element.children.length; i++) {
                        $rootScope.fillMaps(element.children[i]);
                    }
                } else if (element.type === "segment") {
                    for (var i = 0; i < element.fields.length; i++) {
                        $rootScope.fillMaps(element.fields[i]);
                    }
                } else if (element.type === "field") {
                    $rootScope.usedDtLink.push(element.datatype);
                    for (var i = 0; i < element.tables.length; i++) {
                        $rootScope.usedVsLink.push(element.tables[i]);
                    }

                } else if (element.type === "component") {
                    $rootScope.usedDtLink.push(element.datatype);
                    for (var i = 0; i < element.tables.length; i++) {
                        $rootScope.usedVsLink.push(element.tables[i]);
                    }
                } else if (element.type === "datatype") {
                    for (var i = 0; i < element.components.length; i++) {
                        $rootScope.fillMaps(element.components[i]);
                    }
                }
            }
        };



        $rootScope.processElement = function(element, parent) {
            try {
                if (element != undefined && element != null) {
                    if (element.type === "message") {
                        element.children = $filter('orderBy')(element.children, 'position');
                        angular.forEach(element.conformanceStatements, function(cs) {
                            if ($rootScope.conformanceStatementIdList.indexOf(cs.constraintId) == -1) $rootScope.conformanceStatementIdList.push(cs.constraintId);
                        });
                        angular.forEach(element.children, function(segmentRefOrGroup) {
                            $rootScope.processElement(segmentRefOrGroup, element);
                        });
                    } else if (element.type === "group" && element.children) {
                        if (parent) {
                            $rootScope.parentsMap[element.id] = parent;
                        }
                        element.children = $filter('orderBy')(element.children, 'position');
                        angular.forEach(element.children, function(segmentRefOrGroup) {
                            $rootScope.processElement(segmentRefOrGroup, element);
                        });
                    } else if (element.type === "segmentRef") {
                        if (parent) {
                            $rootScope.parentsMap[element.id] = parent;
                        }
                        $rootScope.processElement($rootScope.segmentsMap[element.ref.id], element);
                    } else if (element.type === "segment") {
                        element.fields = $filter('orderBy')(element.fields, 'position');
                        angular.forEach(element.conformanceStatements, function(cs) {
                            if ($rootScope.conformanceStatementIdList.indexOf(cs.constraintId) == -1) $rootScope.conformanceStatementIdList.push(cs.constraintId);
                        });
                        angular.forEach(element.fields, function(field) {
                            $rootScope.processElement(field, element);
                        });
                    } else if (element.type === "field") {
                        $rootScope.parentsMap[element.id] = parent;
                        $rootScope.processElement($rootScope.datatypesMap[element.datatype.id], element);
                    } else if (element.type === "component") {
                        $rootScope.parentsMap[element.id] = parent;
                        $rootScope.processElement($rootScope.datatypesMap[element.datatype.id], element);
                    } else if (element.type === "datatype") {
                        element.components = $filter('orderBy')(element.components, 'position');
                        angular.forEach(element.conformanceStatements, function(cs) {
                            if ($rootScope.conformanceStatementIdList.indexOf(cs.constraintId) == -1) $rootScope.conformanceStatementIdList.push(cs.constraintId);
                        });
                        angular.forEach(element.components, function(component) {
                            $rootScope.processElement(component, element);
                        });
                    }
                }
            } catch (e) {
                throw e;
            }
        };


        $rootScope.filteredSegmentsList = [];
        $rootScope.filteredTablesList = [];
        $rootScope.filteredDatatypesList = [];
        $rootScope.selectedMessage = null;
        $rootScope.selectedSegment = null;

        $rootScope.processMessageTree = function(element, parent) {


            try {
                if (element != undefined && element != null) {
                    if (element.type === "message") {
                        $rootScope.selectedMessage = element;
                        $rootScope.filteredSegmentsList = [];
                        $rootScope.filteredTablesList = [];
                        $rootScope.filteredDatatypesList = [];
                        var m = {};
                        m.children = [];
                        $rootScope.messageTree = m;

                        angular.forEach(element.children, function(segmentRefOrGroup) {
                            $rootScope.processMessageTree(segmentRefOrGroup, m);
                        });

                    } else if (element.type === "group" && element.children) {
                        var g = {};
                        g.path = element.position + "[1]";
                        g.locationPath = element.name.substr(element.name.lastIndexOf('.') + 1) + '[1]';
                        g.obj = element;
                        g.children = [];
                        if (parent.path) {
                            g.path = parent.path + "." + g.path;
                            g.locationPath = parent.locationPath + "." + g.locationPath;
                        }
                        parent.children.push(g);
                        angular.forEach(element.children, function(segmentRefOrGroup) {
                            $rootScope.processMessageTree(segmentRefOrGroup, g);
                        });
                    } else if (element.type === "segmentRef") {
                        var s = {};
                        s.path = element.position + "[1]";
                        s.locationPath = $rootScope.segmentsMap[element.ref.id].name + '[1]';
                        s.obj = element;
                        s.children = [];
                        if (parent.path) {
                            s.path = parent.path + "." + element.position + "[1]";
                            s.locationPath = parent.locationPath + "." + s.locationPath;
                        }

                        if ($rootScope.segmentsMap[s.obj.ref.id] == undefined) {
                            throw new Error("Cannot find Segment[id=" + s.obj.ref.id + ", name= " + s.obj.ref.name + "]");
                        }
                        s.obj.ref.ext = $rootScope.segmentsMap[s.obj.ref.id].ext;
                        s.obj.ref.label = $rootScope.getLabel(s.obj.ref.name, s.obj.ref.ext);
                        parent.children.push(s);

                        var ref = $rootScope.segmentsMap[element.ref.id];
                        $rootScope.processMessageTree(ref, s);

                    } else if (element.type === "segment") {
                        if (!parent) {
                            var s = {};
                            s.obj = element;
                            s.path = element.name;
                            s.locationPath = element.name;
                            s.children = [];
                            parent = s;
                        }

                        $rootScope.filteredSegmentsList.push(element);
                        $rootScope.filteredSegmentsList = _.uniq($rootScope.filteredSegmentsList);

                        angular.forEach(element.fields, function(field) {
                            $rootScope.processMessageTree(field, parent);
                        });
                    } else if (element.type === "field") {
                        var f = {};
                        f.obj = element;
                        f.path = parent.path + "." + element.position + "[1]";
                        f.locationPath = parent.locationPath + "." + element.position + "[1]";
                        f.children = [];
                        var d = $rootScope.datatypesMap[f.obj.datatype.id];
                        if (d === undefined) {
                            throw new Error("Cannot find Data Type[id=" + f.obj.datatype.id + ", name= " + f.obj.datatype.name + "]");
                        }
                        f.obj.datatype.ext = $rootScope.datatypesMap[f.obj.datatype.id].ext;
                        f.obj.datatype.label = $rootScope.getLabel(f.obj.datatype.name, f.obj.datatype.ext);
                        // for (var i = 0; i < f.obj.tables.length; i++) {
                        //     if($rootScope.tablesMap[f.obj.tables[i].id]){
                        //         f.obj.tables[i].bindingIdentifier=$rootScope.tablesMap[f.obj.tables[i].id].bindingIdentifier;
                        //     }
                        // };
                        parent.children.push(f);

                        $rootScope.filteredDatatypesList.push($rootScope.datatypesMap[element.datatype.id]);
                        $rootScope.filteredDatatypesList = _.uniq($rootScope.filteredDatatypesList);
                        if (element.tables && element.tables.length > 0) {
                            angular.forEach(element.tables, function(table) {
                                $rootScope.filteredTablesList.push($rootScope.tablesMap[table.id]);
                            });
                            // $rootScope.filteredTablesList.push($rootScope.tablesMap[element.table.id]);
                        }
                        $rootScope.filteredTablesList = _.uniq($rootScope.filteredTablesList);
                        $rootScope.processMessageTree($rootScope.datatypesMap[element.datatype.id], f);
                    } else if (element.type === "component") {
                        var c = {};

                        c.obj = element;
                        c.path = parent.path + "." + element.position + "[1]";
                        c.locationPath = parent.locationPath + "." + element.position + "[1]";
                        c.children = [];
                        var d = $rootScope.datatypesMap[c.obj.datatype.id];
                        if (d === undefined) {
                            throw new Error("Cannot find Data Type[id=" + c.obj.datatype.id + ", name= " + c.obj.datatype.name + "]");
                        }
                        c.obj.datatype.ext = d.ext;
                        c.obj.datatype.label = $rootScope.getLabel(c.obj.datatype.name, c.obj.datatype.ext);
                        parent.children.push(c);
                        $rootScope.filteredDatatypesList.push($rootScope.datatypesMap[element.datatype.id]);
                        $rootScope.filteredDatatypesList = _.uniq($rootScope.filteredDatatypesList);
                        if (element.tables && element.tables.length > 0) {
                            angular.forEach(element.tables, function(table) {
                                $rootScope.filteredTablesList.push($rootScope.tablesMap[table.id]);
                            });
                            //$rootScope.filteredTablesList.push($rootScope.tablesMap[element.table.id]);
                        }
                        $rootScope.filteredTablesList = _.uniq($rootScope.filteredTablesList);
                        $rootScope.processMessageTree($rootScope.datatypesMap[element.datatype.id], c);
                    } else if (element.type === "datatype") {
                        if (!parent) {
                            var d = {};
                            d.obj = element;
                            d.path = element.name;
                            d.locationPath = element.name;
                            d.children = [];
                            parent = d;
                        }
                        angular.forEach(element.components, function(component) {
                            $rootScope.processMessageTree(component, parent);
                        });
                    }
                }
            } catch (e) {
                throw e;
            }
        };

        $rootScope.processSegmentsTree = function(element, parent) {
            //console.log(element);

            try {
                if (element.type === "segment") {
                    $rootScope.selectedSegment = element;
                    $rootScope.filteredTablesList = [];
                    $rootScope.filteredDatatypesList = [];

                    if (!parent) {
                        var s = {};
                        s.obj = element;
                        s.path = element.name;
                        s.children = [];
                        parent = s;
                    }
                    element.fields = $filter('orderBy')(element.fields, 'position');

                    angular.forEach(element.fields, function(field) {
                        $rootScope.processSegmentsTree(field, parent);
                    });
                } else if (element.type === "field") {
                    var f = {};
                    f.obj = element;
                    f.path = parent.path + "." + element.position + "[1]";
                    f.children = [];
                    parent.children.push(f);
                    $rootScope.filteredDatatypesList.push($rootScope.datatypesMap[element.datatype.id]);
                    $rootScope.filteredDatatypesList = _.uniq($rootScope.filteredDatatypesList);
                    if (element.tables && element.tables.length > 0) {
                        angular.forEach(element.tables, function(table) {
                            $rootScope.filteredTablesList.push($rootScope.tablesMap[table.id]);
                        });
                        //$rootScope.filteredTablesList.push($rootScope.tablesMap[element.table.id]);
                    }
                    $rootScope.filteredTablesList = _.uniq($rootScope.filteredTablesList);
                    $rootScope.processSegmentsTree($rootScope.datatypesMap[element.datatype.id], f);
                } else if (element.type === "component") {
                    var c = {};
                    c.obj = element;
                    c.path = parent.path + "." + element.position + "[1]";
                    c.children = [];
                    parent.children.push(c);
                    $rootScope.filteredDatatypesList.push($rootScope.datatypesMap[element.datatype.id]);
                    $rootScope.filteredDatatypesList = _.uniq($rootScope.filteredDatatypesList);
                    if (element.tables && element.tables.length > 0) {
                        angular.forEach(element.tables, function(table) {
                            $rootScope.filteredTablesList.push($rootScope.tablesMap[table.id]);
                        });
                        //$rootScope.filteredTablesList.push($rootScope.tablesMap[element.table.id]);
                    }
                    $rootScope.filteredTablesList = _.uniq($rootScope.filteredTablesList);
                    ////console.log($rootScope.filteredTablesList);
                    ////console.log($rootScope.filteredTablesList);

                    $rootScope.processSegmentsTree($rootScope.datatypesMap[element.datatype.id], c);
                } else if (element.type === "datatype") {

                    if (!parent) {
                        var d = {};
                        d.obj = element;
                        d.path = element.name;
                        d.children = [];
                        parent = d;
                    }

                    angular.forEach(element.components, function(component) {
                        $rootScope.processSegmentsTree(component, parent);
                    });
                }

            } catch (e) {
                throw e;
            }
        };

        $rootScope.checkedDatatype = null;

        $rootScope.rebuildTreeFromDatatype = function(data) {
            $rootScope.checkedDatatype = data;
            $rootScope.filteredTablesList = [];
            $rootScope.processDatatypeTree(data, null);
        }

        $rootScope.processDatatypeTree = function(element, parent) {

            ////console.log(element);

            try {
                if (element.type === "datatype") {
                    if (!parent) {
                        var d = {};
                        d.obj = element;
                        d.path = element.name;
                        d.children = [];
                        parent = d;
                    }
                    ////console.log("IN Data TYPE ")

                    angular.forEach(element.components, function(component) {
                        $rootScope.processDatatypeTree(component, parent);
                    });
                } else if (element.type === "component") {
                    var c = {};
                    c.obj = element;
                    c.path = parent.path + "." + element.position + "[1]";
                    c.children = [];
                    parent.children.push(c);
                    $rootScope.filteredDatatypesList.push($rootScope.datatypesMap[element.datatype.id]);
                    $rootScope.filteredDatatypesList = _.uniq($rootScope.filteredDatatypesList);
                    if (element.tables && element.tables != null && element.tables.length > 0) {
                        angular.forEach(element.tables, function(table) {
                            $rootScope.filteredTablesList.push($rootScope.tablesMap[table.id]);
                        });
                        //$rootScope.filteredTablesList.push($rootScope.tablesMap[element.table.id]);
                    }
                    $rootScope.filteredTablesList = _.uniq($rootScope.filteredTablesList);
                    $rootScope.processDatatypeTree($rootScope.datatypesMap[element.datatype.id], c);
                }

            } catch (e) {
                throw e;
            }
        };

        $rootScope.createNewFlavorName = function(label) {
            if ($rootScope.igdocument != null) {
                if ($rootScope.igdocument.metaData["ext"] === null || $rootScope.igdocument.metaData["ext"] === '') {
                    return label + "_" + (Math.floor(Math.random() * 10000000) + 1);
                } else {
                    return label + "_" + $rootScope.igdocument.metaData["ext"] + "_" + (Math.floor(Math.random() * 10000000) + 1);
                }
            } else {
                return null;
            }
        };

        $rootScope.createNewExtension = function(ext) {
            if ($rootScope.igdocument != null) {
                var rand = (Math.floor(Math.random() * 10000000) + 1);
                if ($rootScope.igdocument.metaData["ext"] === null) {
                    return ext != null && ext != "" ? ext + "_" + rand : rand;
                } else {
                    return ext != null && ext != "" ? ext + "_" + $rootScope.igdocument.metaData["ext"] + "_" + rand + 1 : rand + 1;
                }
            } else {
                return null;
            }
        };

        $rootScope.isSubComponent = function(node) {
            node.type === 'component' && $rootScope.parentsMap[node.id] && $rootScope.parentsMap[node.id].type === 'component';
        };

        $rootScope.findDatatypeRefs = function(datatype, obj, path, target) {
            if (obj != null && obj != undefined) {
                if (angular.equals(obj.type, 'field')) {
                    if (obj.datatype.id === datatype.id) {
                        var found = angular.copy(obj);
                        found.path = path;
                        found.target = angular.copy(target);
                        found.datatypeLink = angular.copy(obj.datatype);
                        $rootScope.references.push(found);
                    }
                   // $rootScope.findDatatypeRefs(datatype, $rootScope.datatypesMap[obj.datatype.id], path, target);
                }
                
                
                else  if (angular.equals(obj.type, 'component')) {
                    if (obj.datatype.id === datatype.id) {
                        var found = angular.copy(obj);
                        found.path = path;
                        found.target = angular.copy(target);
                        found.datatypeLink = angular.copy(obj.datatype);
                        $rootScope.references.push(found);
                    }
                    $rootScope.findDatatypeRefs(datatype, $rootScope.datatypesMap[obj.datatype.id], path, target);
                }

                else if (angular.equals(obj.type, 'segment')) {
                    angular.forEach(obj.fields, function(field) {
                        $rootScope.findDatatypeRefs(datatype, field, path + "-" + field.position, target);
                    });
                } else if (angular.equals(obj.type, 'datatype')) {
                    if (obj.components != undefined && obj.components != null && obj.components.length > 0) {
                        angular.forEach(obj.components, function(component) {
                            $rootScope.findDatatypeRefs(datatype, component, path + "." + component.position, target);
                        });
                    }
                }
            }
        };
        $rootScope.findDatatypeRefsForMenu = function(datatype, obj, path, target) {
            if (obj != null && obj != undefined) {
                if (angular.equals(obj.type, 'field') || angular.equals(obj.type, 'component')) {
                    if (obj.datatype.id === datatype.id) {
                        var found = angular.copy(obj);
                        found.path = path;
                        found.target = angular.copy(target);
                        found.datatypeLink = angular.copy(obj.datatype);
                        $rootScope.referencesForMenu.push(found);
                    }
                    $rootScope.findDatatypeRefsForMenu(datatype, $rootScope.datatypesMap[obj.datatype.id], path, target);
                } else if (angular.equals(obj.type, 'segment')) {
                    angular.forEach(obj.fields, function(field) {
                        $rootScope.findDatatypeRefsForMenu(datatype, field, path + "-" + field.position, target);
                    });
                } else if (angular.equals(obj.type, 'datatype')) {
                    if (obj.components != undefined && obj.components != null && obj.components.length > 0) {
                        angular.forEach(obj.components, function(component) {
                            $rootScope.findDatatypeRefsForMenu(datatype, component, path + "." + component.position, target);
                        });
                    }
                }
            }
        };

            $rootScope.findTempDatatypeRefs = function(datatype, obj, path, target) {
            if (obj != null && obj != undefined) {
                if (angular.equals(obj.type, 'field') || angular.equals(obj.type, 'component')) {
                    if (obj.datatype.id === datatype.id) {
                        var found = angular.copy(obj);
                        found.path = path;
                        found.target = angular.copy(target);
                        found.datatypeLink = angular.copy(obj.datatype);
                        $rootScope.refsForDelete.push(found);
                    }
                    $rootScope.findTempDatatypeRefs(datatype, $rootScope.datatypesMap[obj.datatype.id], path, target);
                } else if (angular.equals(obj.type, 'segment')) {
                    angular.forEach(obj.fields, function(field) {
                        $rootScope.findTempDatatypeRefs(datatype, field, path + "-" + field.position, target);
                    });
                } else if (angular.equals(obj.type, 'datatype')) {
                    if (obj.components != undefined && obj.components != null && obj.components.length > 0) {
                        angular.forEach(obj.components, function(component) {
                            $rootScope.findTempDatatypeRefs(datatype, component, path + "." + component.position, target);
                        });
                    }
                }
            }
        };

        $rootScope.findSegmentRefs = function(segment, obj, path, positionPath, target) {
            if (obj != null && obj != undefined) {
                if (angular.equals(obj.type, 'message')) {
                    angular.forEach(obj.children, function(child) {
                        $rootScope.findSegmentRefs(segment, child, obj.name + '-' + obj.identifier, obj.name + '-' + obj.identifier, target);
                    });
                } else if (angular.equals(obj.type, 'group')){
                    angular.forEach(obj.children, function(child) {
                        var groupNames = obj.name.split(".");
                        var groupName = groupNames[groupNames.length - 1];
                        $rootScope.findSegmentRefs(segment, child, path + '.' + groupName, positionPath + '.' + obj.position, target);
                    });
                } else if (angular.equals(obj.type, 'segmentRef')) {
                    if (obj.ref.id === segment.id) {
                        var found = angular.copy(obj);
                        found.path = path + '.' + segment.name;
                        found.positionPath = positionPath + '.' + obj.position;
                        found.target = angular.copy(target);
                        found.segmentLink = angular.copy(obj.ref);
                        $rootScope.references.push(found);
                    }
                }
            }
        };
        
        $rootScope.findSegmentRefsForMenu = function(segment, obj, path, positionPath, target) {
            if (obj != null && obj != undefined) {
                if (angular.equals(obj.type, 'message')) {
                    angular.forEach(obj.children, function(child) {
                        $rootScope.findSegmentRefsForMenu(segment, child, obj.name + '-' + obj.identifier, obj.name + '-' + obj.identifier, target);
                    });
                } else if (angular.equals(obj.type, 'group')){
                    angular.forEach(obj.children, function(child) {
                        var groupNames = obj.name.split(".");
                        var groupName = groupNames[groupNames.length - 1];
                        $rootScope.findSegmentRefsForMenu(segment, child, path + '.' + groupName, positionPath + '.' + obj.position, target);
                    });
                } else if (angular.equals(obj.type, 'segmentRef')) {
                    if (obj.ref.id === segment.id) {
                        var found = angular.copy(obj);
                        found.path = path + '.' + segment.name;
                        found.positionPath = positionPath + '.' + obj.position;
                        found.target = angular.copy(target);
                        found.segmentLink = angular.copy(obj.ref);
                        $rootScope.referencesForMenu.push(found);
                    }
                }
            }
        };

        $rootScope.findTableRefs = function(table, obj, path, target) {
            if (obj != null && obj != undefined) {
                if (angular.equals(obj.type, 'field') || angular.equals(obj.type, 'component')) {
                    if (obj.tables != undefined && obj.tables.length > 0) {
                        angular.forEach(obj.tables, function(tableInside) {
                            if (tableInside.id === table.id) {
                                var found = angular.copy(obj);
                                found.path = path;
                                found.target = angular.copy(target);
                                found.tableLink = angular.copy(tableInside);
                                $rootScope.references.push(found);
                            }
                        });
                    }
                    // $rootScope.findTableRefs(table, $rootScope.datatypesMap[obj.datatype.id], path);
                } else if (angular.equals(obj.type, 'segment')) {
                    angular.forEach(obj.fields, function(field) {
                        $rootScope.findTableRefs(table, field, path + "-" + field.position, target);
                    });
                } else if (angular.equals(obj.type, 'datatype')) {
                    if (obj.components != undefined && obj.components != null && obj.components.length > 0) {
                        angular.forEach(obj.components, function(component) {
                            $rootScope.findTableRefs(table, component, path + "." + component.position, target);
                        });
                    }
                }
            }
        };

        $rootScope.findTableRefsForMenu = function(table, obj, path, target) {
            if (obj != null && obj != undefined) {
                if (angular.equals(obj.type, 'field') || angular.equals(obj.type, 'component')) {
                    if (obj.tables != undefined && obj.tables.length > 0) {
                        angular.forEach(obj.tables, function(tableInside) {
                            if (tableInside.id === table.id) {
                                var found = angular.copy(obj);
                                found.path = path;
                                found.target = angular.copy(target);
                                found.tableLink = angular.copy(tableInside);
                                $rootScope.referencesForMenu.push(found);
                            }
                        });
                    }
                    // $rootScope.findTableRefs(table, $rootScope.datatypesMap[obj.datatype.id], path);
                } else if (angular.equals(obj.type, 'segment')) {
                    angular.forEach(obj.fields, function(field) {
                        $rootScope.findTableRefsForMenu(table, field, path + "-" + field.position, target);
                    });
                } else if (angular.equals(obj.type, 'datatype')) {
                    if (obj.components != undefined && obj.components != null && obj.components.length > 0) {
                        angular.forEach(obj.components, function(component) {
                            $rootScope.findTableRefsForMenu(table, component, path + "." + component.position, target);
                        });
                    }
                }
            }
        };
        
        
        
        $rootScope.findTableRefsForDelete = function(table, obj, path, target) {
            if (obj != null && obj != undefined) {
                if (angular.equals(obj.type, 'field') || angular.equals(obj.type, 'component')) {
                    if (obj.tables != undefined && obj.tables.length > 0) {
                        angular.forEach(obj.tables, function(tableInside) {
                            if (tableInside.id === table.id) {
                                var found = angular.copy(obj);
                                found.path = path;
                                found.target = angular.copy(target);
                                found.tableLink = angular.copy(tableInside);
                                $rootScope.refsForDelete.push(found);
                            }
                        });
                    }
                    // $rootScope.findTableRefs(table, $rootScope.datatypesMap[obj.datatype.id], path);
                } else if (angular.equals(obj.type, 'segment')) {
                    angular.forEach(obj.fields, function(field) {
                        $rootScope.findTableRefsForDelete(table, field, path + "-" + field.position, target);
                    });
                } else if (angular.equals(obj.type, 'datatype')) {
                    if (obj.components != undefined && obj.components != null && obj.components.length > 0) {
                        angular.forEach(obj.components, function(component) {
                             $rootScope.findTableRefsForDelete(table, component, path + "." + component.position, target);
                        });
                    }
                }
            }
        };





        $rootScope.saveBindingForSegment = function() {
            var segmentBindingUpdateParameterList = [];

            for (var q = 0; q < $rootScope.references.length; q++) {
                var ref = $rootScope.references[q];
                if (ref.segmentLink.isChanged) {
                    ref.segmentLink.isNew = null;
                    ref.segmentLink.isChanged = null;
                    var segmentBindingUpdateParameter = {};
                    segmentBindingUpdateParameter.messageId = ref.target.id;
                    segmentBindingUpdateParameter.newSegmentLink = angular.copy(ref.segmentLink);
                    segmentBindingUpdateParameter.positionPath = ref.positionPath;
                    segmentBindingUpdateParameterList.push(segmentBindingUpdateParameter);

                    var message = angular.copy($rootScope.messagesMap[segmentBindingUpdateParameter.messageId]);
                    var paths = segmentBindingUpdateParameter.positionPath.split('.');
                    $rootScope.updateSegmentBinding(message.children, paths, segmentBindingUpdateParameter.newSegmentLink);

                    $rootScope.messagesMap[message.id] = message;
                    var oldMessage = _.find($rootScope.igdocument.profile.messages.children, function(msg) {
                        return msg.id == message.id;
                    });

                    var index = $rootScope.igdocument.profile.messages.children.indexOf(oldMessage);
                    if (index > -1) $rootScope.igdocument.profile.messages.children[index] = message;

                }
            }

            MessageService.updateSegmentBinding(segmentBindingUpdateParameterList).then(function(result) {}, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });

            $rootScope.references = [];
            angular.forEach($rootScope.igdocument.profile.messages.children, function(message) {
                $rootScope.findSegmentRefs($rootScope.segment, message, '', '', message);
            });

        };

        $rootScope.updateSegmentBinding = function (children, paths, newSegmentLink){
            var position = parseInt(paths[1]);
            var child = $rootScope.findChildByPosition(children, position);

            if(paths.length == 2) {
                if(child.type === "segmentRef"){
                    child.ref = newSegmentLink;
                }
            }else{
                $rootScope.updateSegmentBinding(child.children, paths.slice(1), newSegmentLink);
            }
        };

        $rootScope.findChildByPosition = function (children, position){
            for (var i = 0; i < children.length; i++) {
                if(children[i].position == position) return children[i];
            }
            return null;
        };

        $rootScope.saveBindingForDatatype = function() {
            var datatypeUpdateParameterList = [];
            var segmentUpdateParameterList = [];

            for (var q = 0; q < $rootScope.references.length; q++) {
                var ref = $rootScope.references[q];
                if (ref.datatypeLink.isNew) {
                    if (ref.type == 'component') {
                        var targetDatatype = angular.copy($rootScope.datatypesMap[ref.target.id]);
                        ref.datatypeLink.isNew = null;
                        ref.datatypeLink.isChanged = null;
                        var newDatatypeLink = angular.copy(ref.datatypeLink);
                        var targetComponent = angular.copy(ref);
                        targetComponent.target = null;
                        targetComponent.path = null;
                        targetComponent.datatypeLink = null;

                        var toBeUpdateComponent = _.find(targetDatatype.components, function(component) {
                            return component.position == targetComponent.position;
                        });
                        if (toBeUpdateComponent) toBeUpdateComponent.datatype = newDatatypeLink;
                        $rootScope.datatypesMap[targetDatatype.id] = targetDatatype;
                        var oldDatatype = _.find($rootScope.datatypes, function(dt) {
                            return dt.id == targetDatatype.id;
                        });
                        var index = $rootScope.datatypes.indexOf(oldDatatype);
                        if (index > -1) $rootScope.datatypes[index] = targetDatatype;

                        var datatypeUpdateParameter = {};
                        datatypeUpdateParameter.datatypeId = targetDatatype.id;
                        datatypeUpdateParameter.componentId = targetComponent.id;
                        datatypeUpdateParameter.datatypeLink = newDatatypeLink;
                        datatypeUpdateParameterList.push(datatypeUpdateParameter);
                    } else if (ref.type == 'field') {
                        var targetSegment = angular.copy($rootScope.segmentsMap[ref.target.id]);
                        ref.datatypeLink.isNew = null;
                        ref.datatypeLink.isChanged = null;
                        var newDatatypeLink = angular.copy(ref.datatypeLink);
                        var targetField = angular.copy(ref);
                        targetField.target = null;
                        targetField.path = null;
                        targetField.datatypeLink = null;

                        var toBeUpdateField = _.find(targetSegment.fields, function(field) {
                            return field.position == targetField.position;
                        });
                        if (toBeUpdateField) toBeUpdateField.datatype = newDatatypeLink;
                        $rootScope.segmentsMap[targetSegment.id] = targetSegment;
                        var oldSegment = _.find($rootScope.segments, function(seg) {
                            return seg.id == targetSegment.id;
                        });
                        var index = $rootScope.segments.indexOf(oldSegment);
                        if (index > -1) $rootScope.segments[index] = targetSegment;

                        var segmentUpdateParameter = {};
                        segmentUpdateParameter.segmentId = targetSegment.id;
                        segmentUpdateParameter.fieldId = targetField.id;
                        segmentUpdateParameter.datatypeLink = newDatatypeLink;
                        segmentUpdateParameterList.push(segmentUpdateParameter);
                    }
                } else if (ref.datatypeLink.isChanged) {
                    if (ref.type == 'component') {
                        var targetDatatype = angular.copy($rootScope.datatypesMap[ref.target.id]);
                        ref.datatypeLink.isNew = null;
                        ref.datatypeLink.isChanged = null;
                        var newDatatypeLink = angular.copy(ref.datatypeLink);
                        var targetComponent = angular.copy(ref);
                        targetComponent.target = null;
                        targetComponent.path = null;
                        targetComponent.datatypeLink = null;

                        var toBeUpdateComponent = _.find(targetDatatype.components, function(component) {
                            return component.position == targetComponent.position;
                        });
                        if (toBeUpdateComponent) {

                            if (toBeUpdateComponent.datatype.id == $rootScope.datatype.id) {
                                toBeUpdateComponent.datatype = newDatatypeLink;
                            }

                        }
                        $rootScope.datatypesMap[targetDatatype.id] = targetDatatype;
                        var oldDatatype = _.find($rootScope.datatypes, function(dt) {
                            return dt.id == targetDatatype.id;
                        });
                        var index = $rootScope.datatypes.indexOf(oldDatatype);
                        if (index > -1) $rootScope.datatypes[index] = targetDatatype;

                        var datatypeUpdateParameter = {};
                        datatypeUpdateParameter.datatypeId = targetDatatype.id;
                        datatypeUpdateParameter.componentId = targetComponent.id;
                        datatypeUpdateParameter.datatypeLink = newDatatypeLink;
                        datatypeUpdateParameter.key = $rootScope.table.id;
                        datatypeUpdateParameterList.push(datatypeUpdateParameter);
                    } else if (ref.type == 'field') {
                        var targetSegment = angular.copy($rootScope.segmentsMap[ref.target.id]);
                        ref.datatypeLink.isNew = null;
                        ref.datatypeLink.isChanged = null;
                        var newDatatypeLink = angular.copy(ref.datatypeLink);
                        var targetField = angular.copy(ref);
                        targetField.target = null;
                        targetField.path = null;
                        targetField.datatypeLink = null;

                        var toBeUpdateField = _.find(targetSegment.fields, function(field) {
                            return field.position == targetField.position;
                        });
                        if (toBeUpdateField) {
                            if (toBeUpdateField.datatype.id == $rootScope.datatype.id) {
                                toBeUpdateField.datatype = newDatatypeLink;
                            }

                        }
                        $rootScope.segmentsMap[targetSegment.id] = targetSegment;
                        var oldSegment = _.find($rootScope.segments, function(seg) {
                            return seg.id == targetSegment.id;
                        });
                        var index = $rootScope.segments.indexOf(oldSegment);
                        if (index > -1) $rootScope.segments[index] = targetSegment;
                        
                        var segmentUpdateParameter = {};
                        segmentUpdateParameter.segmentId = targetSegment.id;
                        segmentUpdateParameter.fieldId = targetField.id;
                        segmentUpdateParameter.datatypeLink = newDatatypeLink;
                        segmentUpdateParameter.key = $rootScope.datatype.id;
                        segmentUpdateParameterList.push(segmentUpdateParameter);
                    }
                }
                console.log("clearing");
                $rootScope.clearChanges();
            }

            SegmentService.updateDatatypeBinding(segmentUpdateParameterList).then(function(result) {}, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });

            DatatypeService.updateDatatypeBinding(datatypeUpdateParameterList).then(function(result) {}, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });

            $rootScope.references = [];
            angular.forEach($rootScope.segments, function(segment) {
                $rootScope.findDatatypeRefs($rootScope.datatype, segment, $rootScope.getSegmentLabel(segment), segment);
            });
            angular.forEach($rootScope.datatypes, function(dt) {
                $rootScope.findDatatypeRefs($rootScope.datatype, dt, $rootScope.getDatatypeLabel(dt), dt);
            });
        };

        $rootScope.replaceElement= function(source, dest){
            $rootScope.SegmentsToUpdate=[];
            $rootScope.datatypeToUpdate=[];
             var newLink = angular.fromJson({
                            id: dest.id,
                            name: dest.name,
                            ext: dest.ext
                        });
            var refs= angular.copy($rootScope.references);
            angular.forEach($rootScope.references, function(ref){
                if(ref.target.status!=="PUBLISHED"){
                if(ref.type=='field'){
                    console.log(ref.target);
                    var segment=angular.copy(ref.target);
                angular.forEach(ref.target.fields, function(field){
                    if(field.position==ref.position){
                        field.datatype.id=dest.id;
                    }
                });
                $rootScope.SegmentsToUpdate.push(ref.target);  
                
                }
                else if(ref.type=='component'){
                angular.forEach(ref.target.components, function(component){
                    if(component.position==ref.position){
                        component.datatype.id=dest.id;
                    }
                });
                  $rootScope.datatypeToUpdate.push(ref.target);  
                }
                }
                
                SegmentService.saves($rootScope.SegmentsToUpdate).then(function(segs){
                            angular.forEach(segs, function(seg){
                            SegmentService.merge($rootScope.segmentsMap[seg.id], seg);
                            
                        
                    });
                            DatatypeService.saves($rootScope.datatypeToUpdate).then(function(dts){
                            
                            angular.forEach(dts, function(dt){
                            DatatypeService.merge($rootScope.datatypesMap[dt.id], dt);
                                             });
                                                $rootScope.editDatatype(dest);

                                                CloneDeleteSvc.deleteDatatype(source);
                                           });
                    
                                  });
                         })
            //
        };

        


        $rootScope.addOneDatatypeById=function(id){
            $scope.selectedDatatypes=[];


        DatatypeService.getOneDatatype(id).then(function(datatype){

             $scope.selectedDatatypes.push(datatype);

                
	            $scope.selectFlv = [];
	            var newLinks = [];
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	   
	                    newLinks.push({
	                        id: $scope.selectedDatatypes[i].id,
	                        name: $scope.selectedDatatypes[i].name
	                    })
	                
	            }
	            $rootScope.usedDtLink = [];
	            $rootScope.usedVsLink = [];
	            for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                $rootScope.fillMaps($scope.selectedDatatypes[i]);
	            }
	            DatatypeService.saves($scope.selectFlv).then(function(result) {
	                for (var i = 0; i < result.length; i++) {
	                    newLinks.push({
	                        id: result[i].id,
	                        name: result[i].name,
	                        ext: result[i].ext
	                    })
	                }
	                DatatypeLibrarySvc.addChildren($rootScope.datatypeLibrary.id, newLinks).then(function(link) {
	                    for (var i = 0; i < newLinks.length; i++) {
	                        $rootScope.datatypeLibrary.children.splice(0, 0, newLinks[i]);
	                    }
	                    for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                        $rootScope.datatypes.splice(0, 0, $scope.selectedDatatypes[i]);
	                    }
	                    for (var i = 0; i < $scope.selectedDatatypes.length; i++) {
	                        $rootScope.datatypesMap[$scope.selectedDatatypes[i].id] = $scope.selectedDatatypes[i];
	                    }
	                    var usedDtId1 = _.map($rootScope.usedDtLink, function(num, key) {
	                        return num.id;
	                    });

	                    DatatypeService.get(usedDtId1).then(function(datatypes) {
	                        for (var j = 0; j < datatypes.length; j++) {
	                            if (!$rootScope.datatypesMap[datatypes[j].id]) {

	                                $rootScope.datatypesMap[datatypes[j].id] = datatypes[j];
	                                $rootScope.datatypes.push(datatypes[j]);
	                                //$rootScope.getDerived(datatypes[j]);
	                            }
	                        }

	                        var usedVsId = _.map($rootScope.usedVsLink, function(num, key) {
	                            return num.id;
	                        });
	                        console.log("$rootScope.usedVsLink");

	                        console.log($rootScope.usedVsLink);
	                        var newTablesLink = _.difference($rootScope.usedVsLink,$rootScope.tableLibrary.children);
	                        console.log(newTablesLink);

	                        TableLibrarySvc.addChildren($rootScope.tableLibrary.id, newTablesLink).then(function() {
	                          $rootScope.tableLibrary.children = _.union(newTablesLink, $rootScope.tableLibrary.children);

	                            TableService.get(usedVsId).then(function(tables) {
	                                for (var j = 0; j < tables.length; j++) {
	                                    if (!$rootScope.tablesMap[tables[j].id]) {
	                                        $rootScope.tablesMap[tables[j].id] = tables[j];
	                                        $rootScope.tables.push(tables[j]);

	                                    }
	                                }
	                            });
                              
	                        });
	                    });
	                    $rootScope.msg().text = "datatypeAdded";
	                    $rootScope.msg().type = "success";
	                    $rootScope.msg().show = true;
	                });

	            }, function(error) {
	                $rootScope.saving = false;
	                $rootScope.msg().text = error.data.text;
	                $rootScope.msg().type = error.data.type;
	                $rootScope.msg().show = true;
	            });

        });

	        
        };
        $rootScope.saveBindingForValueSet = function() {
            var datatypeUpdateParameterList = [];
            var segmentUpdateParameterList = [];

            for (var q = 0; q < $rootScope.references.length; q++) {
                var ref = $rootScope.references[q];
                if (ref.tableLink.isNew) {
                    if (ref.type == 'component') {
                        var targetDatatype = angular.copy($rootScope.datatypesMap[ref.target.id]);
                        ref.tableLink.isNew = null;
                        ref.tableLink.isChanged = null;
                        var newTableLink = angular.copy(ref.tableLink);
                        var targetComponent = angular.copy(ref);
                        targetComponent.target = null;
                        targetComponent.path = null;
                        targetComponent.tableLink = null;

                        var toBeUpdateComponent = _.find(targetDatatype.components, function(component) {
                            return component.position == targetComponent.position;
                        });
                        if (toBeUpdateComponent) toBeUpdateComponent.tables.push(newTableLink);
                        $rootScope.datatypesMap[targetDatatype.id] = targetDatatype;
                        var oldDatatype = _.find($rootScope.datatypes, function(dt) {
                            return dt.id == targetDatatype.id;
                        });
                        var index = $rootScope.datatypes.indexOf(oldDatatype);
                        if (index > -1) $rootScope.datatypes[index] = targetDatatype;

                        var datatypeUpdateParameter = {};
                        datatypeUpdateParameter.datatypeId = targetDatatype.id;
                        datatypeUpdateParameter.componentId = targetComponent.id;
                        datatypeUpdateParameter.tableLink = newTableLink;
                        datatypeUpdateParameterList.push(datatypeUpdateParameter);
                    } else if (ref.type == 'field') {
                        var targetSegment = angular.copy($rootScope.segmentsMap[ref.target.id]);
                        ref.tableLink.isNew = null;
                        ref.tableLink.isChanged = null;
                        var newTableLink = angular.copy(ref.tableLink);
                        var targetField = angular.copy(ref);
                        targetField.target = null;
                        targetField.path = null;
                        targetField.tableLink = null;

                        var toBeUpdateField = _.find(targetSegment.fields, function(field) {
                            return field.position == targetField.position;
                        });
                        if (toBeUpdateField) toBeUpdateField.tables.push(newTableLink);
                        $rootScope.segmentsMap[targetSegment.id] = targetSegment;
                        var oldSegment = _.find($rootScope.segments, function(seg) {
                            return seg.id == targetSegment.id;
                        });
                        var index = $rootScope.segments.indexOf(oldSegment);
                        if (index > -1) $rootScope.segments[index] = targetSegment;

                        var segmentUpdateParameter = {};
                        segmentUpdateParameter.segmentId = targetSegment.id;
                        segmentUpdateParameter.fieldId = targetField.id;
                        segmentUpdateParameter.tableLink = newTableLink;
                        segmentUpdateParameterList.push(segmentUpdateParameter);
                    }
                } else if (ref.tableLink.isChanged) {
                    if (ref.type == 'component') {
                        var targetDatatype = angular.copy($rootScope.datatypesMap[ref.target.id]);
                        ref.tableLink.isNew = null;
                        ref.tableLink.isChanged = null;
                        var newTableLink = angular.copy(ref.tableLink);
                        var targetComponent = angular.copy(ref);
                        targetComponent.target = null;
                        targetComponent.path = null;
                        targetComponent.tableLink = null;

                        var toBeUpdateComponent = _.find(targetDatatype.components, function(component) {
                            return component.position == targetComponent.position;
                        });
                        if (toBeUpdateComponent) {
                            for (var i = 0; i < toBeUpdateComponent.tables.length; i++) {
                                if (toBeUpdateComponent.tables[i].id == $rootScope.table.id) {
                                    toBeUpdateComponent.tables[i] = newTableLink;
                                }
                            }
                        }
                        $rootScope.datatypesMap[targetDatatype.id] = targetDatatype;
                        var oldDatatype = _.find($rootScope.datatypes, function(dt) {
                            return dt.id == targetDatatype.id;
                        });
                        var index = $rootScope.datatypes.indexOf(oldDatatype);
                        if (index > -1) $rootScope.datatypes[index] = targetDatatype;

                        var datatypeUpdateParameter = {};
                        datatypeUpdateParameter.datatypeId = targetDatatype.id;
                        datatypeUpdateParameter.componentId = targetComponent.id;
                        datatypeUpdateParameter.tableLink = newTableLink;
                        datatypeUpdateParameter.key = $rootScope.table.id;
                        datatypeUpdateParameterList.push(datatypeUpdateParameter);
                    } else if (ref.type == 'field') {
                        var targetSegment = angular.copy($rootScope.segmentsMap[ref.target.id]);
                        ref.tableLink.isNew = null;
                        ref.tableLink.isChanged = null;
                        var newTableLink = angular.copy(ref.tableLink);
                        var targetField = angular.copy(ref);
                        targetField.target = null;
                        targetField.path = null;
                        targetField.tableLink = null;

                        var toBeUpdateField = _.find(targetSegment.fields, function(field) {
                            return field.position == targetField.position;
                        });
                        if (toBeUpdateField) {
                            for (var i = 0; i < toBeUpdateField.tables.length; i++) {
                                if (toBeUpdateField.tables[i].id == $rootScope.table.id) {
                                    toBeUpdateField.tables[i] = newTableLink;
                                }
                            }
                        }
                        $rootScope.segmentsMap[targetSegment.id] = targetSegment;
                        var oldSegment = _.find($rootScope.segments, function(seg) {
                            return seg.id == targetSegment.id;
                        });
                        var index = $rootScope.segments.indexOf(oldSegment);
                        if (index > -1) $rootScope.segments[index] = targetSegment;

                        var segmentUpdateParameter = {};
                        segmentUpdateParameter.segmentId = targetSegment.id;
                        segmentUpdateParameter.fieldId = targetField.id;
                        segmentUpdateParameter.tableLink = newTableLink;
                        segmentUpdateParameter.key = $rootScope.table.id;
                        segmentUpdateParameterList.push(segmentUpdateParameter);
                    }
                }
            }

            SegmentService.updateTableBinding(segmentUpdateParameterList).then(function(result) {}, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });

            DatatypeService.updateTableBinding(datatypeUpdateParameterList).then(function(result) {}, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });

            $rootScope.references = [];
            angular.forEach($rootScope.segments, function(segment) {
                $rootScope.findTableRefs($rootScope.table, segment, $rootScope.getSegmentLabel(segment), segment);
            });
            angular.forEach($rootScope.datatypes, function(dt) {
                $rootScope.findTableRefs($rootScope.table, dt, $rootScope.getDatatypeLabel(dt), dt);
            });
            console.log("clearing");
            $rootScope.clearChanges();
        };

        $rootScope.genRegex = function(format) {
            if (format === 'YYYY') {
                return '([0-9]{4})(((0[1-9])|(1[0-2]))(((0[1-9])|([1-2][0-9])|(3[0-1]))((([0-1][0-9])|(2[0-3]))(([0-5][0-9])(([0-5][0-9])(\.[0-9]{1,4})?)?)?)?)?)?((\\+|\\-)[0-9]{4})?';
            } else if (format === 'YYYYMM') {
                return '([0-9]{4})((0[1-9])|(1[0-2]))(((0[1-9])|([1-2][0-9])|(3[0-1]))((([0-1][0-9])|(2[0-3]))(([0-5][0-9])(([0-5][0-9])(\.[0-9]{1,4})?)?)?)?)?((\\+|\\-)[0-9]{4})?';
            } else if (format === 'YYYYMMDD') {
                return '([0-9]{4})((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))((([0-1][0-9])|(2[0-3]))(([0-5][0-9])(([0-5][0-9])(\.[0-9]{1,4})?)?)?)?((\\+|\\-)[0-9]{4})?';
            } else if (format === 'YYYYMMDDhh') {
                return '([0-9]{4})((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))(([0-1][0-9])|(2[0-3]))(([0-5][0-9])(([0-5][0-9])(\.[0-9]{1,4})?)?)?((\\+|\\-)[0-9]{4})?';
            } else if (format === 'YYYYMMDDhhmm') {
                return '([0-9]{4})((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))(([0-1][0-9])|(2[0-3]))([0-5][0-9])(([0-5][0-9])(\.[0-9]{1,4})?)?((\\+|\\-)[0-9]{4})?';
            } else if (format === 'YYYYMMDDhhmmss') {
                return '([0-9]{4})((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))(([0-1][0-9])|(2[0-3]))([0-5][0-9])([0-5][0-9])(\.[0-9]{1,4})?((\\+|\\-)[0-9]{4})?';
            } else if (format === 'YYYYMMDDhhmmss.sss') {
                return '([0-9]{4})((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))(([0-1][0-9])|(2[0-3]))([0-5][0-9])([0-5][0-9])\.[0-9]{1,4}((\\+|\\-)[0-9]{4})?';
            } else if (format === 'YYYY+-ZZZZ') {
                return '([0-9]{4})(((0[1-9])|(1[0-2]))(((0[1-9])|([1-2][0-9])|(3[0-1]))((([0-1][0-9])|(2[0-3]))(([0-5][0-9])(([0-5][0-9])(\.[0-9]{1,4})?)?)?)?)?)?(\\+|\\-)[0-9]{4}';
            } else if (format === 'YYYYMM+-ZZZZ') {
                return '([0-9]{4})((0[1-9])|(1[0-2]))(((0[1-9])|([1-2][0-9])|(3[0-1]))((([0-1][0-9])|(2[0-3]))(([0-5][0-9])(([0-5][0-9])(\.[0-9]{1,4})?)?)?)?)?(\\+|\\-)[0-9]{4}';
            } else if (format === 'YYYYMMDD+-ZZZZ') {
                return '([0-9]{4})((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))((([0-1][0-9])|(2[0-3]))(([0-5][0-9])(([0-5][0-9])(\.[0-9]{1,4})?)?)?)?(\\+|\\-)[0-9]{4}';
            } else if (format === 'YYYYMMDDhh+-ZZZZ') {
                return '([0-9]{4})((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))(([0-1][0-9])|(2[0-3]))(([0-5][0-9])(([0-5][0-9])(\.[0-9]{1,4})?)?)?(\\+|\\-)[0-9]{4}';
            } else if (format === 'YYYYMMDDhhmm+-ZZZZ') {
                return '([0-9]{4})((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))(([0-1][0-9])|(2[0-3]))([0-5][0-9])(([0-5][0-9])(\.[0-9]{1,4})?)?(\\+|\\-)[0-9]{4}';
            } else if (format === 'YYYYMMDDhhmmss+-ZZZZ') {
                return '([0-9]{4})((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))(([0-1][0-9])|(2[0-3]))([0-5][0-9])([0-5][0-9])(\.[0-9]{1,4})?(\\+|\\-)[0-9]{4}';
            } else if (format === 'YYYYMMDDhhmmss.sss+-ZZZZ') {
                return '([0-9]{4})((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))(([0-1][0-9])|(2[0-3]))([0-5][0-9])([0-5][0-9])\.[0-9]{1,4}(\\+|\\-)[0-9]{4}';
            } else if (format === 'ISO-compliant OID') {
                return '[0-2](\\.(0|[1-9][0-9]*))*';
            } else if (format === 'Alphanumeric') {
                return '^[a-zA-Z0-9]*$';
            } else if (format === 'Positive Integer') {
                return '^[1-9]\d*$';
            }

            return format;
        };

        $rootScope.isAvailableDTForTable = function(dt) {
            if (dt != undefined) {
                if (dt.name === 'IS' || dt.name === 'ID' || dt.name === 'CWE' || dt.name === 'CNE' || dt.name === 'CE') return true;

                if (dt.components != undefined && dt.components.length > 0) return true;

            }
            return false;
        };

        $rootScope.validateNumber = function(event) {
            var key = window.event ? event.keyCode : event.which;
            if (event.keyCode == 8 || event.keyCode == 46 || event.keyCode == 37 || event.keyCode == 39) {
                return true;
            } else if (key < 48 || key > 57) {
                return false;
            } else return true;
        };


        $rootScope.displayLocationForDatatype = function(dt, constraintTarget) {
            var position = constraintTarget.substring(0, constraintTarget.indexOf('['));
            var component = _.find(dt.components, function(c) {
                return c.position == position;
            });
            if (component) return dt.name + "." + position + " (" + component.name + ")";
            return dt.name;
        };

        $rootScope.displayLocationForSegment = function(segment, constraintTarget) {
            var position = constraintTarget.substring(0, constraintTarget.indexOf('['));
            var field = _.find(segment.fields, function(f) {
                return f.position == position;
            });
            if (field) return segment.name + "-" + position + " (" + field.name + ")";
            return segment.name;
        };

        $rootScope.generateCompositeConformanceStatement = function(compositeType, firstConstraint, secondConstraint, constraints) {
            var cs = null;
            if (compositeType === 'AND' || compositeType === 'OR' || compositeType === 'XOR') {
                var firstConstraintAssertion = firstConstraint.assertion.replace("<Assertion>", "");
                firstConstraintAssertion = firstConstraintAssertion.replace("</Assertion>", "");
                var secondConstraintAssertion = secondConstraint.assertion.replace("<Assertion>", "");
                secondConstraintAssertion = secondConstraintAssertion.replace("</Assertion>", "");

                cs = {
                    id: new ObjectId().toString(),
                    constraintId: compositeType + '(' + firstConstraint.constraintId + ',' + secondConstraint.constraintId + ')',
                    description: '[' + firstConstraint.description + '] ' + compositeType + ' [' + secondConstraint.description + ']',
                    assertion: '<Assertion><' + compositeType + '>' + firstConstraintAssertion + secondConstraintAssertion + '</' + compositeType + '></Assertion>'
                };
            } else if(compositeType === 'IFTHEN'){
                var firstConstraintAssertion = firstConstraint.assertion.replace("<Assertion>", "");
                firstConstraintAssertion = firstConstraintAssertion.replace("</Assertion>", "");
                var secondConstraintAssertion = secondConstraint.assertion.replace("<Assertion>", "");
                secondConstraintAssertion = secondConstraintAssertion.replace("</Assertion>", "");

                cs = {
                    id: new ObjectId().toString(),
                    constraintId: compositeType + '(' + firstConstraint.constraintId + ',' + secondConstraint.constraintId + ')',
                    description: 'IF [' + firstConstraint.description + '] THEN [' + secondConstraint.description + ']',
                    assertion: '<Assertion><' + compositeType + '>' + firstConstraintAssertion + secondConstraintAssertion + '</' + compositeType + '></Assertion>'
                };
            } else if (compositeType === 'FORALL' || compositeType === 'EXIST') {
                var forALLExistId = compositeType;
                var forALLExistAssertion = '';
                var forALLExistDescription = compositeType;

                angular.forEach(constraints, function(c) {
                    forALLExistAssertion = forALLExistAssertion + c.assertion.replace("<Assertion>", "").replace("</Assertion>", "");
                    forALLExistDescription = forALLExistDescription + '[' + c.description + ']';
                    forALLExistId = forALLExistId + '(' + c.constraintId + ')';
                });

                cs = {
                    id: new ObjectId().toString(),
                    constraintId: forALLExistId,
                    description: forALLExistDescription,
                    assertion: '<Assertion><' + compositeType + '>' + forALLExistAssertion + '</' + compositeType + '></Assertion>'
                };
            }
            return cs;
        };



        $rootScope.generateCompositePredicate = function(compositeType, firstConstraint, secondConstraint, constraints) {
            var cp = null;
            if (compositeType === 'AND' || compositeType === 'OR' || compositeType === 'XOR') {
                var firstConstraintAssertion = firstConstraint.assertion.replace("<Condition>", "");
                firstConstraintAssertion = firstConstraintAssertion.replace("</Condition>", "");
                var secondConstraintAssertion = secondConstraint.assertion.replace("<Condition>", "");
                secondConstraintAssertion = secondConstraintAssertion.replace("</Condition>", "");

                cp = {
                    id: new ObjectId().toString(),
                    constraintId: compositeType + '(' + firstConstraint.constraintId + ',' + secondConstraint.constraintId + ')',
                    constraintTarget: firstConstraint.constraintTarget,
                    description: '[' + firstConstraint.description + '] ' + compositeType + ' [' + secondConstraint.description + ']',
                    trueUsage: '',
                    falseUsage: '',
                    assertion: '<Condition><' + compositeType + '>' + firstConstraintAssertion + secondConstraintAssertion + '</' + compositeType + '></Condition>'
                };
            } else if (compositeType === 'IFTHEN') {
                var firstConstraintAssertion = firstConstraint.assertion.replace("<Condition>", "");
                firstConstraintAssertion = firstConstraintAssertion.replace("</Condition>", "");
                var secondConstraintAssertion = secondConstraint.assertion.replace("<Condition>", "");
                secondConstraintAssertion = secondConstraintAssertion.replace("</Condition>", "");

                cp = {
                    id: new ObjectId().toString(),
                    constraintId: compositeType + '(' + firstConstraint.constraintId + ',' + secondConstraint.constraintId + ')',
                    constraintTarget: firstConstraint.constraintTarget,
                    description: 'IF [' + firstConstraint.description + '] THEN [' + secondConstraint.description + ']',
                    trueUsage: '',
                    falseUsage: '',
                    assertion: '<Condition><' + compositeType + '>' + firstConstraintAssertion + secondConstraintAssertion + '</' + compositeType + '></Condition>'
                };
            } else if (compositeType === 'FORALL' || compositeType === 'EXIST') {
                var forALLExistId = compositeType;
                var forALLExistAssertion = '';
                var forALLExistDescription = compositeType;
                var forALLExistConstraintTarget = '';

                angular.forEach(constraints, function(c) {
                    forALLExistAssertion = forALLExistAssertion + c.assertion.replace("<Condition>", "").replace("</Condition>", "");
                    forALLExistDescription = forALLExistDescription + '[' + c.description + ']';
                    forALLExistId = forALLExistId + '(' + c.constraintId + ')';
                    forALLExistConstraintTarget = c.constraintTarget;
                });

                cp = {
                    id: new ObjectId().toString(),
                    constraintId: forALLExistId,
                    constraintTarget: forALLExistConstraintTarget,
                    description: forALLExistDescription,
                    assertion: '<Condition><' + compositeType + '>' + forALLExistAssertion + '</' + compositeType + '></Condition>'
                };
            }
            return cp;
        };

        $rootScope.generateFreeTextConformanceStatement = function(newConstraint) {
            var cs = {
                id: new ObjectId().toString(),
                constraintId: newConstraint.constraintId,
                description: newConstraint.freeText,
                assertion: null
            };

            return cs;
        };

        $rootScope.generateConformanceStatement = function(newConstraint) {
            var cs = null;
            if (newConstraint.contraintType === 'valued') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: newConstraint.location_1 + ' ' + newConstraint.verb + ' ' + newConstraint.contraintType + '.',
                    assertion: '<Assertion><Presence Path=\"' + newConstraint.position_1 + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'a literal value') {
                if (newConstraint.value.indexOf("^") == -1) {
                    cs = {
                        id: new ObjectId().toString(),
                        constraintId: newConstraint.constraintId,
                        description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' \'' + newConstraint.value + '\'.',
                        assertion: '<Assertion><PlainText Path=\"' + newConstraint.position_1 + '\" Text=\"' + newConstraint.value + '\" IgnoreCase=\"' + newConstraint.ignoreCase + '\"/></Assertion>'
                    };
                } else {
                    console.log(newConstraint.value);
                    if(newConstraint.value =='^~\\&'){
                        cs = {
                            id: new ObjectId().toString(),
                            constraintId: newConstraint.constraintId,
                            description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' \'^~\\&amp;\'.',
                            assertion: '<Assertion><PlainText Path=\"' + newConstraint.position_1 + '\" Text=\"^~\\&amp;\" IgnoreCase=\"' + newConstraint.ignoreCase + '\"/></Assertion>'
                        };
                    }else {
                        var componetsList = newConstraint.value.split("^");
                        var assertionScript = "";
                        var componentPosition = 0;

                        angular.forEach(componetsList, function(componentValue) {
                            componentPosition = componentPosition + 1;
                            var script = '<PlainText Path=\"' + newConstraint.position_1 + "." + componentPosition + "[1]" + '\" Text=\"' + componentValue + '\" IgnoreCase="false"/>';
                            if (assertionScript === "") {
                                assertionScript = script;
                            } else {
                                assertionScript = "<AND>" + assertionScript + script + "</AND>";
                            }
                        });


                        cs = {
                            id: new ObjectId().toString(),
                            constraintId: newConstraint.constraintId,
                            description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' \'' + newConstraint.value + '\'.',
                            assertion: '<Assertion>' + assertionScript + '</Assertion>'
                        };
                    }
                }
            } else if (newConstraint.contraintType === 'one of list values') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' ' + newConstraint.contraintType + ': ' + newConstraint.value + '.',
                    assertion: '<Assertion><StringList Path=\"' + newConstraint.position_1 + '\" CSV=\"' + newConstraint.value + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'one of codes in ValueSet') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' ' + newConstraint.contraintType + ': ' + newConstraint.valueSetId + '.',
                    assertion: '<Assertion><ValueSet Path=\"' + newConstraint.position_1 + '\" ValueSetID=\"' + newConstraint.valueSetId + '\" BindingStrength=\"' + newConstraint.bindingStrength + '\" BindingLocation=\"' + newConstraint.bindingLocation + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'formatted value') {
                if (newConstraint.value === 'Regular expression') {
                    cs = {
                        id: new ObjectId().toString(),
                        constraintId: newConstraint.constraintId,
                        description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' formatted with \'' + newConstraint.value2 + '\'.',
                        assertion: '<Assertion><Format Path=\"' + newConstraint.position_1 + '\" Regex=\"' + newConstraint.value2 + '\"/></Assertion>'
                    };
                } else {
                    cs = {
                        id: new ObjectId().toString(),
                        constraintId: newConstraint.constraintId,
                        description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' formatted with \'' + newConstraint.value + '\'.',
                        assertion: '<Assertion><Format Path=\"' + newConstraint.position_1 + '\" Regex=\"' + $rootScope.genRegex(newConstraint.value) + '\"/></Assertion>'
                    };
                }
            } else if (newConstraint.contraintType === 'identical to another node') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' identical to the value of ' + newConstraint.location_2 + '.',
                    assertion: '<Assertion><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="EQ" Path2=\"' + newConstraint.position_2 + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'equal to another node') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' equal to the value of ' + newConstraint.location_2 + '.',
                    assertion: '<Assertion><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="EQ" Path2=\"' + newConstraint.position_2 + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'not-equal to another node') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' different with the value of ' + newConstraint.location_2 + '.',
                    assertion: '<Assertion><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="NE" Path2=\"' + newConstraint.position_2 + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'greater than another node') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' greater than the value of ' + newConstraint.location_2 + '.',
                    assertion: '<Assertion><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="GT" Path2=\"' + newConstraint.position_2 + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'equal to or greater than another node') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' equal to or greater than the value of ' + newConstraint.location_2 + '.',
                    assertion: '<Assertion><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="GE" Path2=\"' + newConstraint.position_2 + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'less than another node') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' less than the value of ' + newConstraint.location_2 + '.',
                    assertion: '<Assertion><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="LT" Path2=\"' + newConstraint.position_2 + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'equal to or less than another node') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' equal to or less than the value of ' + newConstraint.location_2 + '.',
                    assertion: '<Assertion><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="LE" Path2=\"' + newConstraint.position_2 + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'equal to') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' equal to ' + newConstraint.value + '.',
                    assertion: '<Assertion><SimpleValue Path=\"' + newConstraint.position_1 + '\" Operator="EQ" Value=\"' + newConstraint.value + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'not-equal to') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' different with ' + newConstraint.value + '.',
                    assertion: '<Assertion><SimpleValue Path=\"' + newConstraint.position_1 + '\" Operator="NE" Value=\"' + newConstraint.value + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'greater than') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' greater than ' + newConstraint.value + '.',
                    assertion: '<Assertion><SimpleValue Path=\"' + newConstraint.position_1 + '\" Operator="GT" Value=\"' + newConstraint.value + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'equal to or greater than') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' equal to or greater than ' + newConstraint.value + '.',
                    assertion: '<Assertion><SimpleValue Path=\"' + newConstraint.position_1 + '\" Operator="GE" Value=\"' + newConstraint.value + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'less than') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' less than ' + newConstraint.value + '.',
                    assertion: '<Assertion><SimpleValue Path=\"' + newConstraint.position_1 + '\" Operator="LT" Value=\"' + newConstraint.value + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === 'equal to or less than') {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' equal to or less than ' + newConstraint.value + '.',
                    assertion: '<Assertion><SimpleValue Path=\"' + newConstraint.position_1 + '\" Operator="LE" Value=\"' + newConstraint.value + '\"/></Assertion>'
                };
            } else if (newConstraint.contraintType === "valued sequentially starting with the value '1'") {
                cs = {
                    id: new ObjectId().toString(),
                    constraintId: newConstraint.constraintId,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + " valued sequentially starting with the value '1'.",
                    assertion: '<Assertion><SetID Path=\"' + newConstraint.position_1 + '\"/></Assertion>'
                };
            }


            if (newConstraint.verb.includes('NOT') || newConstraint.verb.includes('not')) {
                cs.assertion = cs.assertion.replace("<Assertion>", "<Assertion><NOT>");
                cs.assertion = cs.assertion.replace("</Assertion>", "</NOT></Assertion>");
            }

            return cs;
        };

        $rootScope.generateFreeTextPredicate = function(positionPath, newConstraint) {
            var cp = {
                id: new ObjectId().toString(),
                constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                constraintTarget: positionPath,
                description: newConstraint.freeText,
                trueUsage: newConstraint.trueUsage,
                falseUsage: newConstraint.falseUsage,
                assertion: null
            };
            return cp;
        };

        $rootScope.generatePredicate = function(positionPath, newConstraint) {
            var cp = null;
            if (newConstraint.contraintType === 'valued') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' ' + newConstraint.contraintType,
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><Presence Path=\"' + newConstraint.position_1 + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'a literal value') {
                if (newConstraint.value.indexOf("^") == -1) {
                    cp = {
                        id: new ObjectId().toString(),
                        constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                        constraintTarget: positionPath,
                        description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' \'' + newConstraint.value + '\'.',
                        trueUsage: newConstraint.trueUsage,
                        falseUsage: newConstraint.falseUsage,
                        assertion: '<Condition><PlainText Path=\"' + newConstraint.position_1 + '\" Text=\"' + newConstraint.value + '\" IgnoreCase=\"' + newConstraint.ignoreCase + '\"/></Condition>'
                    };
                } else {
                    var componetsList = newConstraint.value.split("^");
                    var assertionScript = "";
                    var componentPosition = 0;

                    angular.forEach(componetsList, function(componentValue) {
                        componentPosition = componentPosition + 1;
                        var script = '<PlainText Path=\"' + newConstraint.position_1 + "." + componentPosition + "[1]" + '\" Text=\"' + componentValue + '\" IgnoreCase="false"/>';
                        if (assertionScript === "") {
                            assertionScript = script;
                        } else {
                            assertionScript = "<AND>" + assertionScript + script + "</AND>";
                        }
                    });
                    cp = {
                        id: new ObjectId().toString(),
                        constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                        constraintTarget: positionPath,
                        description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' \'' + newConstraint.value + '\'.',
                        trueUsage: newConstraint.trueUsage,
                        falseUsage: newConstraint.falseUsage,
                        assertion: '<Condition>' + assertionScript + '</Condition>'
                    };
                }
            } else if (newConstraint.contraintType === 'one of list values') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' ' + newConstraint.contraintType + ': ' + newConstraint.value + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><StringList Path=\"' + newConstraint.position_1 + '\" CSV=\"' + newConstraint.value + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'one of codes in ValueSet') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' ' + newConstraint.contraintType + ': ' + newConstraint.valueSetId + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><ValueSet Path=\"' + newConstraint.position_1 + '\" ValueSetID=\"' + newConstraint.valueSetId + '\" BindingStrength=\"' + newConstraint.bindingStrength + '\" BindingLocation=\"' + newConstraint.bindingLocation + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'formatted value') {
                if (newConstraint.value === 'Regular expression') {
                    cp = {
                        id: new ObjectId().toString(),
                        constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                        constraintTarget: positionPath,
                        description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' formatted with \'' + newConstraint.value2 + '\'.',
                        trueUsage: newConstraint.trueUsage,
                        falseUsage: newConstraint.falseUsage,
                        assertion: '<Condition><Format Path=\"' + newConstraint.position_1 + '\" Regex=\"' + newConstraint.value2 + '\"/></Condition>'
                    };
                } else {
                    cp = {
                        id: new ObjectId().toString(),
                        constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                        constraintTarget: positionPath,
                        description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' formatted with \'' + newConstraint.value + '\'.',
                        trueUsage: newConstraint.trueUsage,
                        falseUsage: newConstraint.falseUsage,
                        assertion: '<Condition><Format Path=\"' + newConstraint.position_1 + '\" Regex=\"' + $rootScope.genRegex(newConstraint.value) + '\"/></Condition>'
                    };
                }
            } else if (newConstraint.contraintType === 'identical to another node') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'The value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' identical to the value of ' + newConstraint.location_2 + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="EQ" Path2=\"' + newConstraint.position_2 + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'equal to another node') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' equal to the value of ' + newConstraint.location_2 + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="EQ" Path2=\"' + newConstraint.position_2 + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'not-equal to another node') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' different with the value of ' + newConstraint.location_2 + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="NE" Path2=\"' + newConstraint.position_2 + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'greater than another node') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' greater than the value of ' + newConstraint.location_2 + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="GT" Path2=\"' + newConstraint.position_2 + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'equal to or greater than another node') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' equal to or greater than the value of ' + newConstraint.location_2 + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="GE" Path2=\"' + newConstraint.position_2 + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'less than another node') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' less than the value of ' + newConstraint.location_2 + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="LT" Path2=\"' + newConstraint.position_2 + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'equal to or less than another node') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' equal to or less than the value of ' + newConstraint.location_2 + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><PathValue Path1=\"' + newConstraint.position_1 + '\" Operator="LE" Path2=\"' + newConstraint.position_2 + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'equal to') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' equal to ' + newConstraint.value + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><SimpleValue Path=\"' + newConstraint.position_1 + '\" Operator="EQ" Value=\"' + newConstraint.value + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'not-equal to') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' different with ' + newConstraint.value + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><SimpleValue Path=\"' + newConstraint.position_1 + '\" Operator="NE" Value=\"' + newConstraint.value + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'greater than') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' greater than ' + newConstraint.value + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><SimpleValue Path=\"' + newConstraint.position_1 + '\" Operator="GT" Value=\"' + newConstraint.value + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'equal to or greater than') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' equal to or greater than ' + newConstraint.value + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><SimpleValue Path=\"' + newConstraint.position_1 + '\" Operator="GE" Value=\"' + newConstraint.value + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'less than') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' less than ' + newConstraint.value + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><SimpleValue Path=\"' + newConstraint.position_1 + '\" Operator="LT" Value=\"' + newConstraint.value + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === 'equal to or less than') {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + ' equal to or less than ' + newConstraint.value + '.',
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><SimpleValue Path=\"' + newConstraint.position_1 + '\" Operator="LE" Value=\"' + newConstraint.value + '\"/></Condition>'
                };
            } else if (newConstraint.contraintType === "valued sequentially starting with the value '1'") {
                cp = {
                    id: new ObjectId().toString(),
                    constraintId: 'CP_' + positionPath + '_' + $rootScope.newPredicateFakeId,
                    constraintTarget: positionPath,
                    description: 'If the value of ' + newConstraint.location_1 + ' ' + newConstraint.verb + " valued sequentially starting with the value '1'.",
                    trueUsage: newConstraint.trueUsage,
                    falseUsage: newConstraint.falseUsage,
                    assertion: '<Condition><SetID Path=\"' + newConstraint.position_1 + '\"/></Condition>'
                };
            }

            if (newConstraint.verb.includes('NOT') || newConstraint.verb.includes('not')) {
                cp.assertion = cp.assertion.replace("<Condition>", "<Condition><NOT>");
                cp.assertion = cp.assertion.replace("</Condition>", "</NOT></Condition>");
            }

            return cp;
        };


        $rootScope.erorrForComplexConfStatement = function(newComplexConstraintId, targetComplexId, compositeType, firstConstraint, secondConstraint, constraints) {
            if ($rootScope.isEmptyCompositeType(compositeType)) return true;
            if ($rootScope.isEmptyComplexConstraintID(newComplexConstraintId)) return true;
            if ($rootScope.isDuplicatedComplexConstraintID(newComplexConstraintId, targetComplexId)) return true;

            if (compositeType == 'FORALL' || compositeType == 'EXIST') {
                if (constraints.length < 2) return true;
            } else {
                if (firstConstraint == null) return true;
                if (secondConstraint == null) return true;
            }

            return false;
        };

        $rootScope.erorrForComplexPredicate = function(compositeType, firstConstraint, secondConstraint, complexConstraintTrueUsage, complexConstraintFalseUsage, constraints) {
            if ($rootScope.isEmptyCompositeType(compositeType)) return true;
            if (compositeType == 'FORALL' || compositeType == 'EXIST') {
                if (constraints.length < 2) return true;
            } else {
                if (firstConstraint == null) return true;
                if (secondConstraint == null) return true;
            }
            return false;
        };
        $rootScope.erorrForPredicate = function(newConstraint, type, selectedNode) {
            if (!selectedNode) return true;
            if ($rootScope.isEmptyConstraintNode(newConstraint, type)) return true;
            if ($rootScope.isEmptyConstraintVerb(newConstraint)) return true;
            if ($rootScope.isEmptyConstraintPattern(newConstraint)) return true;
            if (newConstraint.contraintType == 'a literal value' ||
                newConstraint.contraintType == 'equal to' ||
                newConstraint.contraintType == 'not-equal to' ||
                newConstraint.contraintType == 'greater than' ||
                newConstraint.contraintType == 'equal to or greater than' ||
                newConstraint.contraintType == 'less than' ||
                newConstraint.contraintType == 'equal to or less than' ||
                newConstraint.contraintType == 'one of list values' ||
                newConstraint.contraintType == 'formatted value') {
                if ($rootScope.isEmptyConstraintValue(newConstraint)) return true;
                if (newConstraint.value == 'Regular expression') {
                    if ($rootScope.isEmptyConstraintValue2(newConstraint)) return true;
                }
            } else if (newConstraint.contraintType == 'identical to another node' ||
                newConstraint.contraintType == 'equal to another node' ||
                newConstraint.contraintType == 'not-equal to another node' ||
                newConstraint.contraintType == 'greater than another node' ||
                newConstraint.contraintType == 'equal to or greater than another node' ||
                newConstraint.contraintType == 'less than another node' ||
                newConstraint.contraintType == 'equal to or less than another node') {
                if ($rootScope.isEmptyConstraintAnotherNode(newConstraint)) return true;
            } else if (newConstraint.contraintType == 'one of codes in ValueSet') {
                if ($rootScope.isEmptyConstraintValueSet(newConstraint)) return true;
            }

            return false;
        }


        $rootScope.erorrForConfStatement = function(newConstraint, targetId, type, selectedNode) {
            if ($rootScope.isEmptyConstraintID(newConstraint)) return true;
            if ($rootScope.isDuplicatedConstraintID(newConstraint, targetId)) return true;
            if ($rootScope.isEmptyConstraintNode(newConstraint, type)) return true;
            if ($rootScope.isEmptyConstraintVerb(newConstraint)) return true;
            if ($rootScope.isEmptyConstraintPattern(newConstraint)) return true;
            if (newConstraint.contraintType == 'a literal value' ||
                newConstraint.contraintType == 'equal to' ||
                newConstraint.contraintType == 'not-equal to' ||
                newConstraint.contraintType == 'greater than' ||
                newConstraint.contraintType == 'equal to or greater than' ||
                newConstraint.contraintType == 'less than' ||
                newConstraint.contraintType == 'equal to or less than' ||
                newConstraint.contraintType == 'one of list values' ||
                newConstraint.contraintType == 'formatted value') {
                if ($rootScope.isEmptyConstraintValue(newConstraint)) return true;
                if (newConstraint.value == 'Regular expression') {
                    if ($rootScope.isEmptyConstraintValue2(newConstraint)) return true;
                }
            } else if (newConstraint.contraintType == 'identical to another node' ||
                newConstraint.contraintType == 'equal to another node' ||
                newConstraint.contraintType == 'not-equal to another node' ||
                newConstraint.contraintType == 'greater than another node' ||
                newConstraint.contraintType == 'equal to or greater than another node' ||
                newConstraint.contraintType == 'less than another node' ||
                newConstraint.contraintType == 'equal to or less than another node') {
                if ($rootScope.isEmptyConstraintAnotherNode(newConstraint)) return true;
            } else if (newConstraint.contraintType == 'one of codes in ValueSet') {
                if ($rootScope.isEmptyConstraintValueSet(newConstraint)) return true;
            }
            return false;
        };

        $rootScope.isEmptyConstraintID = function(newConstraint) {
            if (newConstraint.constraintId === null) return true;
            if (newConstraint.constraintId === '') return true;

            return false;
        }

        $rootScope.isEmptyComplexConstraintID = function(id) {
            if (id === null) return true;
            if (id === '') return true;

            return false;
        }
        $rootScope.getVersionToSelect=function(element){
        	if(element.publicationVersion){
        		return"(v"+element.publicationVersion+")";
        	}else{
        		return "";
        	}
        }
        $rootScope.isDuplicatedConstraintID = function(newConstraint, targetId) {
            if ($rootScope.conformanceStatementIdList.indexOf(newConstraint.constraintId) != -1 && targetId == newConstraint.constraintId) return true;

            return false;
        }

        $rootScope.isDuplicatedComplexConstraintID = function(newComplexConstraintId, targetComplexId) {
            if ($rootScope.conformanceStatementIdList.indexOf(newComplexConstraintId) != -1 && targetComplexId == newComplexConstraintId) return true;

            return false;
        }

        $rootScope.isEmptyConstraintNode = function(newConstraint, type) {
            if (type == 'datatype') {
                if (newConstraint.component_1 === null) return true;
            } else if (type == 'segment') {
                if (newConstraint.field_1 === null) return true;
            } else if (type == 'message') {
                if (newConstraint.position_1 === null) return true;
            }

            return false;
        }

        $rootScope.isEmptyConstraintVerb = function(newConstraint) {
            if (newConstraint.verb === null) return true;

            return false;
        }

        $rootScope.isEmptyConstraintPattern = function(newConstraint) {
            if (newConstraint.contraintType === null) return true;

            return false;
        }

        $rootScope.isEmptyConstraintValue = function(newConstraint) {
            if (newConstraint.value === null) return true;

            return false;
        }

        $rootScope.isEmptyConstraintValue2 = function(newConstraint) {
            if (newConstraint.value2 === null) return true;

            return false;
        }

        $rootScope.isEmptyConstraintAnotherNode = function(newConstraint, type) {
            if (type == 'datatype') {
                if (newConstraint.component_2 === null) return true;
            } else if (type == 'segment') {
                if (newConstraint.field_2 === null) return true;
            } else if (type == 'message') {
                if (newConstraint.position_2 === null) return true;
            }

            return false;
        }

        $rootScope.isEmptyConstraintValueSet = function(newConstraint) {
            if (newConstraint.valueSetId === null) return true;

            return false;
        }

        $rootScope.isEmptyCompositeType = function(compositeType) {
            if (compositeType === null) return true;

            return false;
        }


        // We check for IE when the user load the main page.
        // TODO: Check only once.
        // $scope.checkForIE();


        $rootScope.openRichTextDlg = function(obj, key, title, disabled) {
            return $modal.open({
                templateUrl: 'RichTextCtrl.html',
                controller: 'RichTextCtrl',
                windowClass: 'app-modal-window',
                backdrop: true,
                keyboard: true,
                backdropClick: false,
                resolve: {
                    editorTarget: function() {
                        return {
                            key: key,
                            obj: obj,
                            disabled: disabled,
                            title: title
                        };
                    }
                }
            });
        };

        $rootScope.openInputTextDlg = function(obj, key, title, disabled) {
            return $modal.open({
                templateUrl: 'InputTextCtrl.html',
                controller: 'InputTextCtrl',
                backdrop: true,
                keyboard: true,
                windowClass: 'input-text-modal-window',
                backdropClick: false,
                resolve: {
                    editorTarget: function() {
                        return {
                            key: key,
                            obj: obj,
                            disabled: disabled,
                            title: title
                        };
                    }
                }
            });
        };


        $rootScope.isDuplicated = function(obj, context, list) {
            if (obj == null || obj == undefined || obj[context] == null) return false;
            return _.find(_.without(list, obj), function(item) {
                return item[context] == obj[context] && item.id != obj.id;
            });
        };

        // $rootScope.validateExtension = function (obj, context, list) {
        // //if (obj == null || obj == undefined) return false;
        // if(obj[context] == null) return false;
        // return _.find(_.without(list, obj), function (item) {
        // return item[context] == obj[context];
        // });


        // };


        $rootScope.isDuplicatedTwoContexts = function(obj, context1, context2, list) {
            if (obj == null || obj == undefined) return false;

            return _.find(_.without(list, obj), function(item) {
                if (item[context1] == obj[context1]) {
                    return item[context2] == obj[context2] && item.id != obj.id;
                } else {
                    return false;
                }
            });
        };
        $rootScope.mergeEmptyProperty= function(to, from){
        	Object.keys(to).forEach(function(key,index) {
        		if(!to[key]&&from[key])
        			to[key]=from[key];
        	    // key: the name of the object key
        	    // index: the ordinal position of the key within the object 
        	});

        }
        $scope.init = function() {
            VersionAndUseService.findAll().then(function(result) {
            	console.log("LOADING INFO VERSION");

            
                angular.forEach(result, function(info) {
                	console.log("LOADING INFO VERSION");
                	console.log($rootScope.versionAndUseMap[info.id]);
                    $rootScope.versionAndUseMap[info.id] = info;
                });
            });
            $http.get('api/igdocuments/config', { timeout: 60000 }).then(function(response) {
                $rootScope.config = angular.fromJson(response.data);
                var delay = $q.defer();

            }, function(error) {});
            
        };


        $scope.getFullName = function() {
            if (userInfoService.isAuthenticated() === true) {
                return userInfoService.getFullName();
            }
            return '';
        };

        $rootScope.getLabel = function(name, ext) {
            var label = name;
            if (ext && ext !== null && ext !== "") {
                label = label + "_" + ext;
            }
            return label;
        };

        $rootScope.getDynamicWidth = function(a, b, otherColumsWidth) {
            var tableWidth = $rootScope.getTableWidth();
            if (tableWidth > 0) {
                var left = tableWidth - otherColumsWidth;
                return { "width": a * parseInt(left / b) + "px" };
            }
            return "";
        };


        $rootScope.getTableWidth = function() {
            if ($rootScope.tableWidth === null || $scope.tableWidth == 0) {
                $rootScope.tableWidth = $("#nodeDetailsPanel").width();
            }
            return $rootScope.tableWidth;
        };


        $rootScope.getConstraintAsString = function(constraint) {
            return constraint.constraintId + " - " + constraint.description;
        };

        $rootScope.getConformanceStatementAsString = function(constraint) {
            return "[" + constraint.constraintId + "]" + constraint.description;
        };
        $rootScope.getConstraintAsId = function(constraint) {
            return "[" + constraint.constraintId + "]";
        };

        $rootScope.getPredicateAsString = function(constraint) {
            if(constraint) return constraint.description;
            return null;
        };

        $rootScope.getTextValue = function(value) {
            return value;
        };

        $rootScope.getConstraintsAsString = function(constraints) {
            var str = '';
            for (var index in constraints) {
                str = str + "<p style=\"text-align: left\">" + constraints[index].id + " - " + constraints[index].description + "</p>";
            }
            return str;
        };

        $rootScope.getPredicatesAsMultipleLinesString = function(node) {
            var html = "";
            angular.forEach(node.predicates, function(predicate) {
                html = html + "<p>" + predicate.description + "</p>";
            });
            return html;
        };

        $rootScope.getPredicatesAsOneLineString = function(node) {
            var html = "";
            angular.forEach(node.predicates, function(predicate) {
                html = html + predicate.description;
            });
            return $sce.trustAsHtml(html);
        };


        $rootScope.getConfStatementsAsMultipleLinesString = function(node) {
            var html = "";
            angular.forEach(node.conformanceStatements, function(conStatement) {
                html = html + "<p>" + conStatement.id + " : " + conStatement.description + "</p>";
            });
            return html;
        };

        $rootScope.getConfStatementsAsOneLineString = function(node) {
            var html = "";
            angular.forEach(node.conformanceStatements, function(conStatement) {
                html = html + conStatement.id + " : " + conStatement.description;
            });
            return $sce.trustAsHtml(html);
        };

        $rootScope.getSegmentRefNodeName = function(node) {
            var seg = $rootScope.segmentsMap[node.ref.id];
            return node.position + "." + $rootScope.getSegmentLabel(seg) + ":" + seg.description;
        };

        $rootScope.getSegmentLabel = function(seg) {
            // var ext = $rootScope.getSegmentExtension(seg);
            return seg != null ? $rootScope.getLabel(seg.name, seg.ext) : "";
        };

        $rootScope.getSegmentExtension = function(seg) {
            return $rootScope.getExtensionInLibrary(seg.id, $rootScope.igdocument.profile.segmentLibrary, "ext");
        };

        $rootScope.getDatatypeExtension = function(datatype) {
            return $rootScope.getExtensionInLibrary(datatype.id, $rootScope.datatypeLibrary, "ext");
        };

        $rootScope.getTableBindingIdentifier = function(table) {
            return $rootScope.getExtensionInLibrary(table.id, $rootScope.tableLibrary, "bindingIdentifier");
        };


        $rootScope.getDatatypeLabel = function(datatype) {
            if (datatype && datatype != null) {
                // var ext = $rootScope.getDatatypeExtension(datatype);
                return $rootScope.getLabel(datatype.name, datatype.ext);
            }
            return "";
        };

        $rootScope.getVersionLabel=function(id){
            if($rootScope.versionAndUseMap[id]){
                return "(v"+$rootScope.versionAndUseMap[id].publicationVersion+")";
            }else{
                return "";
            }
             
        }
        $rootScope.hasSameVersion = function(element) {

            return element.hl7Version;

        }

        $rootScope.getTableLabel = function(table) {
        	
            if (table && table.bindingIdentifier) {
                return $rootScope.getLabel(table.bindingIdentifier, table.ext);
            }
            return "";
        };

        $rootScope.getExtensionInLibrary = function(id, library, propertyType) {
            // ////console.log("main Here id=" + id);
            if (propertyType && library.children) {
                for (var i = 0; i < library.children.length; i++) {
                    if (library.children[i].id === id) {
                        return library.children[i][propertyType];
                    }
                }
            }
            return "";
        };
        $rootScope.publishTable = function(table) {
            var modalInstance = $modal.open({
                templateUrl: 'ConfirmTablePublish.html',
                controller: 'ConfirmTablePublishCtl',
                resolve: {
                    tableToPublish: function() {
                        return table;
                    }
                }
            });
            modalInstance.result.then(function(table) {
                
                var newLink={
                    name:table.name,
                    ext:table.ext,
                    id:table.id
                }

        
      
                TableService.publish($rootScope.table).then(function(published) {
                		console.log("published Results");
                		console.log(published);
                    TableLibrarySvc.updateChild($rootScope.tableLibrary.id, newLink).then(function(link) {

                    		$rootScope.table=published;
                    		
                    		
                    		$rootScope.tablesMap[published.id].status="PUBLISHED";

                    		console.log("rootScope"); 
                    		$rootScope.$broadcast('event:openTable', $rootScope.table);
                    		console.log($rootScope.table);
                            if ($scope.editForm) {
                            	console.log("Cleeaning");
                                $scope.editForm.$setPristine();
                                $scope.editForm.$dirty = false;
                                $scope.editForm.$invalid = false;
                                
                            }
                            $rootScope.clearChanges();
                         	VersionAndUseService.findById(published.id).then(function(inf){
                        		$rootScope.versionAndUseMap[inf.id]=inf;
                        		if($rootScope.versionAndUseMap[inf.sourceId]){
                        			$rootScope.versionAndUseMap[inf.sourceId].deprecated=true;
                        		
                        		}
                            	
                        	});
                    });
                });
            });
        };
        $rootScope.canCreateNewVersion= function(element){
        	if(element.scope&&element.scope!=='USER'){

        		return false;
        	}else if(element.status!=="PUBLISHED"){

        		return false;
        	}
        	else if($rootScope.versionAndUseMap[element.id]&&$rootScope.versionAndUseMap[element.id].deprectaed){
        		console.log($rootScope.versionAndUseMap[element.id].deprectaed);
        		return false;
        		
        	}else{
        		return true;
        	}
        
        }
        $rootScope.publishDatatype = function(datatype) {
        	console.log("publisheing")

            $rootScope.containUnpublished = false;
            $rootScope.unpublishedTables = [];
            $rootScope.unpublishedDatatypes = [];
            $rootScope.ContainUnpublished(datatype);

            if ($rootScope.containUnpublished) {
                $rootScope.abortPublish(datatype);
                datatype.status = "UNPUBLISHED";
            } else {
                $rootScope.confirmPublish(datatype);

            }
        };
        $rootScope.confirmSwitch = function(source, dest) {
            var modalInstance = $modal.open({
                templateUrl: 'confirmSwitch.html',
                controller: 'confirmSwitch',
                resolve: {
                    source: function() {
                        return source;
                    },
                    dest: function() {
                        return dest;
                    },
                    
                }
            });
            modalInstance.result.then(function() {
            	$rootScope.replaceElement(source,dest);
                
            });
        };

        $rootScope.getGroupNodeName = function(node) {
            return node.position + "." + node.name;
        };

        $rootScope.getFieldNodeName = function(node) {
            return node.position + "." + node.name;
        };

        $rootScope.getComponentNodeName = function(node) {
            return node.position + "." + node.name;
        };

        $rootScope.getDatatypeNodeName = function(node) {
            return node.position + "." + node.name;
        };

        $rootScope.onColumnToggle = function(item) {
            $rootScope.viewSettings.save();
        };

        $rootScope.getDatatypeLevelConfStatements = function(element) {
            return DatatypeService.getDatatypeLevelConfStatements(element);
        };

        $rootScope.getDatatypeLevelPredicates = function(element) {
            return DatatypeService.getDatatypeLevelPredicates(element);
        };

        $rootScope.isDatatypeSubDT = function(component) {
            return DatatypeService.isDatatypeSubDT(component, $rootScope.datatype);
        };



        $rootScope.setUsage = function(node) {
            ElementUtils.setUsage(node);
        };


        $rootScope.findDatatypeInLibrary = function(datatypeId, datatypeLibary) {
            if (datatypeLibary.children) {
                for (var i = 0; i < datatypeLibary.children.length; i++) {
                    if (datatypeLibary.children[i].id === id) {
                        return datatypeLibary.children[i];
                    }
                }
            }
            return null;
        };


        $rootScope.openConfirmLeaveDlg = function() {
            if ($rootScope.modalInstance != undefined && $rootScope.modalInstance != null && $rootScope.modalInstance.opened) {
                $rootScope.modalInstance.close();
            }
            $rootScope.modalInstance = $modal.open({
                templateUrl: 'ConfirmLeaveDlg.html',
                controller: 'ConfirmLeaveDlgCtrl',
                'size': 'md'
            });
            return $rootScope.modalInstance;
        };

        $rootScope.displayNullView = function() {
            //console.log("before");
            //console.log($rootScope.subview);
            $rootScope.subview = 'Blank.html';
            //console.log("after");
            //console.log($rootScope.subview);
        }

        $rootScope.Activate = function(param) {
            $rootScope.activeModel = param;
        }


        var vm = this;

        //        $scope.$on("getMenuState", function (event, data) {
        //            $scope.$apply(function () {
        //                vm.opened = data;
        //            });
        //        });
        //
        //        this.toggleNavigation = function() {
        //            $mdSidenav('navigation-drawer').toggle();
        //        };

        $scope.checkedNavigation = false;
        $scope.toggleNavigation = function() {
            $scope.checkedNavigation = !$scope.checkedNavigation;
        };


    }
]);


angular.module('igl').controller('LoginCtrl', ['$scope', '$modalInstance', 'user', function($scope, $modalInstance, user) {
    $scope.user = user;

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };

    $scope.login = function() {
        // ////console.log("logging in...");
        $modalInstance.close($scope.user);
    };
}]);


angular.module('igl').controller('RichTextCtrl', ['$scope', '$modalInstance', 'editorTarget', function($scope, $modalInstance, editorTarget) {
    $scope.editorTarget = editorTarget;

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };

    $scope.close = function() {
        $modalInstance.close($scope.editorTarget);
    };
}]);


angular.module('igl').controller('InputTextCtrl', ['$scope', '$modalInstance', 'editorTarget', function($scope, $modalInstance, editorTarget) {
    $scope.editorTarget = editorTarget;

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };

    $scope.close = function() {
        $modalInstance.close($scope.editorTarget);
    };
}]);

angular.module('igl').controller('ConfirmLogoutCtrl', ["$scope", "$modalInstance", "$rootScope", "$http", function($scope, $modalInstance, $rootScope, $http) {
    $scope.logout = function() {
        $modalInstance.close();
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
}]);


angular.module('igl').controller('ConfirmLeaveDlgCtrl', function($scope, $modalInstance, $rootScope, $http, SectionSvc, FilteringSvc, MessageService, SegmentService, SegmentLibrarySvc, DatatypeLibrarySvc, DatatypeService, IgDocumentService, ProfileSvc, TableService, TableLibrarySvc) {
    $scope.continue = function() {
        $rootScope.clearChanges();
        $modalInstance.close();
    };


    $scope.discard = function() {
        var data = $rootScope.currentData;
        if (data.type && data.type === "message") {
            MessageService.reset();
        } else if (data.type && data.type === "segment") {
            SegmentService.reset();
        } else if (data.type && data.type === "datatype") {
            DatatypeService.reset();
        }
        $rootScope.addedSegments = [];
        $rootScope.addedDatatypes = [];
        $rootScope.addedTables = [];
        $scope.continue();
    };

    $scope.error = null;
    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };

    $scope.save = function() {
        var data = $rootScope.currentData;
        if ($rootScope.libraryDoc && $rootScope.libraryDoc != null) {
            if (data.datatypeLibId && data.date) {
                DatatypeLibrarySvc.saveMetaData($rootScope.libraryDoc.datatypeLibrary.id, data);
            }

        }
        var section = { id: data.id, sectionTitle: data.sectionTitle, sectionDescription: data.sectionDescription, sectionPosition: data.sectionPosition, sectionContents: data.sectionContents };
        ////console.log(data);

        if (data.type && data.type === "section") {
            ////console.log($rootScope.originalSection);
            ////console.log(data);

            SectionSvc.update($rootScope.igdocument.id, section).then(function(result) {
                ////console.log($rootScope.igdocument);
                SectionSvc.merge($rootScope.originalSection, section);
                $scope.continue();
            }, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        } else if (data.type && data.type === "messages") {
            ////console.log($rootScope.originalSection);
            ////console.log(data);
            SectionSvc.update($rootScope.igdocument.id, section).then(function(result) {
                ////console.log($rootScope.igdocument);
                SectionSvc.merge($rootScope.originalSection, section);
                $scope.continue();
            }, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        } else if (data.type && data.type === "segments") {
            ////console.log($rootScope.originalSection);
            ////console.log(data);

            SectionSvc.update($rootScope.igdocument.id, section).then(function(result) {
                ////console.log($rootScope.igdocument);
                SectionSvc.merge($rootScope.originalSection, section);
                $scope.continue();
            }, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        } else if (data.type && data.type === "datatypes") {
            ////console.log($rootScope.originalSection);
            ////console.log(data);

            SectionSvc.update($rootScope.igdocument.id, section).then(function(result) {
                ////console.log($rootScope.igdocument);
                SectionSvc.merge($rootScope.originalSection, section);
                $scope.continue();
            }, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        } else if (data.type && data.type === "tables") {
            ////console.log($rootScope.originalSection);
            ////console.log(data);

            SectionSvc.update($rootScope.igdocument.id, section).then(function(result) {
                ////console.log($rootScope.igdocument);
                SectionSvc.merge($rootScope.originalSection, section);
                $scope.continue();
            }, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        } else if (data.type && data.type === "message") {
            var message = $rootScope.message;
            ////console.log($rootScope.message);
            MessageService.save(message).then(function(result) {
                var index = MessageService.findIndex(message.id);
                if (index < 0) {
                    $rootScope.igdocument.profile.messages.children.splice(0, 0, message);
                }
                MessageService.saveNewElements().then(function() {
                    MessageService.merge($rootScope.messagesMap[message.id], message);
                    $scope.continue();
                }, function(error) {
                    $rootScope.msg().text = "Sorry an error occured. Please try again";
                    $rootScope.msg().type = "danger";
                    $rootScope.msg().show = true;
                });
            }, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });

        } else if (data.type && data.type === "segment") {
            if (data.scope === 'USER' || (data.status && data.status === 'UNPUBLISHED')) {
                var segment = $rootScope.segment;
                var ext = segment.ext;
                if (segment.libIds === undefined) segment.libIds = [];
                if (segment.libIds.indexOf($rootScope.igdocument.profile.segmentLibrary.id) == -1) {
                    segment.libIds.push($rootScope.igdocument.profile.segmentLibrary.id);
                }
                SegmentService.save($rootScope.segment).then(function(result) {
                    var oldLink = SegmentLibrarySvc.findOneChild(result.id, $rootScope.igdocument.profile.segmentLibrary.children);
                    var newLink = SegmentService.getSegmentLink(result);
                    SegmentLibrarySvc.updateChild($rootScope.igdocument.profile.segmentLibrary.id, newLink).then(function(link) {
                        SegmentService.saveNewElements().then(function() {
                            SegmentService.merge($rootScope.segmentsMap[result.id], result);
                            if (oldLink && oldLink != null) {
                                oldLink.ext = newLink.ext;
                                oldLink.name = newLink.name;
                            }
                            $scope.continue();
                        }, function(error) {
                            $rootScope.msg().text = "Sorry an error occured. Please try again";
                            $rootScope.msg().type = "danger";
                            $rootScope.msg().show = true;
                        });
                    }, function(error) {
                        $rootScope.msg().text = error.data.text;
                        $rootScope.msg().type = error.data.type;
                        $rootScope.msg().show = true;
                    });
                }, function(error) {
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
            }else {
                $rootScope.saveBindingForSegment();
                $scope.continue();
            }


        } else if (data.type && data.type === "datatype") {
            if (data.scope === 'USER' || (data.status && data.status === 'UNPUBLISHED')) {
                var datatype = $rootScope.datatype;
                var ext = datatype.ext;
                var libId = "";
                var children = [];
                DatatypeService.save(datatype).then(function(result) {
                    if ($rootScope.libraryDoc && $rootScope.libraryDoc !== null) {
                        libId = $rootScope.libraryDoc.datatypeLibrary.id;
                        children = $rootScope.libraryDoc.datatypeLibrary.children;

                    } else if ($rootScope.igdocument && $rootScope.igdocument !== null) {
                        libId = $rootScope.datatypeLibrary.id;
                        children = $rootScope.datatypeLibrary.children;
                    }
                    var oldLink = DatatypeLibrarySvc.findOneChild(result.id, children);
                    var newLink = DatatypeService.getDatatypeLink(result);
                    newLink.ext = ext;
                    DatatypeLibrarySvc.updateChild(libId, newLink).then(function(link) {
                        DatatypeService.merge($rootScope.datatypesMap[result.id], result);
                        if (oldLink && oldLink != null) {
                            oldLink.ext = newLink.ext;
                            oldLink.name = newLink.name;
                        }
                        $scope.continue();

                    }, function(error) {
                        $rootScope.msg().text = "Sorry an error occured. Please try again";
                        $rootScope.msg().type = "danger";
                        $rootScope.msg().show = true;
                    });

                }, function(error) {
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
            }else {
                $rootScope.saveBindingForDatatype();
                $scope.continue();
            }

        } else if (data.type && data.type === "table") {
            if (data.scope === 'USER' || (data.status && data.status === 'UNPUBLISHED')) {
                var table = $rootScope.table;
                var libId = "";
                var children = [];
                var bindingIdentifier = table.bindingIdentifier;
                if ($rootScope.libraryDoc && $rootScope.libraryDoc !== null) {
                    libId = $rootScope.libraryDoc.tableLibrary.id;
                    children = $rootScope.libraryDoc.tableLibrary.children;

                } else if ($rootScope.igdocument && $rootScope.igdocument !== null) {
                    libId = $rootScope.tableLibrary.id;
                    children = $rootScope.tableLibrary.children;
                }
                TableService.save(table).then(function(result) {
                    var oldLink = TableLibrarySvc.findOneChild(result.id, children);
                    TableService.merge($rootScope.tablesMap[result.id], result);
                    var newLink = TableService.getTableLink(result);
                    newLink.bindingIdentifier = bindingIdentifier;
                    TableLibrarySvc.updateChild(libId, newLink).then(function(link) {
                        if (oldLink && oldLink != null) oldLink.bindingIdentifier = link.bindingIdentifier;
                        $rootScope.msg().text = "tableSaved";
                        $rootScope.msg().type = "success";
                        $rootScope.msg().show = true;
                        $scope.continue();
                    }, function(error) {
                        $rootScope.msg().text = error.data.text;
                        $rootScope.msg().type = error.data.type;
                        $rootScope.msg().show = true;
                    });
                }, function(error) {
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
            }else {
                $rootScope.saveBindingForValueSet();

            }

        } else if (data.type === "document") {

            IgDocumentService.saveMetadata($rootScope.igdocument.id, $rootScope.metaData).then(function(result) {
                $rootScope.igdocument.metaData = angular.copy($rootScope.metaData);
                $scope.continue();

            }, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });

        } else if (data.type === "profile") {

            if ($rootScope.igdocument != null && $rootScope.metaData != null) {
                ProfileSvc.saveMetaData($rootScope.igdocument.id, $rootScope.metaData).then(function(result) {
                    $scope.continue();
                }, function(error) {
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
            }
        }

    }
});
angular.module('igl').controller('confirmSwitch', function($scope, $rootScope, $http, $modalInstance, source, dest) {

	$scope.source=source;
	$scope.dest=dest;
    $scope.confirm = function() {
    	  $modalInstance.close();
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});
/**
 * Created by haffo on 2/13/15.
 */

angular.module('igl').controller('MessageListCtrl', function($scope, $rootScope, Restangular, ngTreetableParams, $filter, $http, $modal, $timeout, $q, CloneDeleteSvc, MastermapSvc, FilteringSvc, MessageService, SegmentService, SegmentLibrarySvc, DatatypeLibrarySvc, TableLibrarySvc, TableService, DatatypeService, blockUI, ViewSettings) {

    $scope.viewSettings = ViewSettings;

    $scope.accordStatus = {
        isCustomHeaderOpen: false,
        isFirstOpen: true,
        isSecondOpen: false,
        isThirdOpen: false,
        isFifthOpen: false,
        isSixOpen: false,
        isFirstDisabled: false
    };
    $scope.tabStatus = {
        active: 1
    };

    $scope.init = function() {
        $scope.accordStatus = {
            isCustomHeaderOpen: false,
            isFirstOpen: true,
            isSecondOpen: false,
            isThirdOpen: false,
            isFifthOpen: false,
            isSixOpen: false,
            isFirstDisabled: false
        };
        $scope.tabStatus = {
            active: 1
        };

        $scope.findAllGlobalConstraints();

    };

    $scope.redirectSeg = function(segmentRef) {
        SegmentService.get(segmentRef.id).then(function(segment) {
            var modalInstance = $modal.open({
                templateUrl: 'redirectCtrl.html',
                controller: 'redirectCtrl',
                size: 'md',
                resolve: {
                    destination: function() {
                        return segment;
                    }
                }



            });
            modalInstance.result.then(function() {
                $rootScope.editSeg(segment);
            });



        });
    };
    $scope.redirectDT = function(datatype) {
        DatatypeService.getOne(datatype.id).then(function(datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'redirectCtrl.html',
                controller: 'redirectCtrl',
                size: 'md',
                resolve: {
                    destination: function() {
                        return datatype;
                    }
                }



            });
            modalInstance.result.then(function() {
                $rootScope.editDatatype(datatype);
            });



        });
    };
    $scope.redirectVS = function(valueSet) {
        TableService.getOne(valueSet.id).then(function(valueSet) {
            var modalInstance = $modal.open({
                templateUrl: 'redirectCtrl.html',
                controller: 'redirectCtrl',
                size: 'md',
                resolve: {
                    destination: function() {
                        return valueSet;
                    }
                }



            });
            modalInstance.result.then(function() {
                $rootScope.editTable(valueSet);
            });



        });
    };

    $scope.deleteConformanceStatement = function(cs, target) {
        target.conformanceStatements.splice(target.conformanceStatements.indexOf(cs), 1);
        $scope.setDirty();
    };


    $scope.OtoX = function(message) {
        var modalInstance = $modal.open({
            templateUrl: 'OtoX.html',
            controller: 'OtoXCtrl',
            size: 'md',
            resolve: {
                message: function() {
                    return message;
                }
            }
        });
        modalInstance.result.then(function() {
            $scope.setDirty();

            if ($scope.messagesParams)
                $scope.messagesParams.refresh();
        });
    };

    $scope.expanded = true;
    $scope.expandAll = function() {
        $scope.expanded = !$scope.expanded;

        $('#messageTable').treetable('expandAll');
    };
    $scope.collapseAll = function() {
        $scope.expanded = !$scope.expanded;
        $('#messageTable').treetable('collapseAll');
    }

    $scope.copy = function(message) {
        CloneDeleteSvc.copyMessage(message);
        $rootScope.$broadcast('event:SetToC');
    };


    $scope.reset = function() {
        blockUI.start();
        MessageService.reset();
        $rootScope.processMessageTree($rootScope.message);
        cleanState();
        blockUI.stop();
    };

    var findIndex = function(id) {
        for (var i = 0; i < $rootScope.igdocument.profile.messages.children.length; i++) {
            if ($rootScope.igdocument.profile.messages.children[i].id === id) {
                return i;
            }
        }
        return -1;
    };

    var indexIn = function(id, collection) {
        for (var i = 0; i < collection.length; i++) {
            if (collection[i].id === id) {
                return i;
            }
        }
        return -1;
    };

    var cleanState = function() {
        $rootScope.addedSegments = [];
        $rootScope.addedDatatypes = [];
        $rootScope.addedTables = [];
        $scope.clearDirty();
        $scope.editForm.$setPristine();
        $scope.editForm.$dirty = false;
        $rootScope.clearChanges();
        if ($scope.messagesParams) {
            $scope.messagesParams.refresh();
        }
    };
    $scope.callMsgDelta = function() {
        $rootScope.$emit("event:openMsgDelta");
    };

    $scope.save = function() {
        $scope.saving = true;
        var message = $rootScope.message;
        $rootScope.$emit("event:saveMsgForDelta");
        console.log($rootScope.message);
        MessageService.save(message).then(function(result) {
            $rootScope.message.dateUpdated = result.dateUpdated;
            $rootScope.$emit("event:updateIgDate");
            var index = findIndex(message.id);
            if (index < 0) {
                $rootScope.igdocument.profile.messages.children.splice(0, 0, message);
            }

            MessageService.saveNewElements().then(function() {
                MessageService.merge($rootScope.messagesMap[message.id], message);
                cleanState();
            }, function(error) {
                $rootScope.msg().text = "Sorry an error occured. Please try again";
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
            });
        }, function(error) {
            $rootScope.msg().text = error.data.text;
            $rootScope.msg().type = error.data.type;
            $rootScope.msg().show = true;
        });
    };





    $scope.delete = function(message) {
        CloneDeleteSvc.deleteMessage(message);
        $rootScope.$broadcast('event:SetToC');
    };


    $scope.deleteSeg = function(segmentRefOrGrp) {
        var modalInstance = $modal.open({
            templateUrl: 'DeleteSegmentRefOrGrp.html',
            controller: 'DeleteSegmentRefOrGrpCtrl',
            windowClass: 'flavor-modal-window',
            resolve: {
                segOrGrpToDelete: function() {
                    return segmentRefOrGrp;
                }


            }
        });
        modalInstance.result.then(function() {
            $scope.setDirty();

            if ($scope.messagesParams)
                $scope.messagesParams.refresh();
        });
    };
    $scope.editableGrp = '';

    $scope.editGrp = function(group, message) {
        $scope.path = group.path.replace(/\[[0-9]+\]/g, '');
        $scope.path = $scope.path.split(".");
        MessageService.findParentByPath($scope.path, message).then(function() {});


        $scope.editableGrp = group.obj.id;
        $scope.grpName = group.obj.name;


    };
    $scope.backGrp = function() {
        $scope.editableGrp = '';
    };
    $scope.applyGrp = function(group, name, position) {
        blockUI.start();
        $scope.editableGrp = '';
        if (group) {
            group.obj.name = name;


        }
        if (position) {
            MessageService.updatePosition($rootScope.segParent.children, group.obj.position - 1, position - 1);
        }
        $scope.setDirty();

        $rootScope.processMessageTree($rootScope.message);
        if ($scope.messagesParams)
            $scope.messagesParams.refresh();
        $scope.Posselected = false;

        blockUI.stop();
    };



    $scope.editableSeg = '';

    $scope.editSgmt = function(segmentRef, message) {
        blockUI.start();
        $scope.path = segmentRef.path.replace(/\[[0-9]+\]/g, '');
        $scope.path = $scope.path.split(".");
        MessageService.findParentByPath($scope.path, message).then(function() {
            // $scope.parentLength=$rootScope.segParent.children.length;
        });

        $scope.editableSeg = segmentRef.obj.id;
        $scope.loadLibrariesByFlavorName = function() {
            var delay = $q.defer();

            $scope.ext = null;
            $scope.results = [];
            $scope.tmpResults = [];
            $scope.results = $scope.results.concat(filterFlavors($rootScope.igdocument.profile.segmentLibrary, segmentRef.obj.ref.name));
            $scope.results = _.uniq($scope.results, function(item, key, a) {
                return item.id;
            });
            $scope.tmpResults = [].concat($scope.results);
            //                SegmentLibrarySvc.findLibrariesByFlavorName(segmentRef.obj.ref.name, 'HL7STANDARD', $rootScope.igdocument.profile.metaData.hl7Version).then(function(libraries) {
            //                    if (libraries != null) {
            //                        _.each(libraries, function(library) {
            //                            $scope.results = $scope.results.concat(filterFlavors(library, segmentRef.obj.ref.name));
            //
            //                        });
            //                    }
            //
            //                    $scope.results = _.uniq($scope.results, function(item, key, a) {
            //                        return item.id;
            //                    });
            //
            //                    $scope.tmpResults = [].concat($scope.results);
            //                    console.log($scope.tmpResults);
            //
            //                    delay.resolve(true);
            //                }, function(error) {
            //                    $rootScope.msg().text = "Sorry could not load the segments";
            //                    $rootScope.msg().type = error.data.type;
            //                    $rootScope.msg().show = true;
            //                    delay.reject(error);
            //                });
            blockUI.stop();
            return delay.promise;

        };

        var filterFlavors = function(library, name) {
            var results = [];
            _.each(library.children, function(link) {
                console.log("++++++++++");
                console.log(link);
                if (link.name === name) {
                    link.libraryName = library.metaData.name;
                    link.hl7Version = $rootScope.segmentsMap[link.id].hl7Version;
                    //link.hl7Version = library.metaData.hl7Version;
                    results.push(link);
                }
            });
            return results;
        };
        $scope.loadLibrariesByFlavorName().then(function(done) {
            // $scope.selection.selected = $scope.currentSegment.id;
            // $scope.selectSegment($scope.currentSegment);
        });


    };

    $scope.backSeg = function() {
        blockUI.start();
        $scope.editableSeg = '';
        // segmentRef.obj.position=$scope.initialPosition;
        blockUI.stop();
    };





    $scope.selectSeg = function(segmentRef, segment) {
        $scope.Segselected = true;
        $scope.editableSeg = '';

        blockUI.start();
        console.log(segment);
        console.log(segmentRef);


        segmentRef.obj.ref.id = JSON.parse(segment).id;
        segmentRef.obj.ref.ext = JSON.parse(segment).ext;
        segmentRef.obj.ref.label = JSON.parse(segment).label;
        segmentRef.obj.ref.name = JSON.parse(segment).name;



        console.log(segmentRef);
        $scope.setDirty();
        var ref = $rootScope.segmentsMap[segmentRef.obj.ref.id];
        $rootScope.processMessageTree($rootScope.message);


        if ($scope.messagesParams)
            $scope.messagesParams.refresh();
        $scope.Segselected = false;
        $scope.Posselected = false;
        blockUI.stop();

    };

    $scope.selectPos = function(segmentRef, position) {

        // $scope.Posselected = true;
        $scope.editableSeg = '';

        MessageService.updatePosition($rootScope.segParent.children, segmentRef.obj.position - 1, position - 1);
        $scope.setDirty();

        $rootScope.processMessageTree($rootScope.message);


        if ($scope.messagesParams)
            $scope.messagesParams.refresh();




    };


    // $scope.selectSeg = function() {

    //     $scope.Segselected = true;




    // };

    $scope.selectedSeg = function() {
        return ($scope.tempSeg !== undefined);
    };
    $scope.unselectSeg = function() {
        $scope.tempSeg = undefined;
        //$scope.newSeg = undefined;
    };
    $scope.isSegActive = function(id) {
        if ($scope.tempSeg) {
            return $scope.tempSeg.id === id;
        } else {
            return false;
        }

    };




    $scope.goToSegment = function(segmentId) {
        $scope.$emit('event:openSegment', $rootScope.segmentsMap[segmentId]);
    };
    $scope.segOption = [

        ['Add segment',
            function($itemScope) {
                $scope.addSegmentModal($itemScope.node);
                /*
                 console.log($itemScope);
                 $itemScope.node.children.push($rootScope.messageTree.children[0]);
                 if ($scope.messagesParams) {
                 $scope.messagesParams.refresh();
                 }
                 */

            }
        ],
        null, ['Add group',
            function($itemScope) {
                $scope.addGroupModal($itemScope.node);
                //$itemScope.node.children.push($rootScope.messageTree.children[3]);
                //$scope.messagesParams.refresh();
            }
        ]

    ];

    $scope.addSegmentModal = function(place) {
        var modalInstance = $modal.open({
            templateUrl: 'AddSegmentModal.html',
            controller: 'AddSegmentCtrl',
            windowClass: 'creation-modal-window',
            resolve: {
                segments: function() {
                    return $rootScope.segments;
                },
                place: function() {
                    return place;
                },
                messageTree: function() {
                    return $rootScope.messageTree;
                }

            }
        });
        modalInstance.result.then(function(segment) {

            $scope.setDirty();


            if ($scope.messagesParams)
                $scope.messagesParams.refresh();
        });
    };
    $scope.addGroupModal = function(place) {
        var modalInstance = $modal.open({
            templateUrl: 'AddGroupModal.html',
            controller: 'AddGroupCtrl',
            windowClass: 'creation-modal-window',
            resolve: {
                segments: function() {
                    return $rootScope.segments;
                },
                place: function() {
                    return place;
                },
                messageTree: function() {
                    return $rootScope.messageTree;
                }

            }
        });
        modalInstance.result.then(function(segment) {
            $scope.setDirty();

            if ($scope.messagesParams)
                $scope.messagesParams.refresh();
        });
    };


    $scope.showSelectSegmentFlavorDlg = function(segmentRef) {
        console.log(segmentRef);
        var modalInstance = $modal.open({
            templateUrl: 'SelectSegmentFlavor.html',
            controller: 'SelectSegmentFlavorCtrl',
            windowClass: 'flavor-modal-window',
            resolve: {
                currentSegment: function() {
                    return $rootScope.segmentsMap[segmentRef.ref.id];
                },
                datatypeLibrary: function() {
                    return $rootScope.igdocument.profile.datatypeLibrary;
                },
                segmentLibrary: function() {
                    return $rootScope.igdocument.profile.segmentLibrary;
                },

                hl7Version: function() {
                    return $rootScope.igdocument.profile.metaData.hl7Version;
                }
            }
        });
        modalInstance.result.then(function(segment) {
            if (segment && segment != null) {
                $scope.loadingSelection = true;
                segmentRef.obj.ref.id = segment.id;
                segmentRef.obj.ref.ext = segment.ext;
                segmentRef.obj.ref.name = segment.name;
                segmentRef.children = [];
                $scope.setDirty();
                var ref = $rootScope.segmentsMap[segmentRef.obj.ref.id];
                $rootScope.processMessageTree(ref, segmentRef);
                if ($scope.messagesParams)
                    $scope.messagesParams.refresh();
                $scope.loadingSelection = false;
            }
        });
    };


    $scope.goToDatatype = function(datatype) {
        $scope.$emit('event:openDatatype', datatype);
    };

    $scope.goToTable = function(table) {
        $scope.$emit('event:openTable', table);
    };

    $scope.hasChildren = function(node) {
        if (node && node != null) {
            if (node.type === 'group') {
                return node.children && node.children.length > 0;
            } else if (node.type === 'segmentRef') {
                return $rootScope.segmentsMap[node.ref.id] && $rootScope.segmentsMap[node.ref.id].fields && $rootScope.segmentsMap[node.ref.id].fields.length > 0;
            } else if (node.type === 'field' || node.type === 'component') {
                return $rootScope.datatypesMap[node.datatype.id] && $rootScope.datatypesMap[node.datatype.id].components && $rootScope.datatypesMap[node.datatype.id].components.length > 0;
            }
            return false;
        } else {
            return false;
        }

    };

    $scope.isSub = function(component) {
        return $scope.isSubDT(component);
    };

    $scope.isSubDT = function(component) {
        return component.type === 'component' && $rootScope.parentsMap && $rootScope.parentsMap[component.id] && $rootScope.parentsMap[component.id].type === 'component';
    };

    $scope.isVisible = function(node) {
        if (node && node != null) {
            //                return FilteringSvc.show(node);
            return true;
        } else {
            return true;
        }
    };

    $scope.isVisibleInner = function(node, nodeParent) {
        if (node && node != null && nodeParent && nodeParent != null) {
            //                return FilteringSvc.showInnerHtml(node, nodeParent);
            return true;
        } else {
            return true;
        }
    };

    $scope.isUsagefiltered = function(node, nodeParent) {
        if ($rootScope.usageF) {
            console.log(nodeParent);
        }
        return true;

    };

    //For Constraints

    $scope.findAllGlobalConstraints = function() {
        $scope.listGlobalConformanceStatements = [];
        $scope.listGlobalPredicates = [];
        $scope.travelMessage($rootScope.message, '');
    };

    $scope.travelMessage = function(current, positionPath) {
        if (current.conformanceStatements && current.conformanceStatements.length > 0) {
            $scope.listGlobalConformanceStatements.push(current);
        }

        if (current.predicates && current.predicates.length > 0) {
            $scope.listGlobalPredicates.push(current);
        }

        if (current.type == 'message' || current.type == 'group') {
            for (var i in current.children) {
                var segGroup = current.children[i];

                if (positionPath == '') {
                    segGroup.positionPath = segGroup.position + '[1]';
                } else {
                    segGroup.positionPath = positionPath + '.' + segGroup.position + '[1]';
                }

                $scope.travelMessage(segGroup, segGroup.positionPath);
            }
        }
    };

    $scope.openPredicateDialog = function(node) {
        if (node.obj.usage == 'C') $scope.openAddGlobalPredicateDialog(node, $rootScope.message);
    };

    $scope.openAddGlobalConformanceStatementDialog = function(message) {
        var modalInstance = $modal.open({
            templateUrl: 'GlobalConformanceStatementCtrl.html',
            controller: 'GlobalConformanceStatementCtrl',
            windowClass: 'app-modal-window',
            keyboard: false,
            resolve: {
                selectedMessage: function() {
                    return message;
                },
            }
        });
        modalInstance.result.then(function(message) {
            if (message) {
                $rootScope.message = message;
                $scope.findAllGlobalConstraints();
                $scope.setDirty();
            }
        }, function() {});
    };

    $scope.openAddGlobalPredicateDialog = function(node, message) {
        var modalInstance = $modal.open({
            templateUrl: 'GlobalPredicateCtrl.html',
            controller: 'GlobalPredicateCtrl',
            windowClass: 'app-modal-window',
            keyboard: false,
            resolve: {
                selectedMessage: function() {
                    return message;
                },
                selectedNode: function() {
                    return node;
                }
            }
        });
        modalInstance.result.then(function(message) {
            if (message) {
                $rootScope.message = message;
                $scope.findAllGlobalConstraints();
                $scope.setDirty();
            }

        }, function() {});
    };

    $scope.countPredicate = function(position) {
        var count = 0
        for (var i = 0, len1 = $scope.listGlobalPredicates.length; i < len1; i++) {
            for (var j = 0, len2 = $scope.listGlobalPredicates[i].predicates.length; j < len2; j++) {
                var positionPath = '';
                if (!$scope.listGlobalPredicates[i].positionPath || $scope.listGlobalPredicates[i].positionPath == '') {
                    positionPath = $scope.listGlobalPredicates[i].predicates[j].constraintTarget;
                } else {
                    positionPath = $scope.listGlobalPredicates[i].positionPath + '.' + $scope.listGlobalPredicates[i].predicates[j].constraintTarget;
                }

                if (positionPath == position) {
                    count = count + 1;
                }
            }
        }
        return count;
    };

    $scope.findPredicateByPath = function(position) {
        for (var i = 0, len1 = $scope.listGlobalPredicates.length; i < len1; i++) {
            for (var j = 0, len2 = $scope.listGlobalPredicates[i].predicates.length; j < len2; j++) {
                var positionPath = '';
                if (!$scope.listGlobalPredicates[i].positionPath || $scope.listGlobalPredicates[i].positionPath == '') {
                    positionPath = $scope.listGlobalPredicates[i].predicates[j].constraintTarget;
                } else {
                    positionPath = $scope.listGlobalPredicates[i].positionPath + '.' + $scope.listGlobalPredicates[i].predicates[j].constraintTarget;
                }

                if (positionPath == position) {
                    return $scope.listGlobalPredicates[i].predicates[j];
                }
            }
        }
        return null;
    };


    $scope.deletePredicateByPath = function(position, message) {
        var modalInstance = $modal.open({
            templateUrl: 'DeleteMessagePredicate.html',
            controller: 'DeleteMessagePredicateCtrl',
            size: 'md',
            resolve: {
                position: function() {
                    return position;
                },
                message: function() {
                    return message;
                }
            }
        });
        modalInstance.result.then(function() {
            $scope.setDirty();
            $scope.findAllGlobalConstraints();
        });
    };

});

angular.module('igl').controller('MessageRowCtrl', function($scope, $filter) {
    $scope.formName = "form_" + new Date().getTime();


    //        $scope.init = function(){
    //            $scope.$watch(function(){
    //            return  $scope.formName.$dirty;
    //        }, function(newValue, oldValue) {
    //            $scope.editForm.$dirty = newValue !=null &&  oldValue != null;
    //        });
    //
    //        }

});

angular.module('igl').controller('SelectSegmentFlavorCtrl', function($scope, $filter, $q, $modalInstance, $rootScope, $http, segmentLibrary, SegmentService, $rootScope, hl7Version, ngTreetableParams, ViewSettings, SegmentLibrarySvc, datatypeLibrary, DatatypeLibrarySvc, currentSegment, TableService) {
    $scope.segmentLibrary = segmentLibrary;
    $scope.datatypeLibrary = datatypeLibrary;
    $scope.resultsError = null;
    $scope.viewSettings = ViewSettings;
    $scope.resultsLoading = null;
    $scope.results = [];
    $scope.tmpResults = [].concat($scope.results);
    $scope.currentSegment = currentSegment;
    $scope.selection = { library: null, scope: null, hl7Version: hl7Version, segment: null, name: $scope.currentSegment != null && $scope.currentSegment ? $scope.currentSegment.name : null, selected: null };


    $scope.segmentFlavorParams = new ngTreetableParams({
        getNodes: function(parent) {
            return SegmentService.getNodes(parent, $scope.selection.segment);
        },
        getTemplate: function(node) {
            return SegmentService.getReadTemplate(node, $scope.selection.segment);
        }
    });

    $scope.loadLibrariesByFlavorName = function() {
        var delay = $q.defer();
        $scope.selection.segment = null;
        $scope.selection.selected = null;
        $scope.resetMap();
        $scope.ext = null;
        $scope.results = [];
        $scope.tmpResults = [];
        $scope.results = $scope.results.concat(filterFlavors($scope.segmentLibrary, $scope.selection.name));
        $scope.tmpResults = [].concat($scope.results);
        SegmentLibrarySvc.findLibrariesByFlavorName($scope.selection.name, 'HL7STANDARD', /*$scope.selection.hl7Version*/ $rootScope.igdocument.profile.metaData.hl7Version).then(function(libraries) {
            if (libraries != null) {
                _.each(libraries, function(library) {
                    $scope.results = $scope.results.concat(filterFlavors(library, $scope.selection.name));
                });
            }

            $scope.results = _.uniq($scope.results, function(item, key, a) {
                return item.id;
            });

            $scope.tmpResults = [].concat($scope.results);

            delay.resolve(true);
        }, function(error) {
            $rootScope.msg().text = "Sorry could not load the segments";
            $rootScope.msg().type = error.data.type;
            $rootScope.msg().show = true;
            delay.reject(error);
        });
        return delay.promise;
    };

    var filterFlavors = function(library, name) {
        var results = [];
        _.each(library.children, function(link) {
            if (link.name === name) {
                link.libraryName = library.metaData.name;
                link.hl7Version = library.metaData.hl7Version;
                results.push(link);
            }
        });
        return results;
    };


    $scope.selectSegment = function(segment) {
        if (segment && segment != null) {
            $scope.loadingSelection = true;
            $scope.selection.segment = segment;
            $scope.selection.segment["type"] = "segment";
        }
    };

    var indexIn = function(id, collection) {
        for (var i = 0; i < collection.length; i++) {
            if (collection[i].id === id) {
                return i;
            }
        }
        return -1;
    };

    var collectNewSegmentAndDatatypesAndTables = function(segment, datatypes) {
        $rootScope.segmentsMap[segment.id] = segment;
        if (indexIn(segment.id, $rootScope.addedSegments) < 0) {
            $rootScope.addedSegments.push(segment);
        }
        var tmpTables = [];
        angular.forEach(datatypes, function(child) {
            if (indexIn(child.id, $rootScope.datatypes) < 0) {
                $rootScope.datatypesMap[child.id] = child;
            }
            if (indexIn(child.id, $rootScope.addedDatatypes) < 0) {
                $rootScope.addedDatatypes.push(child);
            }
            if (indexIn(child.table.id, $rootScope.addedTables) < 0) {
                tmpTables.push(child.table.id);
            }
        });

        if (tmpTables.length > 0) {
            TableService.findAllByIds(tmpTables).then(function(tables) {
                $rootScope.addedTables = $rootScope.addedTables.concat(tables);
                angular.forEach(tables, function(table) {
                    $rootScope.tablesMap[table.id] = table;
                });
                $modalInstance.close($scope.selection.segment);
            }, function(error) {
                $rootScope.msg().text = "Sorry an error occured. Please try again";
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
            });
        } else {
            $modalInstance.close($scope.selection.segment);
        }
    };

    $scope.submit = function() {
        console.log($scope.selection);
        var indexFromLibrary = indexIn($scope.selection.segment.id, $scope.segmentLibrary.children);
        var indexFromCollection = indexIn($scope.selection.segment.id, $rootScope.segments);
        var indexFromMap = $rootScope.segmentsMap[$scope.selection.segment.id] != undefined && $rootScope.segmentsMap[$scope.selection.segment.id] != null ? 100 : -1;
        if (indexFromLibrary < 0 | indexFromCollection < 0 | indexFromMap < 0) {
            SegmentService.get($scope.selection.segment.id).then(function(full) {
                $scope.ext = $scope.selection.segment.ext;
                $scope.selection.segment = full;
                $scope.selection.segment["type"] = "segment";
                SegmentService.collectDatatypes(full.id).then(function(datatypes) {
                    collectNewSegmentAndDatatypesAndTables($scope.selection.segment, datatypes);
                }, function(error) {
                    $scope.loadingSelection = false;
                    $rootScope.msg().text = "Sorry could not load the data type";
                    $rootScope.msg().type = "danger";
                    $rootScope.msg().show = true;
                });
            }, function(error) {
                $scope.resultsLoading = false;
                $rootScope.msg().text = "Sorry could not load the data type";
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
            });
        } else {
            $modalInstance.close($scope.selection.segment);
        }
    };
    $scope.cancel = function() {
        $scope.resetMap();
        $modalInstance.dismiss('cancel');
    };


    $scope.validateLabel = function(label, name) {
        if (label && !label.startsWith(name)) {
            return false;
        }
        return true;
    };

    $scope.findDTByComponentId = function(componentId) {
        return $rootScope.parentsMap && $rootScope.parentsMap[componentId] ? $rootScope.parentsMap[componentId] : null;
    };

    $scope.isSub = function(component) {
        return $scope.isSubDT(component);
    };

    $scope.isSubDT = function(component) {
        return component.type === 'component' && $rootScope.parentsMap && $rootScope.parentsMap[component.id] && $rootScope.parentsMap[component.id].type === 'component';
    };

    $scope.hasChildren = function(node) {
        return node && node != null && ((node.fields && node.fields.length > 0) || (node.datatype && $rootScope.getDatatype(node.datatype.id) && $rootScope.getDatatype(node.datatype.id).components && $rootScope.getDatatype(node.datatype.id).components.length > 0));
    };


    $scope.validateLabel = function(label, name) {
        if (label && !label.startsWith(name)) {
            return false;
        }
        return true;
    };


    $scope.isRelevant = function(node) {
        return SegmentService.isRelevant(node);
    };

    $scope.isBranch = function(node) {
        SegmentService.isBranch(node);
    };

    $scope.isVisible = function(node) {
        return SegmentService.isVisible(node);
    };

    $scope.children = function(node) {
        return SegmentService.getNodes(node);
    };

    $scope.getParent = function(node) {
        return SegmentService.getParent(node);
    };

    $scope.getSegmentLevelConfStatements = function(element) {
        return SegmentService.getSegmentLevelConfStatements(element);
    };

    $scope.getSegmentLevelPredicates = function(element) {
        return SegmentService.getSegmentLevelPredicates(element);
    };


    $scope.isChildSelected = function(component) {
        return $scope.selectedChildren.indexOf(component) >= 0;
    };

    $scope.isChildNew = function(component) {
        return component && component != null && component.status === 'DRAFT';
    };

    var containsId = function(id, library) {
        for (var i = 0; i < library.children.length; i++) {
            if (library.children[i].id === id) {
                return true;
            }
        }
    };

    $scope.resetMap = function() {
        if ($rootScope.addedDatatypes = null) {
            angular.forEach($rootScope.addedDatatypes, function(child) {
                delete $rootScope.datatypesMap[child];
            });
        }
    };

    $scope.getLocalDatatypeLabel = function(link) {
        return link != null ? $rootScope.getLabel(link.name, link.ext) : null;
    };

    $scope.getLocalSegmentLabel = function(link) {
        return link != null ? $rootScope.getLabel(link.name, link.ext) : null;
    };

    $scope.loadLibrariesByFlavorName().then(function(done) {
        $scope.selection.selected = $scope.currentSegment.id;
        $scope.selectSegment($scope.currentSegment);
    });

});

angular.module('igl').controller('MessageViewCtrl', function($scope, $rootScope, Restangular) {
    $scope.loading = false;
    $scope.msg = null;
    $scope.messageData = [];
    $scope.setData = function(node) {
        if (node) {
            if (node.type === 'message') {
                angular.forEach(node.children, function(segmentRefOrGroup) {
                    $scope.setData(segmentRefOrGroup);
                });
            } else if (node.type === 'group') {
                $scope.messageData.push({ name: "-- " + node.name + " begin" });
                if (node.children) {
                    angular.forEach(node.children, function(segmentRefOrGroup) {
                        $scope.setData(segmentRefOrGroup);
                    });
                }
                $scope.messageData.push({ name: "-- " + node.name + " end" });
            } else if (node.type === 'segment') {
                $scope.messageData.push + (node);
            }
        }
    };


    $scope.init = function(message) {
        $scope.loading = true;
        $scope.msg = message;
        console.log(message.id);
        $scope.setData($scope.msg);
        $scope.loading = false;
    };

    //        $scope.hasChildren = function (node) {
    //            return node && node != null && node.type !== 'segment' && node.children && node.children.length > 0;
    //        };

});

angular.module('igl').controller('ConfirmMessageDeleteCtrl', function($scope, $modalInstance, messageToDelete, $rootScope, MessagesSvc, IgDocumentService, CloneDeleteSvc) {
    $scope.messageToDelete = messageToDelete;
    $scope.loading = false;
    $scope.delete = function() {
        $scope.loading = true;
        IgDocumentService.deleteMessage($rootScope.igdocument.id, $scope.messageToDelete.id).then(function(res) {
            MessagesSvc.delete($scope.messageToDelete).then(function(result) {
                // We must delete from two collections.
                //CloneDeleteSvc.execDeleteMessage($scope.messageToDelete);
                if ($rootScope.messages.children) {
                    var index = MessagesSvc.findOneChild($scope.messageToDelete.id, $rootScope.messages.children);
                    if (index >= 0) {
                        $rootScope.messages.children.splice(index, 1);
                    }
                }

                var tmp = MessagesSvc.findOneChild($scope.messageToDelete.id, $rootScope.igdocument.profile.messages.children);
                if (tmp != null) {
                    var index = $rootScope.igdocument.profile.messages.children.indexOf(tmp);
                    if (index >= 0) {
                        $rootScope.igdocument.profile.messages.children.splice(index, 1);
                    }
                }

                $rootScope.messagesMap[$scope.messageToDelete.id] = null;
                $rootScope.references = [];
                if ($rootScope.message != null && $rootScope.message.id === $scope.messageToDelete.id) {
                    $rootScope.message = null;
                }
                $rootScope.msg().text = "messageDeleteSuccess";
                $rootScope.msg().type = "success";
                $rootScope.msg().show = true;
                $rootScope.manualHandle = true;
                $scope.loading = false;
                $modalInstance.close($scope.messageToDelete);
            }, function(error) {
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = "danger";
                $rootScope.msg().show = true;
                $rootScope.manualHandle = true;
                $scope.loading = false;
            });
        }, function(error) {
            $rootScope.msg().text = error.data.text;
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;
            $rootScope.manualHandle = true;
            $scope.loading = false;
        });
    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


});

angular.module('igl').controller('AddSegmentCtrl', function($scope, $modalInstance, segments, place, $rootScope, $http, ngTreetableParams, SegmentService, MessageService, blockUI) {
    $scope.segmentParent = place;
    //console.log(place);


    // $scope.segmentss = result.filter(function(current) {
    //     return segments.filter(function(current_b) {
    //         return current_b.id == current.id;
    //     }).length == 0
    // });

    $scope.newSegment = {
        accountId: null,
        comment: "",
        conformanceStatements: [],
        date: null,
        hl7Version: null,
        id: "",
        libIds: [],
        max: "",
        min: "",
        participants: [],
        position: "",
        predicates: [],
        ref: {
            ext: null,
            id: "",
            label: "",
            name: ""
        },
        scope: null,
        status: null,
        type: "segmentRef",
        usage: "",
        version: null

    };
    $scope.$watch('newSeg', function() {
        if ($scope.newSeg) {
            $scope.newSegment.id = new ObjectId().toString();
            $scope.newSegment.ref.ext = $scope.newSeg.ext;
            $scope.newSegment.ref.id = $scope.newSeg.id;
            $scope.newSegment.ref.name = $scope.newSeg.name;

            if (place.type === "message") {

                $scope.newSegment.position = place.children[place.children.length - 1].position + 1;
            } else if (place.obj && place.obj.type === "group") {
                if (place.children.length !== 0) {

                    $scope.newSegment.position = place.children[place.children.length - 1].obj.position + 1;

                } else {
                    $scope.newSegment.position = 1;
                }

            }

        }

    }, true);
    $scope.isInSegs = function(segment) {
        console.log(segment);
        console.log(segments.indexOf(segment));
        if (segment && segments.indexOf(segment) === -1) {
            return false;
        } else {
            return true;
        }

    };
    $scope.selectUsage = function(usage) {
        console.log(usage);
        if (usage === 'X' || usage === 'W') {
            $scope.newSegment.max = 0;
            $scope.newSegment.min = 0;
            $scope.disableMin = true;
            $scope.disableMax = true;

        } else if (usage === 'R') {
            $scope.newSegment.min = 1;

            $scope.disableMin = true;
            $scope.disableMax = false;
        } else if (usage === 'RE' || usage === 'O') {
            $scope.newSegment.min = 0;

            $scope.disableMin = true;
            $scope.disableMax = false;

        } else {
            $scope.disableMin = false;
            $scope.disableMax = false;

        }

    };
    $scope.selectSeg = function(segment) {
        $scope.newSeg = segment;
    };
    $scope.selected = function() {
        return ($scope.newSeg !== undefined);
    };
    $scope.unselect = function() {
        $scope.newSeg = undefined;
    };
    $scope.isActive = function(id) {
        if ($scope.newSeg) {
            return $scope.newSeg.id === id;
        } else {
            return false;
        }
    };


    $scope.addSegment = function() {
        blockUI.start();
        if (place.type === "message") {


            $rootScope.message.children.push($scope.newSegment);
            MessageService.updatePosition(place.children, $scope.newSegment.position - 1, $scope.position - 1);

        } else if (place.obj && place.obj.type === "group") {

            $scope.path = place.path.replace(/\[[0-9]+\]/g, '');
            $scope.path = $scope.path.split(".");

            MessageService.addSegToPath($scope.path, $rootScope.message, $scope.newSegment, $scope.newSegment.position - 1, $scope.position - 1);
        }




        $rootScope.messageTree = null;
        $rootScope.processMessageTree($rootScope.message);
        //console.log($rootScope.messageTree);

        if ($scope.messagesParams) {
            $scope.messagesParams.refresh();
        }
        blockUI.stop();
        $modalInstance.close();

    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


});

angular.module('igl').controller('AddGroupCtrl', function($scope, $modalInstance, segments, place, $rootScope, $http, ngTreetableParams, SegmentService, MessageService, blockUI) {
    $scope.groupParent = place;

    $scope.newGroup = {
        accountId: null,
        children: [],
        comment: "",
        conformanceStatements: [],
        date: null,
        hl7Version: null,
        id: "",
        libIds: [],
        max: "",
        min: "",
        name: "",
        participants: [],
        position: "",
        predicates: [],
        scope: null,
        status: null,
        type: "group",
        usage: "",
        version: null

    };
    $scope.selectUsage = function(usage) {
        console.log(usage);
        if (usage === 'X' || usage === 'W') {
            $scope.newGroup.max = 0;
            $scope.newGroup.min = 0;
            $scope.disableMin = true;
            $scope.disableMax = true;

        } else if (usage === 'R') {
            $scope.newGroup.min = 1;

            $scope.disableMin = true;
            $scope.disableMax = false;
        } else if (usage === 'RE' || usage === 'O') {
            $scope.newGroup.min = 0;

            $scope.disableMin = true;
            $scope.disableMax = false;

        } else {
            $scope.disableMin = false;
            $scope.disableMax = false;

        }

    };


    $scope.addGroup = function() {
        blockUI.start();

        $scope.newGroup.id = new ObjectId().toString();
        $scope.newGroup.name = $scope.grpName;
        if (place.children.length !== 0) {
            if (place.type === "message") {
                $scope.newGroup.position = place.children[place.children.length - 1].position + 1;


            } else {
                $scope.newGroup.position = place.children[place.children.length - 1].obj.position + 1;

            }

        } else {
            $scope.newGroup.position = 1;
        }


        if (place.type === "message") {
            $rootScope.message.children.push($scope.newGroup);
            MessageService.updatePosition(place.children, $scope.newGroup.position - 1, $scope.position - 1);

        } else if (place.obj && place.obj.type === "group") {
            $scope.path = place.path.replace(/\[[0-9]+\]/g, '');
            $scope.path = $scope.path.split(".");

            MessageService.addSegToPath($scope.path, $rootScope.message, $scope.newGroup, $scope.newGroup.position - 1, $scope.position - 1);

            //place.children.push($scope.newSegment);
        }


        $rootScope.messageTree = null;
        $rootScope.processMessageTree($rootScope.message);
        //console.log($rootScope.messageTree);

        if ($scope.messagesParams) {
            $scope.messagesParams.refresh();
        }
        blockUI.stop();
        $modalInstance.close();


    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


});

angular.module('igl').controller('DeleteSegmentRefOrGrpCtrl', function($scope, $modalInstance, segOrGrpToDelete, $rootScope, MessageService, blockUI) {
    $scope.segOrGrpToDelete = segOrGrpToDelete;
    $scope.loading = false;
    $scope.updatePosition = function(node) {
        angular.forEach(node.children, function(child) {
            child.position = node.children.indexOf(child) + 1;

        })

    };
    $scope.delete = function() {
        $scope.loading = true;
        blockUI.start();
        $scope.path = segOrGrpToDelete.path.replace(/\[[0-9]+\]/g, '');
        $scope.path = $scope.path.split(".");
        MessageService.deleteSegFromPath($scope.path, $rootScope.message).then(function() {
            if (segOrGrpToDelete.obj.type === 'group') {
                $rootScope.msg().text = "GrpDeleteSuccess";
            } else {
                $rootScope.msg().text = "SegmentRefDeleteSuccess";
            }


            $rootScope.msg().type = "success";
            $rootScope.msg().show = true;
            $rootScope.manualHandle = true;
            $scope.loading = false;
            $scope.updatePosition($rootScope.parentGroup);
            $rootScope.messageTree = null;
            $rootScope.processMessageTree($rootScope.message);
            blockUI.stop();
            $modalInstance.close($scope.segOrGrpToDelete);
        }, function(error) {
            $rootScope.msg().text = error.data.text;
            $rootScope.msg().type = "danger";
            $rootScope.msg().show = true;
            $rootScope.manualHandle = true;
            $scope.loading = false;
            blockUI.stop();
        });


    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


});

angular.module('igl').controller('OtoXCtrl', function($scope, $modalInstance, message, $rootScope, blockUI) {
    console.log(message);
    $scope.message = message;
    $scope.loading = false;

    $scope.confirm = function(message) {
        $scope.loading = true;
        blockUI.start();
        if ($scope.message.type === 'message') {
            for (var node = 0; node < message.children.length; node++) {
                if (message.children[node].usage === "O") {
                    message.children[node].usage = "X";
                    message.children[node].max = 0;
                    message.children[node].min = 0;

                }
                if (message.children[node].type === "group") {

                    $scope.confirm(message.children[node])
                }

            }
        } else if ($scope.message.type === 'segment') {
            for (var node = 0; node < message.fields.length; node++) {
                if (message.fields[node].usage === "O") {
                    message.fields[node].usage = "X";
                    message.fields[node].max = 0;
                    message.fields[node].min = 0;

                }




            }
        } else if ($scope.message.type === 'datatype') {
            for (var node = 0; node < message.components.length; node++) {
                if (message.components[node].usage === "O") {
                    message.components[node].usage = "X";
                    message.components[node].max = 0;
                    message.components[node].min = 0;

                }




            }
        }

        $rootScope.msg().text = "OtoXSuccess";
        $rootScope.msg().type = "success";
        $rootScope.msg().show = true;
        $rootScope.manualHandle = true;
        $scope.loading = false;
        $rootScope.messageTree = null;
        $rootScope.processMessageTree($rootScope.message);
        blockUI.stop();
        $modalInstance.close($scope.message);
    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


});

angular.module('igl').controller('redirectCtrl', function($scope, $modalInstance, destination, $rootScope) {
    $scope.destination = destination;
    $scope.loading = false;

    $scope.confirm = function() {


        $modalInstance.close($scope.destination);



    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


});

angular.module('igl').controller('cmpMessageCtrl', function($scope, $modal, ObjectDiff, orderByFilter, $rootScope, $q, $interval, ngTreetableParams, $http, StorageService, userInfoService, IgDocumentService, SegmentService, DatatypeService, SegmentLibrarySvc, DatatypeLibrarySvc, TableLibrarySvc, CompareService) {

    $scope.msgChanged = false;
    var ctrl = this;
    this.messageId = -1;

    $scope.isDeltaCalled = false;
    $scope.setDeltaToF = function() {
        $scope.isDeltaCalled = false;
    }


    $scope.scopes = [{
        name: "USER",
        alias: "My IG"
    }, {
        name: "HL7STANDARD",
        alias: "Base HL7"
    }];
    var listHL7Versions = function() {
        return $http.get('api/igdocuments/findVersions', {
            timeout: 60000
        }).then(function(response) {
            var hl7Versions = [];
            var length = response.data.length;
            for (var i = 0; i < length; i++) {
                hl7Versions.push(response.data[i]);
            }
            return hl7Versions;
        });
    };

    var init = function() {
        $scope.isDeltaCalled = true;
        $rootScope.deltaMsgList = [];
        ctrl.messageId = -1;
        $scope.message1 = angular.copy($rootScope.message);
        $scope.version1 = angular.copy($rootScope.igdocument.profile.metaData.hl7Version);

        $scope.scope1 = "USER";
        $scope.ig1 = angular.copy($rootScope.igdocument.metaData.title);
        $scope.segList1 = angular.copy($rootScope.segments);
        $scope.dtList1 = angular.copy($rootScope.datatypes);
        $scope.version2 = angular.copy($scope.version1);
        console.log($scope.scopes);
        console.log($scope.scopes[1]);
        $scope.scope2 = "HL7STANDARD";
        listHL7Versions().then(function(versions) {

            $scope.versions = versions;

            if ($scope.dynamicMsg_params) {
                $scope.showDelta = true;
                $scope.status.isFirstOpen = true;
                $scope.dynamicMsg_params.refresh();
            }

        });
    };

    $scope.$on('event:loginConfirmed', function(event) {
        init();
    });
    $rootScope.$on('event:initMessage', function(event) {

        if ($scope.isDeltaCalled) {
            init();
        }
    });
    $rootScope.$on('event:openMsgDelta', function(event) {
        init();
    });

    //init();


    $scope.status = {
        isCustomHeaderOpen: false,
        isFirstOpen: true,
        isSecondOpen: true,
        isFirstDisabled: false
    };


    $scope.setVersion2 = function(vr) {
        $scope.version2 = vr;

    };
    $scope.setScope2 = function(scope) {

        $scope.scope2 = scope;
    };

    $scope.$watchGroup(['message1', 'message2'], function() {
        $scope.msgChanged = true;


    }, true);
    $scope.$watchGroup(['version2', 'scope2'], function() {
        $scope.igList2 = [];
        $scope.messages2 = [];
        $scope.ig2 = "";
        console.log("==============");
        if ($scope.scope2 && $scope.version2) {
            IgDocumentService.getIgDocumentsByScopesAndVersion([$scope.scope2], $scope.version2).then(function(result) {
                if (result) {
                    if ($scope.scope2 === "HL7STANDARD") {
                        $scope.igDisabled2 = true;
                        $scope.ig2 = {
                            id: result[0].id,
                            title: result[0].metaData.title
                        };
                        console.log($scope.ig2);
                        $scope.igList2.push($scope.ig2);
                        $scope.setIG2($scope.ig2);
                    } else {
                        $scope.igDisabled2 = false;
                        for (var i = 0; i < result.length; i++) {
                            $scope.igList2.push({
                                id: result[i].id,
                                title: result[i].metaData.title,
                            });
                        }
                    }
                }
            });

        }

    }, true);

    $scope.setMsg2 = function(msg) {

        if (msg === -1) {
            $scope.message2 = {};
        } else {
            $scope.message2 = $scope.messages2[msg];
            console.log($scope.message2);

        }
        //$scope.segment2 = segment;
    };
    $scope.setIG2 = function(ig) {
        if (ig) {
            IgDocumentService.getOne(ig.id).then(function(igDoc) {
                SegmentLibrarySvc.getSegmentsByLibrary(igDoc.profile.segmentLibrary.id).then(function(segments) {
                    DatatypeLibrarySvc.getDatatypesByLibrary(igDoc.profile.datatypeLibrary.id).then(function(datatypes) {
                        TableLibrarySvc.getTablesByLibrary(igDoc.profile.tableLibrary.id).then(function(tables) {
                            $scope.messages2 = [];
                            $scope.msg2 = "";
                            if (igDoc) {
                                $scope.segList2 = angular.copy(segments);
                                //$scope.segList2 = orderByFilter($scope.segList2, 'name');
                                $scope.dtList2 = angular.copy(datatypes);
                                $scope.tableList2 = angular.copy(tables);
                                $scope.messages2 = orderByFilter(igDoc.profile.messages.children, 'name');
                                $scope.segments2 = orderByFilter(segments, 'name');
                                $scope.datatypes2 = orderByFilter(datatypes, 'name');
                                $scope.tables2 = orderByFilter(tables, 'bindingIdentifier');
                            }
                        });
                    });
                });

            });

            //$scope.messages2 = ($scope.findIGbyID(JSON.parse(ig).id)).profile.messages.children;

        }

    };

    $scope.hideMsg = function(msg1, msg2) {

        if (msg2) {
            return !(msg1.structID === msg2.structID);
        } else {
            return false;
        }
    };
    $scope.disableMsg = function(msg1, msg2) {

        if (msg2) {
            return (msg1.id === msg2.id);
        } else {
            return false;
        }
    };




    $scope.dynamicMsg_params = new ngTreetableParams({
        getNodes: function(parent) {
            if ($rootScope.deltaMsgList !== undefined) {

                //return parent ? parent.fields : $scope.test;
                if (parent) {
                    if (parent.fields) {
                        return parent.fields;
                    } else if (parent.components) {
                        return parent.components;
                    } else if (parent.segments) {
                        return parent.segments;
                    } else if (parent.codes) {
                        return parent.codes;
                    }

                } else {
                    return $rootScope.deltaMsgList;
                }

            }
        },
        getTemplate: function(node) {
            return 'tree_node';
        }
    });

    $scope.cmpMessage = function(msg1, msg2) {
        $rootScope.deltaMap = {};
        $scope.loadingSelection = true;
        $scope.msgChanged = false;
        $scope.vsTemplate = false;
        $scope.loadingSelection = false;
        $rootScope.deltaMsgList = CompareService.cmpMessage(JSON.stringify(msg1), JSON.stringify(msg2), $scope.dtList1, $scope.dtList2, $scope.segList1, $scope.segList2);
        //$scope.dataList = result;
        console.log($rootScope.deltaMsgList);

        if ($scope.dynamicMsg_params) {
            console.log($rootScope.deltaMsgList);
            $scope.showDelta = true;
            $scope.status.isSecondOpen = true;
            $scope.dynamicMsg_params.refresh();
        }
    };
});

angular.module('igl').controller('GlobalPredicateCtrl', function($scope, $modalInstance, selectedMessage, selectedNode, $rootScope, $q) {
    $scope.selectedMessage = angular.copy(selectedMessage);
    $scope.selectedMessage.pathInfoSet = [];
    $scope.selectedNode = selectedNode;
    $scope.constraints = [];
    $scope.firstConstraint = null;
    $scope.secondConstraint = null;
    $scope.compositeType = null;
    $scope.complexConstraint = null;
    $scope.newComplexConstraintId = null;
    $scope.targetContext = null;
    $scope.treeDataForMessage = [];
    $scope.constraintType = 'Plain';
    $scope.firstNodeData = null;
    $scope.secondNodeData = null;
    $scope.changed = false;
    $scope.treeDataForMessage.push($scope.selectedMessage);
    $scope.draggingStatus = null;
    $scope.listGlobalPredicates = [];
    $scope.existingPredicate = null;
    $scope.existingContext = null;
    $scope.tempPredicates = [];
    $scope.predicateData = null;
    $scope.contextKey = null;

    $scope.setChanged = function() {
        $scope.changed = true;
    };

    $scope.toggleChildren = function(data) {
        data.childrenVisible = !data.childrenVisible;
        data.folderClass = data.childrenVisible ? "fa-minus" : "fa-plus";
    };

    $scope.beforePredicateDrop = function() {
        var deferred = $q.defer();

        if ($scope.draggingStatus === 'PredicateDragging') {
            $scope.predicateData = null;
            deferred.resolve();
        } else {
            deferred.reject();
        }
        return deferred.promise;
    };

    $scope.beforeNodeDrop = function() {
        var deferred = $q.defer();
        if ($scope.draggingStatus === 'ContextTreeNodeDragging') {
            deferred.resolve();
        } else {
            deferred.reject();
        }
        return deferred.promise;
    };

    $scope.afterPredicateDrop = function() {
        $scope.draggingStatus = null;
        $scope.existingPredicate = $scope.predicateData;
        $scope.existingContext = $scope.selectedContextNode;
        if (!$scope.existingContext.positionPath || $scope.existingContext.positionPath == '') {
            $scope.existingPredicate.constraintTarget = $scope.selectedNode.path;
        } else {
            $scope.existingPredicate.constraintTarget = $scope.selectedNode.path.replace($scope.existingContext.positionPath + '.', '');
        }
    };

    $scope.selectContext = function(selectedContextNode) {
        $scope.contextKey = new ObjectId().toString();
        $scope.selectedContextNode = selectedContextNode;
        $scope.selectedContextNode.pathInfoSet = [];
        $scope.generatePathInfo($scope.selectedContextNode, ".", ".", "1", false, null, $scope.contextKey);
        $scope.initPredicate();
        $scope.initComplexPredicate();
        $scope.tempPredicates = [];
    };

    $scope.afterNodeDrop = function() {
        $scope.draggingStatus = null;
        $scope.newConstraint.pathInfoSet_1 = $scope.firstNodeData.pathInfoSet;
        $scope.generateFirstPositionAndLocationPath();
    };

    $scope.afterSecondNodeDrop = function() {
        $scope.draggingStatus = null;
        $scope.newConstraint.pathInfoSet_2 = $scope.secondNodeData.pathInfoSet;
        $scope.generateSecondPositionAndLocationPath();
    };

    $scope.generateFirstPositionAndLocationPath = function() {
        if ($scope.newConstraint.pathInfoSet_1) {
            var positionPath = '';
            var locationPath = '';
            for (var i in $scope.newConstraint.pathInfoSet_1) {
                if (i > 0) {
                    var pathInfo = $scope.newConstraint.pathInfoSet_1[i];
                    positionPath = positionPath + "." + pathInfo.positionNumber + "[" + pathInfo.instanceNumber + "]";
                    locationPath = locationPath + "." + pathInfo.locationName + "[" + pathInfo.instanceNumber + "]";

                    if (i == $scope.newConstraint.pathInfoSet_1.length - 1) {
                        locationPath = locationPath + " (" + pathInfo.nodeName + ")";
                    }
                }
            }

            $scope.newConstraint.position_1 = positionPath.substr(1);
            $scope.newConstraint.location_1 = locationPath.substr(1);
        }
    }

    $scope.generateSecondPositionAndLocationPath = function() {
        if ($scope.newConstraint.pathInfoSet_2) {
            var positionPath = '';
            var locationPath = '';
            for (var i in $scope.newConstraint.pathInfoSet_2) {
                if (i > 0) {
                    var pathInfo = $scope.newConstraint.pathInfoSet_2[i];
                    positionPath = positionPath + "." + pathInfo.positionNumber + "[" + pathInfo.instanceNumber + "]";
                    locationPath = locationPath + "." + pathInfo.locationName + "[" + pathInfo.instanceNumber + "]";

                    if (i == $scope.newConstraint.pathInfoSet_2.length - 1) {
                        locationPath = locationPath + " (" + pathInfo.nodeName + ")";
                    }
                }
            }

            $scope.newConstraint.position_2 = positionPath.substr(1);
            $scope.newConstraint.location_2 = locationPath.substr(1);
        }
    }

    $scope.draggingPredicate = function(event, ui, nodeData) {
        $scope.draggingStatus = 'PredicateDragging';
    };

    $scope.draggingNodeFromContextTree = function(event, ui, nodeData) {
        $scope.draggingStatus = 'ContextTreeNodeDragging';
    };

    $scope.generatePathInfo = function(current, positionNumber, locationName, instanceNumber, isInstanceNumberEditable, nodeName, key) {
        var pathInfo = {};
        pathInfo.positionNumber = positionNumber;
        pathInfo.locationName = locationName;
        pathInfo.nodeName = nodeName;
        pathInfo.instanceNumber = instanceNumber;
        pathInfo.isInstanceNumberEditable = isInstanceNumberEditable;
        current.pathInfoSet.push(pathInfo);
        current.contextKey = key;

        if (current.type == 'message' || current.type == 'group') {
            for (var i in current.children) {
                var segGroup = current.children[i];
                segGroup.pathInfoSet = angular.copy(current.pathInfoSet);
                var childPositionNumber = segGroup.position;
                var childLocationName = '';
                var childNodeName = '';
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                if (segGroup.max != '1') {
                    childInstanceNumber = '*';
                    childisInstanceNumberEditable = true;
                }
                if (segGroup.type == 'group') {
                    childNodeName = segGroup.name;
                    childLocationName = segGroup.name.substr(segGroup.name.lastIndexOf('.') + 1);
                } else {
                    var s = angular.copy($rootScope.segmentsMap[segGroup.ref.id]);
                    s.id = new ObjectId().toString();
                    childLocationName = s.name;
                    childNodeName = s.name;
                    segGroup.segment = s;
                }
                $scope.generatePathInfo(segGroup, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName, key);
            }
        } else if (current.type == 'segmentRef') {
            var seg = current.segment;
            for (var i in seg.fields) {
                var f = seg.fields[i];
                f.pathInfoSet = angular.copy(current.pathInfoSet);

                var childPositionNumber = f.position;
                var childLocationName = f.position;
                var childNodeName = f.name;
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                if (f.max != '1') {
                    childInstanceNumber = '*';
                    childisInstanceNumberEditable = true;
                }
                var child = angular.copy($rootScope.datatypesMap[f.datatype.id]);
                child.id = new ObjectId().toString();
                f.child = child;
                $scope.generatePathInfo(f, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName, key);
            }
        } else if (current.type == 'field' || current.type == 'component') {
            var dt = current.child;
            for (var i in dt.components) {
                var c = dt.components[i];
                c.pathInfoSet = angular.copy(current.pathInfoSet);
                var childPositionNumber = c.position;
                var childLocationName = c.position;
                var childNodeName = c.name;
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                var child = angular.copy($rootScope.datatypesMap[c.datatype.id]);
                child.id = new ObjectId().toString();
                c.child = child;
                $scope.generatePathInfo(c, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName, key);
            }
        }
    };

    $scope.initComplexPredicate = function() {
        $scope.constraints = [];
        $scope.firstConstraint = null;
        $scope.secondConstraint = null;
        $scope.compositeType = null;
    }

    $scope.initPredicate = function() {
        $scope.newConstraint = angular.fromJson({
            pathInfoSet_1: null,
            pathInfoSet_2: null,
            position_1: null,
            position_2: null,
            location_1: null,
            location_2: null,
            freeText: null,
            verb: null,
            ignoreCase: false,
            constraintId: null,
            contraintType: null,
            value: null,
            value2: null,
            valueSetId: null,
            bindingStrength: 'R',
            bindingLocation: '1',
            trueUsage: null,
            falseUsage: null,
        });
    };

    $scope.addFreeTextPredicate = function() {
        var cp = $rootScope.generateFreeTextPredicate('NOT Assigned', $scope.newConstraint);
        $scope.tempPredicates.push(cp);
        $scope.initPredicate();
    };

    $scope.addPredicate = function() {
        var cp = $rootScope.generatePredicate('NOT Assigned', $scope.newConstraint);
        $scope.tempPredicates.push(cp);
        $scope.initPredicate();
    };

    $scope.addComplexPredicate = function() {
        $scope.complexConstraint = $rootScope.generateCompositePredicate($scope.compositeType, $scope.firstConstraint, $scope.secondConstraint, $scope.constraints);
        $scope.tempPredicates.push($scope.complexConstraint);
        $scope.initComplexPredicate();
    };

    $scope.deletePredicate = function() {
        $scope.existingPredicate = null;
        $scope.existingContext = null;
        $scope.setChanged();
    };

    $scope.deleteTempPredicate = function(predicate) {
        $scope.tempPredicates.splice($scope.tempPredicates.indexOf(predicate), 1);
    };

    $scope.cancel = function() {
        $modalInstance.dismiss();
    };

    $scope.saveclose = function() {
        $scope.deleteExistingPredicate($scope.selectedMessage);

        if ($scope.existingPredicate != null) {
            $scope.addChangedPredicate($scope.selectedMessage);
        }

        $rootScope.recordChanged();
        $modalInstance.close($scope.selectedMessage);
    };

    $scope.addChangedPredicate = function(current) {
        console.log("----------------------------------");
        console.log("CurrentPATH::::" + current.positionPath);
        console.log($scope.existingContext.positionPath);
        if (current.positionPath == $scope.existingContext.positionPath) {
            console.log($scope.existingPredicate);
            current.predicates.push($scope.existingPredicate);
        }

        if (current.type == 'message' || current.type == 'group') {
            for (var i in current.children) {
                $scope.addChangedPredicate(current.children[i]);
            }
        }
    }

    $scope.deleteExistingPredicate = function(current) {
        if (current.predicates && current.predicates.length > 0) {
            var toBeDeletePredicate = null;
            for (var i in current.predicates) {
                var positionPath = null;
                if (current.positionPath == null || current.positionPath == '') {
                    var positionPath = current.predicates[i].constraintTarget;
                } else {
                    var positionPath = current.positionPath + '.' + current.predicates[i].constraintTarget;
                }
                if (positionPath == $scope.selectedNode.path) {
                    toBeDeletePredicate = i;
                }
            }
            if (toBeDeletePredicate != null) current.predicates.splice(toBeDeletePredicate, 1);
        }
        if (current.type == 'message' || current.type == 'group') {
            for (var i in current.children) {
                $scope.deleteExistingPredicate(current.children[i]);
            }
        }
    };

    $scope.findAllGlobalPredicates = function() {
        $scope.listGlobalPredicates = [];
        $scope.travelMessage($scope.selectedMessage, '');
    };

    $scope.travelMessage = function(current, parrentPositionPath) {
        if (current.predicates && current.predicates.length > 0) {
            $scope.listGlobalPredicates.push(current);

            for (var i in current.predicates) {
                var positionPath = null;
                if (current.positionPath == null || current.positionPath == '') {
                    var positionPath = current.predicates[i].constraintTarget;
                } else {
                    var positionPath = current.positionPath + '.' + current.predicates[i].constraintTarget;
                }
                if (positionPath == $scope.selectedNode.path) {
                    $scope.existingPredicate = current.predicates[i];
                    $scope.existingContext = current;
                }
            }
        }

        if (current.type == 'message' || current.type == 'group') {
            for (var i in current.children) {
                var segGroup = current.children[i];

                if (parrentPositionPath == '') {
                    segGroup.positionPath = segGroup.position + '[1]';
                } else {
                    segGroup.positionPath = parrentPositionPath + '.' + segGroup.position + '[1]';
                }

                $scope.travelMessage(segGroup, segGroup.positionPath);
            }
        }
    };

    $scope.initPredicate();
    $scope.initComplexPredicate();
    $scope.findAllGlobalPredicates();
    $scope.generatePathInfo($scope.selectedMessage, ".", ".", "1", false, null, 'default');

});

angular.module('igl').controller('GlobalConformanceStatementCtrl', function($scope, $modalInstance, selectedMessage, $rootScope, $q) {
    $scope.selectedMessage = angular.copy(selectedMessage);
    $scope.constraints = [];
    $scope.firstConstraint = null;
    $scope.secondConstraint = null;
    $scope.compositeType = null;
    $scope.complexConstraint = null;
    $scope.newComplexConstraintId = null;
    $scope.selectedContextNode = null;
    $scope.treeDataForMessage = [];
    $scope.constraintType = 'Plain';
    $scope.firstNodeData = null;
    $scope.secondNodeData = null;
    $scope.changed = false;
    $scope.selectedMessage.pathInfoSet = [];
    $scope.treeDataForMessage.push($scope.selectedMessage);
    $scope.draggingStatus = null;
    $scope.contextKey = null;

    $scope.setChanged = function() {
        $scope.changed = true;
    };

    $scope.toggleChildren = function(data) {
        data.childrenVisible = !data.childrenVisible;
        data.folderClass = data.childrenVisible ? "fa-minus" : "fa-plus";
    };

    $scope.beforeNodeDrop = function() {
        var deferred = $q.defer();
        if ($scope.draggingStatus === 'MessageTreeNodeDragging') {
            deferred.resolve();
        } else {
            deferred.reject();
        }
        return deferred.promise;
    };

    $scope.afterNodeDrop = function() {
        $scope.draggingStatus = null;
        $scope.newConstraint.pathInfoSet_1 = $scope.firstNodeData.pathInfoSet;
        $scope.generateFirstPositionAndLocationPath();
    };

    $scope.afterSecondNodeDrop = function() {
        $scope.draggingStatus = null;
        $scope.newConstraint.pathInfoSet_2 = $scope.secondNodeData.pathInfoSet;
        $scope.generateSecondPositionAndLocationPath();
    };

    $scope.draggingNodeFromContextTree = function(event, ui, nodeData) {
        $scope.draggingStatus = 'MessageTreeNodeDragging';
    };


    $scope.selectContext = function(selectedContextNode) {
        $scope.contextKey = new ObjectId().toString();
        $scope.selectedContextNode = selectedContextNode;
        $scope.selectedContextNode.pathInfoSet = [];
        $scope.generatePathInfo($scope.selectedContextNode, ".", ".", "1", false, null, $scope.contextKey);
        $scope.initConformanceStatement();
    };



    $scope.generateFirstPositionAndLocationPath = function() {
        if ($scope.newConstraint.pathInfoSet_1) {
            var positionPath = '';
            var locationPath = '';
            for (var i in $scope.newConstraint.pathInfoSet_1) {
                if (i > 0) {
                    var pathInfo = $scope.newConstraint.pathInfoSet_1[i];
                    positionPath = positionPath + "." + pathInfo.positionNumber + "[" + pathInfo.instanceNumber + "]";
                    locationPath = locationPath + "." + pathInfo.locationName + "[" + pathInfo.instanceNumber + "]";

                    if (i == $scope.newConstraint.pathInfoSet_1.length - 1) {
                        locationPath = locationPath + " (" + pathInfo.nodeName + ")";
                    }
                }
            }

            $scope.newConstraint.position_1 = positionPath.substr(1);
            $scope.newConstraint.location_1 = locationPath.substr(1);
        }
    };

    $scope.generateSecondPositionAndLocationPath = function() {
        if ($scope.newConstraint.pathInfoSet_2) {
            var positionPath = '';
            var locationPath = '';
            for (var i in $scope.newConstraint.pathInfoSet_2) {
                if (i > 0) {
                    var pathInfo = $scope.newConstraint.pathInfoSet_2[i];
                    positionPath = positionPath + "." + pathInfo.positionNumber + "[" + pathInfo.instanceNumber + "]";
                    locationPath = locationPath + "." + pathInfo.locationName + "[" + pathInfo.instanceNumber + "]";

                    if (i == $scope.newConstraint.pathInfoSet_2.length - 1) {
                        locationPath = locationPath + " (" + pathInfo.nodeName + ")";
                    }
                }
            }

            $scope.newConstraint.position_2 = positionPath.substr(1);
            $scope.newConstraint.location_2 = locationPath.substr(1);
        }
    };

    $scope.draggingNodeFromMessageTree = function(event, ui, nodeData) {
        $scope.draggingStatus = 'MessageTreeNodeDragging';
    };

    $scope.generatePathInfo = function(current, positionNumber, locationName, instanceNumber, isInstanceNumberEditable, nodeName, key) {
        var pathInfo = {};
        pathInfo.positionNumber = positionNumber;
        pathInfo.locationName = locationName;
        pathInfo.nodeName = nodeName;
        pathInfo.instanceNumber = instanceNumber;
        pathInfo.isInstanceNumberEditable = isInstanceNumberEditable;
        current.contextKey = key;
        current.pathInfoSet.push(pathInfo);

        if (current.type == 'message' || current.type == 'group') {
            for (var i in current.children) {
                var segGroup = current.children[i];
                segGroup.pathInfoSet = angular.copy(current.pathInfoSet);
                var childPositionNumber = segGroup.position;
                var childLocationName = '';
                var childNodeName = '';
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                if (segGroup.max != '1') {
                    childInstanceNumber = '*';
                    childisInstanceNumberEditable = true;
                }
                if (segGroup.type == 'group') {
                    childNodeName = segGroup.name;
                    childLocationName = segGroup.name.substr(segGroup.name.lastIndexOf('.') + 1);
                } else {
                    var s = angular.copy($rootScope.segmentsMap[segGroup.ref.id]);
                    s.id = new ObjectId().toString();
                    childLocationName = s.name;
                    childNodeName = s.name;
                    segGroup.segment = s;
                }
                $scope.generatePathInfo(segGroup, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName, key);
            }
        } else if (current.type == 'segmentRef') {
            var seg = current.segment;
            for (var i in seg.fields) {
                var f = seg.fields[i];
                f.pathInfoSet = angular.copy(current.pathInfoSet);

                var childPositionNumber = f.position;
                var childLocationName = f.position;
                var childNodeName = f.name;
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                if (f.max != '1') {
                    childInstanceNumber = '*';
                    childisInstanceNumberEditable = true;
                }
                var child = angular.copy($rootScope.datatypesMap[f.datatype.id]);
                child.id = new ObjectId().toString();
                f.child = child;
                $scope.generatePathInfo(f, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName, key);
            }
        } else if (current.type == 'field' || current.type == 'component') {
            var dt = current.child;
            for (var i in dt.components) {
                var c = dt.components[i];
                c.pathInfoSet = angular.copy(current.pathInfoSet);
                var childPositionNumber = c.position;
                var childLocationName = c.position;
                var childNodeName = c.name;
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                var child = angular.copy($rootScope.datatypesMap[c.datatype.id]);
                child.id = new ObjectId().toString();
                c.child = child;
                $scope.generatePathInfo(c, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName, key);
            }
        }
    };

    $scope.initConformanceStatement = function() {
        $scope.newConstraint = angular.fromJson({
            pathInfoSet_1: null,
            pathInfoSet_2: null,
            position_1: null,
            position_2: null,
            location_1: null,
            location_2: null,
            freeText: null,
            verb: null,
            ignoreCase: false,
            constraintId: null,
            contraintType: null,
            value: null,
            value2: null,
            valueSetId: null,
            bindingStrength: 'R',
            bindingLocation: '1'
        });
    };

    $scope.initComplexStatement = function() {
        $scope.constraints = [];
        $scope.firstConstraint = null;
        $scope.secondConstraint = null;
        $scope.compositeType = null;
        $scope.complexConstraint = null;
        $scope.newComplexConstraintId = null;
    }

    $scope.addConformanceStatement = function() {
        var cs = $rootScope.generateConformanceStatement($scope.newConstraint);
        $scope.selectedContextNode.conformanceStatements.push(cs);
        $scope.changed = true;
        $scope.initConformanceStatement();
    };

    $scope.deleteConformanceStatement = function(conformanceStatement) {
        $scope.selectedContextNode.conformanceStatements.splice($scope.selectedContextNode.conformanceStatements.indexOf(conformanceStatement), 1);
        $scope.changed = true;
    };

    $scope.addFreeTextConformanceStatement = function() {
        var cs = $rootScope.generateFreeTextConformanceStatement($scope.newConstraint);
        $scope.selectedContextNode.conformanceStatements.push(cs);
        $scope.changed = true;
        $scope.initConformanceStatement();
    };

    $scope.addComplexConformanceStatement = function() {
        $scope.complexConstraint = $rootScope.generateCompositeConformanceStatement($scope.compositeType, $scope.firstConstraint, $scope.secondConstraint, $scope.constraints);
        $scope.complexConstraint.constraintId = $scope.newComplexConstraintId;
        $scope.selectedContextNode.conformanceStatements.push($scope.complexConstraint);
        $scope.initComplexStatement();
        $scope.changed = true;
    };

    $scope.cancel = function() {
        $modalInstance.dismiss();
    };

    $scope.saveclose = function() {
        $rootScope.recordChanged();
        $modalInstance.close($scope.selectedMessage);
    };

    $scope.initConformanceStatement();
    $scope.initComplexStatement();
    $scope.generatePathInfo($scope.selectedMessage, ".", ".", "1", false, null, 'default');

});

angular.module('igl').controller('DeleteMessagePredicateCtrl', function($scope, $modalInstance, position, message, $rootScope) {
    $scope.selectedMessage = message;
    $scope.position = position;
    $scope.delete = function() {
        $scope.deleteExistingPredicate($scope.selectedMessage);

        $modalInstance.close();
    };

    $scope.deleteExistingPredicate = function(current) {
        if (current.predicates && current.predicates.length > 0) {
            var toBeDeletePredicate = null;
            for (var i in current.predicates) {
                var positionPath = null;
                if (current.positionPath == null || current.positionPath == '') {
                    var positionPath = current.predicates[i].constraintTarget;
                } else {
                    var positionPath = current.positionPath + '.' + current.predicates[i].constraintTarget;
                }
                if (positionPath == $scope.position) {
                    toBeDeletePredicate = i;
                }
            }
            if (toBeDeletePredicate != null) current.predicates.splice(toBeDeletePredicate, 1);
        }
        if (current.type == 'message' || current.type == 'group') {
            for (var i in current.children) {
                $scope.deleteExistingPredicate(current.children[i]);
            }
        }
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});
angular.module('igl').controller('ListProfileComponentCtrl', function($scope, $modal, orderByFilter, $rootScope, $q, $interval, PcLibraryService, PcService, ngTreetableParams, $http, StorageService, userInfoService, IgDocumentService, SegmentService, DatatypeService, SegmentLibrarySvc, DatatypeLibrarySvc, TableLibrarySvc, MessageService) {
    $scope.changes = false;

    $scope.editProfileComponent = false;
    $scope.edit = false;
    $scope.profileComponents = [];
    $scope.accordStatus = {
        isCustomHeaderOpen: false,
        isFirstOpen: true,
        isSecondOpen: false,
        isFirstDisabled: false
    };
    $scope.pcTypes = [{
        name: "message",
        alias: "Message",
        sub: "Segment Ref/Group"
    }, {
        name: "segment",
        alias: "Segment",
        sub: "Field"
    }, {
        name: "datatype",
        alias: "Datatype",
        sub: "Component"
    }];
    $scope.setPcType = function(type) {
        $scope.element = type;
        if (type.name === 'segment') {
            $scope.segs = angular.copy($rootScope.segments);
        } else if (type.name === 'datatype') {
            $scope.dts = angular.copy($rootScope.datatypes);
        } else if (type.name === 'message') {
            console.log($rootScope.messages);
            $scope.msgs = angular.copy($rootScope.messages.children);
        }
    };



    $scope.applyPcTo = function(node) {
        var applyPcToInstance = $modal.open({
            templateUrl: 'applyPcTo.html',
            controller: 'applyPcToCtrl',
            size: 'lg',
            windowClass: 'conformance-profiles-modal',
            resolve: {
                pc: function() {
                    return $rootScope.profileComponent;
                },
                messages: function() {
                    return $rootScope.messages.children;
                }

            }
        }).result.then(function(results) {

            console.log("+++====+++++");
            console.log($rootScope.profileComponent);

            if ($scope.applyPcToParams) {
                $scope.applyPcToParams.refresh();
            }
            $scope.setDirty();



        });

    };
    $scope.removeApply = function(node) {
        var index = $rootScope.profileComponent.appliedTo.indexOf(node);
        if (index > -1) $rootScope.profileComponent.appliedTo.splice(index, 1);
        if ($scope.applyPcToParams) {
            $scope.applyPcToParams.refresh();
        }
        $scope.setDirty();


    };
    $scope.addPComponents = function() {
        var applyPcToInstance = $modal.open({
            templateUrl: 'addComponents.html',
            controller: 'addComponentsCtrl',
            size: 'lg',
            windowClass: 'conformance-profiles-modal',
            resolve: {
                messages: function() {
                    return angular.copy($rootScope.messages.children);
                },
                segments: function() {
                    return angular.copy($rootScope.segments);
                },
                segmentsMap: function() {
                    return angular.copy($rootScope.segmentsMap);
                },
                datatypes: function() {
                    return angular.copy($rootScope.datatypes);
                },
                datatypesMap: function() {
                    return $rootScope.datatypesMap;
                },
                currentPc: function() {
                    return $rootScope.profileComponent;
                }

            }
        }).result.then(function(results) {
            $scope.setDirty();
            if ($scope.profileComponentParams) {
                $scope.profileComponentParams.refresh();
            }
        });

    };
    $scope.removePcEntry = function(node) {

        var index = $rootScope.profileComponent.children.indexOf(node);
        if (index > -1) $rootScope.profileComponent.children.splice(index, 1);
        $scope.setDirty();
        if ($scope.profileComponentParams) {
            $scope.profileComponentParams.refresh();
        }
    };
    $scope.setPcChild = function(pc) {
        console.log(pc);
        if (pc.type === 'segmentRef') {
            console.log($scope.parent);
            $scope.newPc = {
                id: new ObjectId().toString(),
                name: $rootScope.segmentsMap[pc.ref.id].label,
                type: pc.type,
                path: $scope.parent.structID + '.' + pc.position,
                attributes: {},
                appliedTo: [],
                version: ""
            };
        } else if (pc.type === 'field') {
            console.log($scope.parent);
            $scope.newPc = {
                id: new ObjectId().toString(),
                name: pc.name,
                type: pc.type,
                path: $rootScope.segmentsMap[$scope.parent.id].label + '.' + pc.position,
                attributes: {},
                appliedTo: [],
                version: ""
            };
        } else if (pc.type === 'component') {
            console.log($scope.parent);

            $scope.newPc = {
                id: new ObjectId().toString(),
                name: pc.name,
                type: pc.type,
                path: $rootScope.datatypesMap[$scope.parent.id].label + '.' + pc.position,
                attributes: {},
                appliedTo: [],
                version: ""
            };
        }

    };
    $scope.addComponent = function() {

        PcLibraryService.addComponentToLib($rootScope.igdocument.id, $scope.newPc).then(function(ig) {
            $rootScope.igdocument.profile.profileComponentLibrary.children = ig.profile.profileComponentLibrary.children;
            if ($scope.profileComponentParams) {
                $scope.profileComponentParams.refresh();
            }
        });
    };
    $scope.save = function() {
        console.log($rootScope.profileComponent);
        var children = $rootScope.profileComponent.children;
        var bindingParam = $rootScope.profileComponent.appliedTo;


        PcService.save($rootScope.igdocument.profile.profileComponentLibrary.id, $rootScope.profileComponent).then(function(result) {
            // MessageService.updateProfileComponentBinding(bindingParam).then(function(messages) {
            for (var i = 0; i < $rootScope.igdocument.profile.profileComponentLibrary.children.length; i++) {
                if ($rootScope.igdocument.profile.profileComponentLibrary.children[i].id === $rootScope.profileComponent.id) {
                    $rootScope.igdocument.profile.profileComponentLibrary.children[i].name = $rootScope.profileComponent.name;
                }
                $rootScope.profileComponent = result;
            }
            for (var i = 0; i < $rootScope.profileComponents.length; i++) {
                if ($rootScope.profileComponents[i].id === $rootScope.profileComponent.id) {
                    $rootScope.profileComponents[i] = $rootScope.profileComponent;
                }
            }
            $scope.changes = false;
            $scope.clearDirty();
            console.log(result);
        });
        // });
    };

    $scope.editUsage = function(field) {
        console.log(field);
        //field.oldUsage = field.usage;


    };
    $scope.setUsage = function(field) {
        //field.newUsage = field.usage;
        if (field.attributes.usage) {
            field.attributes.usage = field.attributes.usage;
        } else {
            field.attributes.usage = field.attributes.oldUsage;
        }

        $scope.setDirty();
    };
    $scope.cancelUsage = function(field) {
        //field.usage = field.oldUsage;
        field.attributes.usage = field.attributes.oldUsage;
        $scope.setDirty();
    };
    $scope.editMinCard = function(field) {
        field.oldMinCard = field.min;
    };
    $scope.setMinCard = function(field) {
        field.newMinCard = field.min;
    };
    $scope.cancelMinCard = function(field) {
        field.attributes.min = field.attributes.oldMin;
        $scope.setDirty();

        //field.newMinCard = null;
    }
    $scope.editMaxCard = function(field) {
        field.oldMaxCard = field.max;
    };
    $scope.setMaxCard = function(field) {
        field.newMaxCard = field.max;
    };
    $scope.cancelMaxCard = function(field) {
        field.attributes.max = field.attributes.oldMax;
        $scope.setDirty();

        //field.newMaxCard = null;
    }
    $scope.editMinL = function(field) {
        field.oldMinLength = field.minLength;
    };
    $scope.setMinL = function(field) {
        field.newMinLength = field.minLength;
    };
    $scope.cancelMinL = function(field) {
        field.attributes.minLength = field.attributes.oldMinLength;
        $scope.setDirty();

        //field.newMinLength = null;
    }
    $scope.editMaxL = function(field) {
        field.oldMaxLength = field.maxLength;
    };
    $scope.setMaxL = function(field) {
        field.newMaxLength = field.maxLength;
    };
    $scope.cancelMaxL = function(field) {
        field.attributes.maxLength = field.attributes.oldMaxLength;
        $scope.setDirty();

        //field.newMaxLength = null;
    };
    $scope.editConfL = function(field) {
        field.oldConfLength = field.confLength;
    };
    $scope.setMaxL = function(field) {
        field.newConfLength = field.confLength;
    };
    $scope.cancelConfL = function(field) {
        field.attributes.confLength = field.attributes.oldConfLength;
        $scope.setDirty();

        //field.newconfLength = null;
    };
    $scope.cancelDefText = function(field) {
        field.attributes.text = null;
        $scope.setDirty();
    };
    $scope.cancelTables = function(field) {
        field.attributes.tables = field.attributes.oldTables;
        $scope.setDirty();
    };
    $scope.cancelDatatype = function(field) {
        field.attributes.datatype = field.attributes.oldDatatype;
        $scope.editableDT = '';
        $scope.setDirty();
    };
    $scope.cancelComment = function(field) {
        field.attributes.comment = field.attributes.oldComment;
        $scope.setDirty();
    };
    $scope.cancelRef = function(field) {
        field.attributes.ref = field.attributes.oldRef;
        $scope.setDirty();
    }
    $scope.editableDT = '';

    $scope.selectDT = function(field, datatype) {
        console.log("datatype");

        console.log(datatype);
        if (datatype && datatype !== "Others") {
            $scope.DTselected = true;

            $scope.editableDT = '';
            // field.attributes.datatype = {
            //     id: datatype.id,
            //     name: datatype.name,
            //     ext: datatype.ext,
            //     label: datatype.label
            // };
            field.attributes.datatype = {};
            field.attributes.datatype.ext = JSON.parse(datatype).ext;
            field.attributes.datatype.id = JSON.parse(datatype).id;
            field.attributes.datatype.label = JSON.parse(datatype).label;
            field.attributes.datatype.name = JSON.parse(datatype).name;


            $scope.setDirty();
            if ($scope.profileComponentParams)
                $scope.profileComponentParams.refresh();
            $scope.DTselected = false;

        } else {
            $scope.otherDT(field);
        }


    };
    $scope.editVSModal = function(field) {
        var modalInstance = $modal.open({
            templateUrl: 'editVSModal.html',
            controller: 'EditVSCtrl',
            windowClass: 'edit-VS-modal',
            resolve: {

                valueSets: function() {
                    return $rootScope.tables;
                },

                field: function() {
                    return field;
                }

            }
        });
        modalInstance.result.then(function(field) {
            $scope.setDirty();

        });

    };

    $scope.addComment = function(field) {
        var modalInstance = $modal.open({
            templateUrl: 'addCommentModal.html',
            controller: 'addCommentCtrl',
            windowClass: 'edit-VS-modal',
            resolve: {



                field: function() {
                    return field;
                }

            }
        });
        modalInstance.result.then(function(field) {
            $scope.setDirty();

        });

    };
    $scope.addDefText = function(field) {
        var modalInstance = $modal.open({
            templateUrl: 'addDefTextModal.html',
            controller: 'addDefTextCtrl',
            windowClass: 'edit-VS-modal',
            resolve: {



                field: function() {
                    return field;
                }

            }
        });
        modalInstance.result.then(function(field) {
            $scope.setDirty();

        });

    };
    $scope.otherDT = function(field) {
        var modalInstance = $modal.open({
            templateUrl: 'otherDTModal.html',
            controller: 'otherDTCtrl',
            windowClass: 'edit-VS-modal',
            resolve: {

                datatypes: function() {
                    return $rootScope.datatypes;
                },

                field: function() {
                    return field.attributes;
                }

            }
        });
        modalInstance.result.then(function(field) {
            $scope.setDirty();
            $scope.editableDT = '';
            if ($scope.profileComponentParams) {
                $scope.profileComponentParams.refresh();
            }
        });

    };
    $scope.editableRef = '';
    $scope.editRef = function(field) {
        $scope.editableRef = field.id;
        $scope.segFlavors = [];
        for (var i = 0; i < $rootScope.segments.length; i++) {
            if ($rootScope.segments[i].name === field.attributes.ref.name) {
                $scope.segFlavors.push({
                    id: $rootScope.segments[i].id,
                    name: $rootScope.segments[i].name,
                    ext: $rootScope.segments[i].ext,
                    label: $rootScope.segments[i].label

                });
            }
        }
        console.log($scope.segFlavors);
    };
    $scope.selectFlavor = function(field, flavor) {
        console.log(flavor);
        if (flavor) {
            field.attributes.ref = {
                id: flavor.id,
                name: flavor.name,
                ext: flavor.ext,
                label: flavor.label
            };

            $scope.setDirty();
            $scope.editableRef = '';
        };

    };

    $scope.editDT = function(field) {
        $scope.editableDT = field.id;

        $scope.loadLibrariesByFlavorName = function() {
            console.log(field);
            var delay = $q.defer();
            $scope.ext = null;
            $scope.datatypes = [];
            if (field.attributes.datatype) {
                $scope.datatypes = $scope.datatypes.concat(filterFlavors($rootScope.igdocument.profile.datatypeLibrary, field.attributes.datatype.name));

            } else {
                $scope.datatypes = $scope.datatypes.concat(filterFlavors($rootScope.igdocument.profile.datatypeLibrary, field.attributes.oldDatatype.name));

            }
            $scope.datatypes = _.uniq($scope.datatypes, function(item, key, a) {
                return item.id;
            });
            return delay.promise;
        };


        var filterFlavors = function(library, name) {
            var results = [];
            _.each(library.children, function(link) {
                if (link.name === name) {
                    link.libraryName = library.metaData.name;
                    link.hl7Version = $rootScope.datatypesMap[link.id].hl7Version;
                    //link.hl7Version = library.metaData.hl7Version;
                    results.push(link);
                }
            });
            return results;
        };




        $scope.loadLibrariesByFlavorName().then(function(done) {
            console.log($scope.results);
            // $scope.selection.selected = $scope.currentDatatype.id;
            // $scope.showSelectedDetails($scope.currentDatatype);
        });
    };


});
angular.module('igl').controller('addCommentCtrl',
    function($scope, $rootScope, $modalInstance, field, PcService, $http, SegmentLibrarySvc) {
        $scope.field = field;
        $scope.close = function() {
            //$scope.field.attributes.comment = $scope.comment;
            $modalInstance.close();
        };
    });

angular.module('igl').controller('addDefTextCtrl',
    function($scope, $rootScope, $modalInstance, field, PcService, $http, SegmentLibrarySvc) {
        $scope.field = field;
        $scope.close = function() {
            //$scope.field.attributes.comment = $scope.comment;
            $modalInstance.close();
        };
    });


angular.module('igl').controller('applyPcToCtrl',
    function($scope, $rootScope, $modalInstance, pc, PcService, messages, $http, SegmentLibrarySvc, ngTreetableParams, CompositeMessageService) {
        if (pc.appliedTo === null) {
            pc.appliedTo = [];
        }
        $scope.applyToList = [];
        $scope.messages = messages;
        $scope.msgs = [];
        for (var i = 0; i < $scope.messages.length; i++) {
            $scope.msgs.push({
                id: $scope.messages[i].id,
                name: $scope.messages[i].name
            });
        }
        for (var j = 0; j < pc.appliedTo.length; j++) {
            for (var i = 0; i < $scope.msgs.length; i++) {
                if (pc.appliedTo[j].id === $scope.msgs[i].id) {
                    $scope.msgs.splice(i, 1);
                }
            }
        };
        $scope.ApplyToComponentParams = new ngTreetableParams({
            getNodes: function(parent) {
                if ($scope.msgs !== undefined) {

                    if (parent) {
                        if (parent.children) {

                            return parent.children;
                        }

                    } else {
                        return $scope.msgs;
                    }

                }
            },
            getTemplate: function(node) {
                return 'applyTable';
            }
        });
        $scope.addApplyToMsg = function(node) {
            console.log(node);
            $scope.applyToList.push(node);
            var index = $scope.msgs.indexOf(node);
            if (index > -1) $scope.msgs.splice(index, 1);
            console.log($scope.msgs);
            if ($scope.ApplyToComponentParams) {
                $scope.ApplyToComponentParams.refresh();
            }
        };
        $scope.removeSelectedApplyTo = function(applyTo) {
            var index = $scope.applyToList.indexOf(applyTo);
            if (index > -1) $scope.applyToList.splice(index, 1);
            $scope.msgs.push(applyTo);
            if ($scope.ApplyToComponentParams) {
                $scope.ApplyToComponentParams.refresh();
            }
        };
        $scope.apply = function() {
            console.log("$scope.applyToList");

            console.log($scope.applyToList);
            for (var j = 0; j < $scope.applyToList.length; j++) {
                $rootScope.profileComponent.appliedTo.push({
                    id: $scope.applyToList[j].id,
                    name: $scope.applyToList[j].name
                });
                for (var i = 0; i < $rootScope.messages.children.length; i++) {
                    if ($rootScope.messages.children[i].id === $scope.applyToList[j].id) {
                        if (!$rootScope.messages.children[i].appliedPc) {
                            $rootScope.messages.children[i].appliedPc = [];
                        }
                        $rootScope.messages.children[i].appliedPc.push({
                            id: $scope.applyToList[j].id,
                            name: $scope.applyToList[j].name
                        });
                    }
                }


            }

            var processFields = function(fields) {
                for (var i = 0; i < fields.length; i++) {
                    fields[i].datatype = $rootScope.datatypesMap[fields[i].datatype.id];
                    if (fields[i].datatype.components.length > 0) {
                        fields[i].datatype.components = processFields(fields[i].datatype.components);
                    }

                }
                return fields;
            };
            var processMessage = function(message) {
                for (var i = 0; i < message.children.length; i++) {
                    if (message.children[i].type === "segmentRef") {
                        message.children[i].ref = $rootScope.segmentsMap[message.children[i].ref.id];
                        message.children[i].ref.fields = processFields(message.children[i].ref.fields);
                    } else if (message.children[i].type === "group") {
                        processMessage(message.children[i]);
                    }
                }
                return message;
            };

            var message = angular.copy($rootScope.messages.children[0]);

            var processedMsg = processMessage(message);

            CompositeMessageService.create(processedMsg).then(function(result) {
                console.log(result);
                $modalInstance.close();
            });


        };

        $scope.cancel = function() {
            $modalInstance.dismiss('cancel');
        };
    });



angular.module('igl').controller('addComponentsCtrl',
    function($scope, $rootScope, $modalInstance, messages, segments, segmentsMap, datatypesMap, currentPc, PcLibraryService, datatypes, ngTreetableParams, $http, SegmentLibrarySvc, PcService) {
        $scope.selectedPC = [];
        $scope.MsgProfileComponentParams = new ngTreetableParams({
            getNodes: function(parent) {
                if (messages !== undefined) {

                    if (parent) {
                        if (parent.children) {
                            for (var i = 0; i < parent.children.length; i++) {
                                if (parent.type === 'group') {

                                    parent.children[i].parent = parent.parent + '.' + parent.name;
                                    if (parent.children[i].type === 'segmentRef') {

                                        parent.children[i].children = segmentsMap[parent.children[i].ref.id].fields;

                                    }
                                } else if (parent.type === 'message') {
                                    parent.children[i].parent = parent.structID;
                                    if (parent.children[i].type === 'segmentRef') {

                                        parent.children[i].children = segmentsMap[parent.children[i].ref.id].fields;

                                    }
                                } else if (parent.type === 'segmentRef') {
                                    parent.children[i].parent = parent.parent + '.' + segmentsMap[parent.ref.id].label;
                                    parent.children[i].children = datatypesMap[parent.children[i].datatype.id].components;
                                } else if (parent.type === 'field' || parent.type === 'component') {
                                    console.log("--------------------//////////////////-------------");
                                    console.log(parent);
                                    parent.children[i].parent = parent.parent + '.' + parent.position;
                                    parent.children[i].children = datatypesMap[parent.children[i].datatype.id].components;
                                }

                            }
                            return parent.children;
                        }

                    } else {
                        return messages;
                    }

                }
            },
            getTemplate: function(node) {
                return 'MsgProfileComponentTable';
            }
        });
        $scope.removeSelectedComp = function(pc) {
            var index = $scope.selectedPC.indexOf(pc);
            if (index > -1) $scope.selectedPC.splice(index, 1);
        };

        $scope.addElementPc = function(node, event) {
            var currentScope = angular.element(event.target).scope();
            var pc = currentScope.node;
            var parent = currentScope.parentNode;
            console.log('parent Node details: ', currentScope.parentNode);
            console.log('selected Node details: ', currentScope.node);
            if (pc.type === 'segmentRef') {
                var newPc = {
                    id: new ObjectId().toString(),

                    type: pc.type,
                    path: pc.parent + '.' + pc.position,
                    attributes: {
                        oldRef: {
                            id: $rootScope.segmentsMap[pc.ref.id].id,
                            name: $rootScope.segmentsMap[pc.ref.id].name,
                            ext: $rootScope.segmentsMap[pc.ref.id].ext,
                            label: $rootScope.segmentsMap[pc.ref.id].label,

                        },
                        ref: {
                            id: $rootScope.segmentsMap[pc.ref.id].id,
                            name: $rootScope.segmentsMap[pc.ref.id].name,
                            ext: $rootScope.segmentsMap[pc.ref.id].ext,
                            label: $rootScope.segmentsMap[pc.ref.id].label,

                        },
                        oldUsage: pc.usage,
                        usage: pc.usage,
                        oldMin: pc.min,
                        min: pc.min,
                        oldMax: pc.max,
                        max: pc.max,
                        oldComment: pc.comment,
                        comment: pc.comment,
                    },
                    appliedTo: [],
                    version: ""
                };
            } else if (pc.type === 'group') {
                var newPc = {
                    id: new ObjectId().toString(),
                    name: pc.name,
                    type: pc.type,
                    path: pc.parent + '.' + pc.position,
                    attributes: {
                        oldUsage: pc.usage,
                        usage: pc.usage,
                        oldMin: pc.min,
                        min: pc.min,
                        oldMax: pc.max,
                        max: pc.max,
                        oldComment: pc.comment,
                        comment: pc.comment,
                    },
                    appliedTo: [],
                    version: ""
                };
            } else if (pc.type === 'field') {
                if (parent.type === 'segment') {
                    var newPc = {
                        id: new ObjectId().toString(),
                        name: pc.name,
                        type: pc.type,
                        path: parent.label + '.' + pc.position,
                        pathExp: parent.label + '.' + pc.position,
                        attributes: {
                            oldDatatype: pc.datatype,
                            oldTables: pc.tables,
                            oldUsage: pc.usage,
                            usage: pc.usage,
                            oldMin: pc.min,
                            min: pc.min,
                            oldMax: pc.max,
                            max: pc.max,
                            oldMinLength: pc.minLength,
                            minLength: pc.minLength,
                            oldMaxLength: pc.maxLength,
                            maxLength: pc.maxLength,
                            oldConfLength: pc.confLength,
                            confLength: pc.confLength,
                            oldComment: pc.comment,
                            comment: pc.comment,
                            text: pc.text
                        },
                        appliedTo: [],
                        version: ""
                    };
                } else if (parent.type === 'segmentRef') {
                    var newPc = {
                        id: new ObjectId().toString(),
                        name: pc.name,
                        type: pc.type,
                        path: parent.parent + '.' + $rootScope.segmentsMap[parent.ref.id].label + '.' + pc.position,
                        attributes: {
                            oldDatatype: pc.datatype,
                            oldTables: pc.tables,
                            oldUsage: pc.usage,
                            usage: pc.usage,
                            oldMin: pc.min,
                            min: pc.min,
                            oldMax: pc.max,
                            max: pc.max,
                            oldMinLength: pc.minLength,
                            minLength: pc.minLength,
                            oldMaxLength: pc.maxLength,
                            maxLength: pc.maxLength,
                            oldConfLength: pc.confLength,
                            confLength: pc.confLength,
                            oldComment: pc.comment,
                            comment: pc.comment,
                            text: pc.text
                        },
                        appliedTo: [],
                        version: ""
                    };
                }
            } else if (pc.type === 'component') {
                var splitParent = parent.parent.split(".");
                console.log(splitParent);
                console.log(parent);
                console.log(pc);
                if ((splitParent.length > 1 && parent.type !== "component") || (splitParent.length > 2 && parent.type === "component")) {
                    var newPc = {
                        id: new ObjectId().toString(),
                        name: pc.name,
                        type: pc.type,
                        path: parent.parent + '.' + parent.position + '.' + pc.position,
                        attributes: {
                            oldDatatype: pc.datatype,
                            oldTables: pc.tables,
                            oldUsage: pc.usage,
                            usage: pc.usage,
                            oldMin: pc.min,
                            min: pc.min,
                            oldMax: pc.max,
                            max: pc.max,
                            oldMinLength: pc.minLength,
                            minLength: pc.minLength,
                            oldMaxLength: pc.maxLength,
                            maxLength: pc.maxLength,
                            oldConfLength: pc.confLength,
                            confLength: pc.confLength,
                            oldComment: pc.comment,
                            comment: pc.comment,
                            text: pc.text
                        },
                        appliedTo: [],
                        version: ""
                    };

                } else {
                    console.log("-------");
                    console.log(parent);
                    var newPc = {
                        id: new ObjectId().toString(),
                        name: pc.name,
                        type: pc.type,
                        path: parent.parent + '.' + parent.position + '.' + pc.position,
                        pathExp: parent.parent + '.' + parent.position + '.' + pc.position,
                        attributes: {
                            oldDatatype: pc.datatype,
                            oldTables: pc.tables,
                            oldUsage: pc.usage,
                            usage: pc.usage,
                            oldMin: pc.min,
                            min: pc.min,
                            oldMax: pc.max,
                            max: pc.max,
                            oldMinLength: pc.minLength,
                            minLength: pc.minLength,
                            oldMaxLength: pc.maxLength,
                            maxLength: pc.maxLength,
                            oldConfLength: pc.confLength,
                            confLength: pc.confLength,
                            oldComment: pc.comment,
                            comment: pc.comment,
                            text: pc.text
                        },
                        appliedTo: [],
                        version: ""
                    };

                }

            } else if (pc.type === 'segment') {
                var newPc = {
                    id: new ObjectId().toString(),
                    name: $rootScope.segmentsMap[pc.id].name,
                    ext: $rootScope.segmentsMap[pc.id].ex,
                    type: pc.type,
                    path: $rootScope.segmentsMap[pc.id].label,
                    pathExp: $rootScope.segmentsMap[pc.id].label,
                    attributes: {
                        ref: {
                            id: $rootScope.segmentsMap[pc.id].id,
                            name: $rootScope.segmentsMap[pc.id].name,
                            ext: $rootScope.segmentsMap[pc.id].ex,
                            label: $rootScope.segmentsMap[pc.id].label,

                        },
                        oldRef: {
                            id: $rootScope.segmentsMap[pc.id].id,
                            name: $rootScope.segmentsMap[pc.id].name,
                            ext: $rootScope.segmentsMap[pc.id].ex,
                            label: $rootScope.segmentsMap[pc.id].label,

                        }
                    },
                    appliedTo: [],
                    version: ""
                };
            } else if (pc.type === 'datatype') {

                var newPc = {
                    id: new ObjectId().toString(),
                    name: $rootScope.datatypesMap[pc.id].label,
                    ext: $rootScope.datatypesMap[pc.id].ex,
                    type: pc.type,
                    path: $rootScope.datatypesMap[pc.id].label,
                    attributes: {},
                    appliedTo: [],
                    version: ""
                };


            };
            $scope.selectedPC.push(newPc);
            console.log(newPc);
        };

        $scope.SegProfileComponentParams = new ngTreetableParams({
            getNodes: function(parent) {
                if (segments !== undefined) {
                    if (parent) {
                        if (parent.fields) {
                            for (var i = 0; i < parent.fields.length; i++) {
                                if (parent.type === "segment") {
                                    parent.fields[i].parent = parent.label;
                                }
                                if (parent.type === "field" || parent.type === "component") {
                                    parent.fields[i].parent = parent.parent + '.' + parent.position;
                                }
                                if (parent.fields[i].datatype) {
                                    parent.fields[i].fields = datatypesMap[parent.fields[i].datatype.id].components;
                                }
                            }
                            return parent.fields;
                        }

                    } else {
                        return segments;
                    }

                }
            },
            getTemplate: function(node) {
                return 'SegProfileComponentTable';
            }
        });

        $scope.DTProfileComponentParams = new ngTreetableParams({
            getNodes: function(parent) {
                if (datatypes !== undefined) {
                    if (parent) {
                        if (parent.components) {
                            for (var i = 0; i < parent.components.length; i++) {
                                if (parent.type === "datatype") {
                                    parent.components[i].parent = parent.label;
                                }
                                if (parent.type === "component") {
                                    parent.components[i].parent = parent.parent + '.' + parent.position;
                                }
                                if (parent.components[i].datatype) {
                                    parent.components[i].components = datatypesMap[parent.components[i].datatype.id].components;
                                }
                            }
                            return parent.components;
                        }

                    } else {
                        console.log(datatypes);
                        return datatypes;
                    }

                }
            },
            getTemplate: function(node) {
                return 'DTProfileComponentTable';
            }
        });
        $scope.add = function() {
            // PcLibraryService.addComponentsToLib($rootScope.igdocument.id, $scope.selectedPC).then(function(ig) {
            //     $rootScope.igdocument.profile.profileComponentLibrary.children = ig.profile.profileComponentLibrary.children;
            //     if ($scope.profileComponentParams) {
            //         $scope.profileComponentParams.refresh();
            //     }
            //     $modalInstance.close();
            // });
            console.log($rootScope.profileComponent);
            for (var i = 0; i < $scope.selectedPC.length; i++) {
                $rootScope.profileComponent.children.push($scope.selectedPC[i]);
            }
            $modalInstance.close();

            // PcService.addPCs(currentPc.id, $scope.selectedPC).then(function(profileC) {
            //     $rootScope.profileComponent = profileC;
            //     
            // });
        };


        $scope.cancel = function() {
            $modalInstance.dismiss('cancel');
        };
    });
'use strict';

angular.module('igl')
.controller('RegisterResetPasswordCtrl', ['$scope', '$resource', '$modal', '$routeParams', 'isFirstSetup',
    function ($scope, $resource, $modal, $routeParams, isFirstSetup) {
        $scope.agreed = false;
        $scope.displayForm = true;
        $scope.isFirstSetup = isFirstSetup;

        if ( !angular.isDefined($routeParams.username) ) {
            $scope.displayForm = false;
        }
        if ( $routeParams.username === '' ) {
            $scope.displayForm = false;
        }
        if ( !angular.isDefined($routeParams.token) ) {
            $scope.displayForm = false;
        }
        if ( $routeParams.token === '' ) {
            $scope.displayForm = false;
        }
        if ( !angular.isDefined($routeParams.userId) ) {
            $scope.displayForm = false;
        }
        if ( $routeParams.userId === '' ) {
            $scope.displayForm = false;
        }

        //to register an account for the first time
        var AcctInitPassword = $resource('api/sooa/accounts/register/:userId/passwordreset', {userId:'@userId', token:'@token'});
        //to reset the password  
        var AcctResetPassword = $resource('api/sooa/accounts/:id/passwordreset', {id:'@userId', token:'@token'});

        $scope.user = {};
        $scope.user.username = $routeParams.username;
        $scope.user.newUsername = $routeParams.username;
        $scope.user.userId = $routeParams.userId;
        $scope.user.token = $routeParams.token;



//        $scope.confirmRegistration = function() {
//            var modalInstance = $modal.open({
//                backdrop: true,
//                keyboard: true,
//                backdropClick: false,
//                controller: 'AgreementCtrl',
//                templateUrl: 'views/agreement.html'
//            });
//            modalInstance.result.then(function (result) {
//                if(result) {
//                    var initAcctPass = new AcctInitPassword($scope.user);
//                    initAcctPass.signedConfidentialityAgreement = true;
//                    initAcctPass.$save(function() {
//                        $scope.user.password = '';
//                        $scope.user.passwordConfirm = '';
//                    });
//                }
//                else {
//                    //console.log("Agreement not accepted");
//                }
//            });
//        };

        $scope.changePassword = function() {
            if($scope.agreed) {
                var resetAcctPass = new AcctResetPassword($scope.user);
                resetAcctPass.$save(function () {
                    $scope.user.password = '';
                    $scope.user.passwordConfirm = '';
                });
            }
        };
    }
]);

'use strict';

angular.module('igl')
.controller('RegistrationCtrl', ['$scope', '$resource', '$modal', '$location',
    function ($scope, $resource, $modal, $location) {
        $scope.account = {};
        $scope.registered = false;
        $scope.agreed = false;

        //Creating a type to check with the server if a username already exists.
        var Username = $resource('api/sooa/usernames/:username', {username: '@username'});
        var Email = $resource('api/sooa/emails/:email', {email: '@email'});

        var NewAccount = $resource('api/sooa/accounts/register');

        $scope.registerAccount = function() {
            if($scope.agreed) {
                //console.log("Creating account");
                var acctToRegister = new NewAccount();
                acctToRegister.accountType = 'author';
                acctToRegister.employer =  $scope.account.employer;
                acctToRegister.fullName =  $scope.account.fullName;
                acctToRegister.phone =  $scope.account.phone;
                acctToRegister.title =  $scope.account.title;
                acctToRegister.juridiction =  $scope.account.juridiction;
                acctToRegister.username =  $scope.account.username;
                acctToRegister.password =  $scope.account.password;
                acctToRegister.email =  $scope.account.email;
                acctToRegister.signedConfidentialityAgreement = true;
                acctToRegister.$save(
                    function() {
                        if (acctToRegister.text ===  'userAdded') {
                            $scope.account = {};
                            //should unfreeze the form
                            $scope.registered = true;
                            $location.path('/registrationSubmitted');
                        }else{
                            $scope.registered = false;
                        }
                    },
                    function() {
                        $scope.registered = false;
                    }
                );
                //should freeze the form - at least the button
                $scope.registered = true;
            }
        };

//        $scope.registerAccount = function() {
//            /* Check for username already in use
//               Verify email not already associated to an account
//               Will need to send an email if success
//               */
//            var modalInstance = $modal.open({
//                backdrop: true,
//                keyboard: true,
//                backdropClick: false,
//                controller: 'AgreementCtrl',
//                templateUrl: 'views/account/agreement.html'
//            });
//
//            modalInstance.result.then(function(result) {
//                if(result) {
//                    //console.log("Creating account");
//                    var acctToRegister = new NewAccount();
//                    acctToRegister.accountType = 'provider';
//                    acctToRegister.company =  $scope.account.company;
//                    acctToRegister.firstname =  $scope.account.firstname;
//                    acctToRegister.lastname =  $scope.account.lastname;
//                    acctToRegister.username =  $scope.account.username;
//                    acctToRegister.password =  $scope.account.password;
//                    acctToRegister.email =  $scope.account.email;
//                    acctToRegister.signedConfidentialityAgreement = true;
//
//                    acctToRegister.$save(
//                        function() {
//                            if (acctToRegister.text ===  'userAdded') {
//                                $scope.account = {};
//                                //should unfreeze the form
//                                $scope.registered = true;
//                                $location.path('/home');
//                            }
//                        },
//                        function() {
//                            $scope.registered = false;
//                        }
//                    );
//                    //should freeze the form - at least the button
//                    $scope.registered = true;
//                }
//                else {
//                    //console.log('Account not created');
//                }
//            });
//        };
    }
]);
//
//angular.module('igl').controller('AgreementCtrl', ['$scope', '$modalInstance',
//    function ($scope, $modalInstance) {
//
//        $scope.acceptAgreement =  function() {
//            var res = true;
//            $modalInstance.close(res);
//        };
//
//        $scope.doNotAcceptAgreement =  function() {
//            var res = false;
//            $modalInstance.close(res);
//        };
//    }
//]);

/**
 * Created by haffo on 2/13/15.
 */

angular.module('igl').controller('SegmentListCtrl', function($scope, $rootScope, Restangular, ngTreetableParams, CloneDeleteSvc, $filter, $http, $modal, $timeout, $q, SegmentService, FieldService, FilteringSvc, MastermapSvc, SegmentLibrarySvc, DatatypeLibrarySvc, MessageService, DatatypeService, TableService, blockUI) {
    //        $scope.loading = false;

    // console.log("IN SEGMENTS========");
    $scope.accordStatus = {
        isCustomHeaderOpen: false,
        isFirstOpen: true,
        isSecondOpen: true,
        isThirdOpen: true,
        isFourthOpen: true,
        isFirstDisabled: false
    };

    $scope.tabStatus = {
        active: 1
    };

    $scope.init = function() {

        $scope.accordStatus = {
            isCustomHeaderOpen: false,
            isFirstOpen: true,
            isSecondOpen: false,
            isThirdOpen: false,
            isFourthOpen: false,
            isFirstDisabled: false
        };

        $scope.tabStatus = {
            active: 1
        };
    };

    $scope.editableDT = '';
    $scope.editableVS = '';

    $scope.readonly = false;
    $scope.saved = false;
    $scope.message = false;
    $scope.segmentCopy = null;
    $scope.selectedChildren = [];
    $scope.saving = false;

    // console.log($rootScope.tables);
    $scope.OtoX = function(message) {
        var modalInstance = $modal.open({
            templateUrl: 'OtoX.html',
            controller: 'OtoXCtrl',
            size: 'md',
            resolve: {
                message: function() {
                    return message;
                }


            }
        });
        modalInstance.result.then(function() {
            $scope.setDirty();

            if ($scope.segmentsParams)
                $scope.segmentsParams.refresh();
        });
    };

    $scope.openPredicateDialog = function(node) {
        if (node.usage == 'C') $scope.managePredicate(node);
    };

    $scope.deleteField = function(fieldToDelete, segment) {
        var modalInstance = $modal.open({
            templateUrl: 'DeleteField.html',
            controller: 'DeleteFieldCtrl',
            size: 'md',
            resolve: {
                fieldToDelete: function() {
                    return fieldToDelete;
                },
                segment: function() {
                    return segment;
                }


            }
        });
        modalInstance.result.then(function() {
            $scope.setDirty();

            if ($scope.segmentsParams)
                $scope.segmentsParams.refresh();
        });
    };
    $scope.editableField = '';
    $scope.editField = function(field) {
        // console.log(field);
        $scope.editableField = field.id;
        $scope.fieldName = field.name;

    };

    $scope.deleteConformanceStatementFromList = function(c) {
        $rootScope.segment.conformanceStatements.splice($rootScope.segment.conformanceStatements.indexOf(c), 1);

        $scope.setDirty();
    };

    $scope.deletePredicateFromList = function(p) {
        $rootScope.segment.predicates.splice($rootScope.segment.predicates.indexOf(p), 1);

        $scope.setDirty();
    };

    $scope.AddBindingForSegment = function(segment) {
        var modalInstance = $modal.open({
            templateUrl: 'AddBindingForSegment.html',
            controller: 'AddBindingForSegment',
            windowClass: 'conformance-profiles-modal',
            resolve: {
                segment: function() {
                    return segment;
                }
            }
        });
        modalInstance.result.then(function() {
            $scope.setDirty();
        });
    };


    $scope.changeSegmentLink = function(segmentLink) {
        segmentLink.isChanged = true;

        var t = $rootScope.segmentsMap[segmentLink.id];

        if (t == null) {
            segmentLink.name = null;
            segmentLink.ext = null;
            segmentLink.label = null;
        } else {
            segmentLink.name = t.name;
            segmentLink.ext = t.ext;
            segmentLink.label = t.label;
        }
        // console.log(segmentLink);
    };


    $scope.backField = function() {
        $scope.editableField = '';
    };
    $scope.applyField = function(segment, field, name, position) {
        blockUI.start();
        $scope.editableField = '';
        if (field) {
            field.name = name;


        }
        if (position) {
            MessageService.updatePosition(segment.fields, field.position - 1, position - 1);
        }
        $scope.setDirty();

        if ($scope.segmentsParams)
            $scope.segmentsParams.refresh();
        $scope.Posselected = false;
        blockUI.stop();

    };




    $scope.selectDT = function(field, datatype) {
        if (datatype) {
            $scope.DTselected = true;
            blockUI.start();
            $scope.editableDT = '';

            field.datatype.ext = JSON.parse(datatype).ext;
            field.datatype.id = JSON.parse(datatype).id;
            field.datatype.label = JSON.parse(datatype).label;
            field.datatype.name = JSON.parse(datatype).name;
            // console.log(field);
            $scope.setDirty();
            $rootScope.processElement(field);
            if ($scope.segmentsParams)
                $scope.segmentsParams.refresh();
            $scope.DTselected = false;
            blockUI.stop();
        } else {
            $scope.otherDT(field);
        }


    };
    // $scope.applyDT = function(field, datatype) {
    //     blockUI.start();
    //     $scope.editableDT = '';

    //     field.datatype.ext = JSON.parse(datatype).ext;
    //     field.datatype.id = JSON.parse(datatype).id;
    //     field.datatype.label = JSON.parse(datatype).label;
    //     field.datatype.name = JSON.parse(datatype).name;
    //     console.log(field);
    //     $scope.setDirty();
    //     $rootScope.processElement(field);
    //     if ($scope.segmentsParams)
    //         $scope.segmentsParams.refresh();
    //     $scope.DTselected = false;
    //     blockUI.stop();

    // };
    $scope.otherDT = function(field) {
        // console.log("heeere");
        var modalInstance = $modal.open({
            templateUrl: 'otherDTModal.html',
            controller: 'otherDTCtrl',
            windowClass: 'edit-VS-modal',
            resolve: {

                datatypes: function() {
                    return $rootScope.datatypes;
                },

                field: function() {
                    return field;
                }

            }
        });
        modalInstance.result.then(function(field) {
            $scope.setDirty();
            $scope.editableDT = '';
            if ($scope.segmentsParams) {
                $scope.segmentsParams.refresh();
            }
        });

    };

    $scope.editDT = function(field) {
        $scope.editableDT = field.id;

        $scope.results = [];
        angular.forEach($rootScope.datatypeLibrary.children, function(dtLink) {
            if (dtLink.name && dtLink.name === field.datatype.name) {
                $scope.results.push(dtLink);
            }
        });
    };

    $scope.backDT = function() {
        $scope.editableDT = '';
    };


    $scope.redirectDT = function(datatype) {
        DatatypeService.getOne(datatype.id).then(function(datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'redirectCtrl.html',
                controller: 'redirectCtrl',
                size: 'md',
                resolve: {
                    destination: function() {
                        return datatype;
                    }
                }



            });
            modalInstance.result.then(function() {
                $rootScope.editDatatype(datatype);
            });



        });
    };

    $scope.loadVS = function($query) {


        return $rootScope.tables.filter(function(table) {
            return table.bindingIdentifier.toLowerCase().indexOf($query.toLowerCase()) != -1;
        });

    };

    $scope.editVSModal = function(field) {
        var modalInstance = $modal.open({
            templateUrl: 'editVSModal.html',
            controller: 'EditVSCtrl',
            windowClass: 'edit-VS-modal',
            resolve: {

                valueSets: function() {
                    return $rootScope.tables;
                },

                field: function() {
                    return field;
                }

            }
        });
        modalInstance.result.then(function(field) {
            $scope.setDirty();
            if ($scope.segmentsParams) {
                $scope.segmentsParams.refresh();
            }
        });

    };


    $scope.editVS = function(field) {
        // console.log(field);
        $scope.editableVS = field.id;
        if (field.table !== null) {
            $scope.VSselected = true;
            $scope.selectedValueSet = field.table;
            // console.log($scope.selectedValueSet);

        } else {
            $scope.VSselected = false;

        }

    };
    $scope.backVS = function() {
        $scope.editableVS = '';
    };
    // $scope.applyVS = function(field) {
    //     $scope.editableVS = '';
    //     if (field.table === null) {
    //         field.table = {
    //             id: '',
    //             bindingIdentifier: ''

    //         };
    //         console.log(field);

    //     }
    //     console.log(field);


    //     field.table.id = $scope.selectedValueSet.id;
    //     field.table.bindingIdentifier = $scope.selectedValueSet.bindingIdentifier;
    //     $scope.setDirty();
    //     $scope.VSselected = false;

    // };


    $scope.redirectVS = function(valueSet) {
        TableService.getOne(valueSet.id).then(function(valueSet) {
            var modalInstance = $modal.open({
                templateUrl: 'redirectCtrl.html',
                controller: 'redirectCtrl',
                size: 'md',
                resolve: {
                    destination: function() {
                        return valueSet;
                    }
                }



            });
            modalInstance.result.then(function() {
                $rootScope.editTable(valueSet);
            });



        });
    };

    $scope.selectVS = function(field, valueSet) {
        // console.log("valueSet");
        // console.log(valueSet);

        $scope.selectedValueSet = valueSet;
        $scope.VSselected = true;
        $scope.editableVS = '';
        if (field.table === null) {
            field.table = {
                id: '',
                bindingIdentifier: ''

            };
            // console.log(field);

        }
        // console.log(field);


        field.table.id = $scope.selectedValueSet.id;
        field.table.bindingIdentifier = $scope.selectedValueSet.bindingIdentifier;
        $scope.setDirty();
        $scope.VSselected = false;


    };

    $scope.selectedVS = function() {
        return ($scope.selectedValueSet !== undefined);
    };
    $scope.unselectVS = function() {
        $scope.selectedValueSet = undefined;
        $scope.VSselected = false;

        //$scope.newSeg = undefined;
    };
    $scope.isVSActive = function(id) {
        if ($scope.selectedValueSet) {
            return $scope.selectedValueSet.id === id;
        } else {
            return false;
        }

    };

    $scope.addFieldModal = function(segment) {
        var modalInstance = $modal.open({
            templateUrl: 'AddFieldModal.html',
            controller: 'AddFieldCtrl',
            windowClass: 'creation-modal-window',
            resolve: {

                valueSets: function() {
                    return $rootScope.tables;
                },
                datatypes: function() {
                    return $rootScope.datatypes;
                },
                segment: function() {
                    return segment;
                },
                messageTree: function() {
                    return $rootScope.messageTree;
                }

            }
        });
        modalInstance.result.then(function(field) {
            $scope.setDirty();

            if ($scope.segmentsParams) {
                $scope.segmentsParams.refresh();
            }
        });
    };

    $scope.addCoConstraint = function() {
        var valueList = [];

        for (var i = 0, len1 = $rootScope.segment.coConstraints.columnList.length; i < len1; i++) {
            var v = {};
            v.value = '';
            valueList.push(v);
        };

        var cc = {
            description: "",
            comments: "",
            values: valueList
        };
        $scope.setDirty();
        $rootScope.segment.coConstraints.constraints.push(cc);
    };

    $scope.manageCoConstaintsTableModal = function(segment) {
        var modalInstance = $modal.open({
            templateUrl: 'ManageCoConstraintsTableModal.html',
            controller: 'ManageCoConstraintsTableCtrl',
            windowClass: 'creation-modal-window',
            resolve: {
                segment: function() {
                    return segment;
                }
            }
        });
        modalInstance.result.then(function() {
            $scope.setDirty();
        });
    };


    $scope.deleteColumn = function(column) {
        var index = $rootScope.segment.coConstraints.columnList.indexOf(column);

        if (index > -1) {
            var columnPosition = $rootScope.segment.coConstraints.columnList[index].columnPosition;
            $rootScope.segment.coConstraints.columnList.splice(index, 1);

            for (var i = 0, len1 = $rootScope.segment.coConstraints.columnList.length; i < len1; i++) {
                if ($rootScope.segment.coConstraints.columnList[i].columnPosition > columnPosition) {
                    $rootScope.segment.coConstraints.columnList[i].columnPosition = $rootScope.segment.coConstraints.columnList[i].columnPosition - 1;
                }
            }

            for (var i = 0, len1 = $rootScope.segment.coConstraints.constraints.length; i < len1; i++) {
                $rootScope.segment.coConstraints.constraints[i].values.splice(columnPosition, 1);
            };
        }

        $scope.setDirty();
    };

    $scope.deleteCoConstraint = function(cc) {
        var index = $rootScope.segment.coConstraints.constraints.indexOf(cc);

        if (index > -1) {
            $rootScope.segment.coConstraints.constraints.splice(index, 1);
        };
        $scope.setDirty();
    };

    $scope.deleteCoConstraints = function() {
        $rootScope.segment.coConstraints.columnList = [];
        $rootScope.segment.coConstraints.constraints = [];
        $scope.setDirty();
    };

    $scope.getConstraintType = function(data, cc) {
        var index = cc.values.indexOf(data);
        return $rootScope.segment.coConstraints.columnList[index].constraintType;
    };

    $scope.headerChanged = function() {
        // console.log("WWWWWW");
    }

    $scope.reset = function() {
        blockUI.start();
        SegmentService.reset();
        if ($scope.editForm) {
            $scope.editForm.$dirty = false;
            $scope.editForm.$setPristine();
        }
        $rootScope.clearChanges();

        $rootScope.addedDatatypes = [];
        $rootScope.addedTables = [];
        if ($scope.segmentsParams) {
            $scope.segmentsParams.refresh();
        }
        blockUI.stop();
    };

    $scope.close = function() {
        $rootScope.segment = null;
        $scope.refreshTree();
        $scope.loadingSelection = false;
    };

    $scope.copy = function(segment) {
        CloneDeleteSvc.copySegment(segment);
    }

    $scope.delete = function(segment) {
        CloneDeleteSvc.deleteSegment(segment);
        $rootScope.$broadcast('event:SetToC');
    };


    $scope.hasChildren = function(node) {
        if (node && node != null) {
            if (node.fields && node.fields.length > 0) return true;
            else {
                if (node.type === 'case') {
                    if ($rootScope.getDatatype(node.datatype).components && $rootScope.getDatatype(node.datatype).components.length > 0) return true;
                } else {
                    if (node.datatype && $rootScope.getDatatype(node.datatype.id)) {
                        if ($rootScope.getDatatype(node.datatype.id).components && $rootScope.getDatatype(node.datatype.id).components.length > 0) return true;
                        else {
                            if ($rootScope.getDatatype(node.datatype.id).name === 'varies') {
                                var mapping = _.find($rootScope.segment.dynamicMapping.mappings, function(mapping) {
                                    return mapping.position == node.position;
                                });
                                if (mapping && mapping.cases && mapping.cases.length > 0) return true;
                            }
                        }
                    }
                }
            }
        }

        return false;
    };


    $scope.validateLabel = function(label, name) {
        if (label && !label.startsWith(name)) {
            return false;
        }
        return true;
    };

    $scope.onDatatypeChange = function(node) {
        $rootScope.recordChangeForEdit2('field', 'edit', node.id, 'datatype', node.datatype.id);
        $scope.refreshTree();
    };

    $scope.refreshTree = function() {
        if ($scope.segmentsParams)
            $scope.segmentsParams.refresh();
    };

    $scope.goToTable = function(table) {
        $scope.$emit('event:openTable', table);
    };

    $scope.goToDatatype = function(datatype) {
        $scope.$emit('event:openDatatype', datatype);
    };

    $scope.deleteTable = function(node) {
        node.table = null;
        $rootScope.recordChangeForEdit2('field', 'edit', node.id, 'table', null);
    };

    $scope.mapTable = function(node) {
        var modalInstance = $modal.open({
            templateUrl: 'TableMappingSegmentCtrl.html',
            controller: 'TableMappingSegmentCtrl',
            windowClass: 'app-modal-window',
            resolve: {
                selectedNode: function() {
                    return node;
                }
            }
        });
        modalInstance.result.then(function(node) {
            $scope.selectedNode = node;
            $scope.setDirty();
        }, function() {});
    };



    $scope.findDTByComponentId = function(componentId) {
        return $rootScope.parentsMap && $rootScope.parentsMap[componentId] ? $rootScope.parentsMap[componentId] : null;
    };

    $scope.isSub = function(component) {
        return $scope.isSubDT(component);
    };

    $scope.isSubDT = function(component) {
        return component.type === 'component' && $rootScope.parentsMap && $rootScope.parentsMap[component.id] && $rootScope.parentsMap[component.id].type === 'component';
    };

    $scope.managePredicate = function(node) {
        var modalInstance = $modal.open({
            templateUrl: 'PredicateSegmentCtrl.html',
            controller: 'PredicateSegmentCtrl',
            windowClass: 'app-modal-window',
            resolve: {
                selectedNode: function() {
                    return node;
                }
            }
        });
        modalInstance.result.then(function(segment) {
            if (segment) {
                $rootScope.segment.predicates = segment.predicates;
                $scope.setDirty();
            }
        }, function() {});
    };

    $scope.manageConformanceStatement = function() {
        var modalInstance = $modal.open({
            templateUrl: 'ConformanceStatementSegmentCtrl.html',
            controller: 'ConformanceStatementSegmentCtrl',
            windowClass: 'app-modal-window',
            resolve: {}
        });
        modalInstance.result.then(function(segment) {
            if (segment) {
                $scope.setDirty();
            }
        }, function() {

        });
    };

    $scope.show = function(segment) {
        return true;
    };

    $scope.countConformanceStatements = function(position) {
        var count = 0;
        if ($rootScope.segment != null) {
            for (var i = 0, len1 = $rootScope.segment.conformanceStatements.length; i < len1; i++) {
                if ($rootScope.segment.conformanceStatements[i].constraintTarget.indexOf(position + '[') === 0)
                    count = count + 1;
            }
        }
        return count;
    };

    $scope.countPredicate = function(position) {
        var count = 0;
        if ($rootScope.segment != null) {
            for (var i = 0, len1 = $rootScope.segment.predicates.length; i < len1; i++) {
                if ($rootScope.segment.predicates[i].constraintTarget.indexOf(position + '[') === 0)
                    count = count + 1;
            }
        }
        return count;
    };

    $scope.deletePredicateByPosition = function(position, segment) {
        var modalInstance = $modal.open({
            templateUrl: 'DeleteSegmentPredicate.html',
            controller: 'DeleteSegmentPredicateCtrl',
            size: 'md',
            resolve: {
                position: function() {
                    return position;
                },
                segment: function() {
                    return segment;
                }
            }
        });
        modalInstance.result.then(function() {
            $scope.setDirty();
        });
    };

    $scope.countPredicateOnComponent = function(position, componentId) {
        var dt = $scope.findDTByComponentId(componentId);
        if (dt != null)
            for (var i = 0, len1 = dt.predicates.length; i < len1; i++) {
                if (dt.predicates[i].constraintTarget.indexOf(position + '[') === 0)
                    return 1;
            }

        return 0;
    };

    $scope.isRelevant = function(node) {
        return SegmentService.isRelevant(node);
    };

    $scope.isBranch = function(node) {
        SegmentService.isBranch(node);
    };

    $scope.isVisible = function(node) {
        return SegmentService.isVisible(node);
    };

    $scope.children = function(node) {
        return SegmentService.getNodes(node);
    };

    $scope.getParent = function(node) {
        return SegmentService.getParent(node);
    };

    $scope.getSegmentLevelConfStatements = function(element) {
        return SegmentService.getSegmentLevelConfStatements(element);
    };

    $scope.getSegmentLevelPredicates = function(element) {
        return SegmentService.getSegmentLevelPredicates(element);
    };


    $scope.isChildSelected = function(component) {
        return $scope.selectedChildren.indexOf(component) >= 0;
    };

    $scope.isChildNew = function(component) {
        return component && component != null && component.status === 'DRAFT';
    };


    $scope.selectChild = function($event, child) {
        var checkbox = $event.target;
        var action = (checkbox.checked ? 'add' : 'remove');
        updateSelected(action, child);
    };


    $scope.selectAllChildren = function($event) {
        var checkbox = $event.target;
        var action = (checkbox.checked ? 'add' : 'remove');
        for (var i = 0; i < $rootScope.segment.fields.length; i++) {
            var component = $rootScope.segment.fields[i];
            updateSelected(action, component);
        }
    };

    var updateSelected = function(action, child) {
        if (action === 'add' && !$scope.isChildSelected(child)) {
            $scope.selectedChildren.push(child);
        }
        if (action === 'remove' && $scope.isChildSelected(child)) {
            $scope.selectedChildren.splice($scope.selectedChildren.indexOf(child), 1);
        }
    };

    //something extra I couldn't resist adding :)
    $scope.isSelectedAllChildren = function() {
        return $rootScope.segment && $rootScope.segment != null && $rootScope.segment.fields && $scope.selectedChildren.length === $rootScope.segment.fields.length;
    };


    /**
     * TODO: update master map
     */
    $scope.createNewField = function() {
        if ($rootScope.segment != null) {
            if (!$rootScope.segment.fields || $rootScope.segment.fields === null)
                $rootScope.segment.fields = [];
            var child = FieldService.create($rootScope.segment.fields.length + 1);
            $rootScope.segment.fields.push(child);
            //TODO update master map
            //TODO:remove as legacy code
            $rootScope.parentsMap[child.id] = $rootScope.segment;
            if ($scope.segmentsParams)
                $scope.segmentsParams.refresh();
        }
    };

    /**
     * TODO: update master map
     */
    $scope.deleteFields = function() {
        if ($rootScope.segment != null && $scope.selectedChildren != null && $scope.selectedChildren.length > 0) {
            FieldService.deleteList($scope.selectedChildren, $rootScope.segment);
            //TODO update master map
            //TODO:remove as legacy code
            angular.forEach($scope.selectedChildren, function(child) {
                delete $rootScope.parentsMap[child.id];
            });
            $scope.selectedChildren = [];
            if ($scope.segmentsParams)
                $scope.segmentsParams.refresh();
        }
    };



    $scope.cleanState = function() {
        $scope.saving = false;
        $scope.selectedChildren = [];
        if ($scope.editForm) {
            $scope.editForm.$setPristine();
            $scope.editForm.$dirty = false;
        }
        $rootScope.clearChanges();
        if ($scope.segmentsParams)
            $scope.segmentsParams.refresh();
    };
    $scope.callSegDelta = function() {

        $rootScope.$emit("event:openSegDelta");
    };


    $scope.save = function() {
        $scope.saving = true;
        var segment = $rootScope.segment;
        $rootScope.$emit("event:saveSegForDelta");
        var ext = segment.ext;
        if (segment.libIds === undefined) segment.libIds = [];
        if (segment.libIds.indexOf($rootScope.igdocument.profile.segmentLibrary.id) == -1) {
            segment.libIds.push($rootScope.igdocument.profile.segmentLibrary.id);
        }
        SegmentService.save($rootScope.segment).then(function(result) {
            $rootScope.segment.dateUpdated = result.dateUpdated;
            $rootScope.$emit("event:updateIgDate");
            if ($rootScope.selectedSegment !== null && $rootScope.segment.id === $rootScope.selectedSegment.id) {
                $rootScope.processSegmentsTree($rootScope.segment, null);
            }

            var oldLink = SegmentLibrarySvc.findOneChild(result.id, $rootScope.igdocument.profile.segmentLibrary.children);
            var newLink = SegmentService.getSegmentLink(result);
            SegmentLibrarySvc.updateChild($rootScope.igdocument.profile.segmentLibrary.id, newLink).then(function(link) {
                SegmentService.saveNewElements().then(function() {
                    SegmentService.merge($rootScope.segmentsMap[result.id], result);
                    if (oldLink && oldLink != null) {
                        oldLink.ext = newLink.ext;
                        oldLink.name = newLink.name;
                    }
                    $scope.cleanState();
                }, function(error) {
                    $scope.saving = false;

                    $rootScope.msg().text = "Sorry an error occured. Please try again";
                    $rootScope.msg().type = "danger";
                    $rootScope.msg().show = true;
                });
            }, function(error) {
                $scope.saving = false;
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });


        }, function(error) {
            $scope.saving = false;
            $rootScope.msg().text = error.data.text;
            $rootScope.msg().type = error.data.type;
            $rootScope.msg().show = true;
        });

        $rootScope.saveBindingForSegment();
    };


    var searchById = function(id) {
        var children = $rootScope.igdocument.profile.segmentLibrary.children;
        for (var i = 0; i < $rootScope.igdocument.profile.segmentLibrary.children; i++) {
            if (children[i].id === id) {
                return children[i];
            }
        }
        return null;
    };

    var indexOf = function(id) {
        var children = $rootScope.igdocument.profile.segmentLibrary.children;
        for (var i = 0; i < children; i++) {
            if (children[i].id === id) {
                return i;
            }
        }
        return -1;

    };


    $scope.showSelectDatatypeFlavorDlg = function(field) {
        var modalInstance = $modal.open({
            templateUrl: 'SelectDatatypeFlavor.html',
            controller: 'SelectDatatypeFlavorCtrl',
            windowClass: 'flavor-modal-window',
            resolve: {
                currentDatatype: function() {
                    return $rootScope.datatypesMap[field.datatype.id];
                },

                hl7Version: function() {
                    return $rootScope.igdocument.profile.metaData.hl7Version;
                },

                datatypeLibrary: function() {
                    return $rootScope.igdocument.profile.datatypeLibrary;
                }
            }
        });
        modalInstance.result.then(function(datatype) {
            //                MastermapSvc.deleteElementChildren(field.datatype.id, "datatype", field.id, field.type);
            field.datatype.id = datatype.id;

            field.datatype.name = datatype.name;
            field.datatype.ext = datatype.ext;
            $rootScope.processElement(field);
            $scope.setDirty();
            //                MastermapSvc.addDatatypeId(datatype.id, [field.id, field.type]);
            if ($scope.segmentsParams)
                $scope.segmentsParams.refresh();
        });

    };

    $scope.showEditDynamicMappingDlg = function(node) {
        var modalInstance = $modal.open({
            templateUrl: 'DynamicMappingCtrl.html',
            controller: 'DynamicMappingCtrl',
            windowClass: 'app-modal-window',
            resolve: {
                selectedNode: function(

                ) {
                    return node;
                }
            }
        });
        modalInstance.result.then(function(node) {
            $scope.selectedNode = node;
            $scope.setDirty();
            $scope.segmentsParams.refresh();
        }, function() {});
    };

});
angular.module('igl').controller('SegmentRowCtrl', function($scope, $filter) {
    $scope.formName = "form_" + new Date().getTime();
});
angular.module('igl').controller('DynamicMappingCtrl', function($scope, $modalInstance, selectedNode, $rootScope) {
    $scope.changed = false;
    $scope.selectedNode = selectedNode;
    $scope.selectedMapping = angular.copy(_.find($rootScope.segment.dynamicMapping.mappings, function(mapping) {
        return mapping.position == $scope.selectedNode.position;
    }));
    if (!$scope.selectedMapping) {
        $scope.selectedMapping = {};
        $scope.selectedMapping.cases = [];
        $scope.selectedMapping.position = $scope.selectedNode.position;
    }

    $scope.deleteCase = function(c) {
        var index = $scope.selectedMapping.cases.indexOf(c);
        $scope.selectedMapping.cases.splice(index, 1);
        $scope.recordChange();
    };

    $scope.addCase = function() {
        var newCase = {
            id: new ObjectId().toString(),
            type: 'case',
            value: '',
            datatype: null
        };

        $scope.selectedMapping.cases.unshift(newCase);
        $scope.recordChange();
    };

    $scope.recordChange = function() {
        $scope.changed = true;
        // $scope.editForm.$dirty = true;
    };


    $scope.updateMapping = function() {
        var oldMapping = _.find($rootScope.segment.dynamicMapping.mappings, function(mapping) {
            return mapping.position == $scope.selectedNode.position;
        });
        var index = $rootScope.segment.dynamicMapping.mappings.indexOf(oldMapping);
        $rootScope.segment.dynamicMapping.mappings.splice(index, 1);
        $rootScope.segment.dynamicMapping.mappings.unshift($scope.selectedMapping);
        $scope.changed = false;
        $scope.ok();
    };

    $scope.ok = function() {
        $modalInstance.close($scope.selectedNode);
    };

});
angular.module('igl').controller('TableMappingSegmentCtrl', function($scope, $modalInstance, selectedNode, $rootScope) {
    $scope.changed = false;
    $scope.selectedNode = selectedNode;
    $scope.selectedTable = null;
    if (selectedNode.table != undefined) {
        $scope.selectedTable = $rootScope.tablesMap[selectedNode.table.id];
    }

    $scope.selectTable = function(table) {
        $scope.selectedTable = table;
        $scope.changed = true;
    };


    $scope.mappingTable = function() {
        if ($scope.selectedNode.table == null || $scope.selectedNode.table == undefined) $scope.selectedNode.table = {};
        $scope.selectedNode.table.id = $scope.selectedTable.id;
        $scope.selectedNode.table.bindingIdentifier = $scope.selectedTable.bindingIdentifier;
        $rootScope.recordChangeForEdit2('field', 'edit', $scope.selectedNode.id, 'table', $scope.selectedNode.table.id);
        $scope.ok();
    };

    $scope.ok = function() {
        $modalInstance.close($scope.selectedNode);
    };

});
angular.module('igl').controller('ManageCoConstraintsTableCtrl', function($scope, $modalInstance, segment, $rootScope) {
    $scope.newColumnField = '';
    $scope.newColumnConstraintType = '';
    $scope.selectedSegment = angular.copy(segment);
    $scope.addColumnCoConstraints = function() {
        var newColumn = {
            field: JSON.parse($scope.newColumnField),
            constraintType: $scope.newColumnConstraintType,
            columnPosition: $scope.selectedSegment.coConstraints.columnList.length
        };
        for (var i = 0, len1 = $scope.selectedSegment.coConstraints.constraints.length; i < len1; i++) {
            var v = {};
            v.value = '';
            $scope.selectedSegment.coConstraints.constraints[i].values.push(v);
        };
        $scope.selectedSegment.coConstraints.columnList.push(newColumn);

        $scope.newColumnField = '';
        $scope.newColumnConstraintType = '';
    };

    $scope.deleteColumn = function(column) {
        var index = $scope.selectedSegment.coConstraints.columnList.indexOf(column);

        if (index > -1) {
            var columnPosition = $scope.selectedSegment.coConstraints.columnList[index].columnPosition;
            $scope.selectedSegment.coConstraints.columnList.splice(index, 1);

            for (var i = 0, len1 = $scope.selectedSegment.coConstraints.columnList.length; i < len1; i++) {
                if ($scope.selectedSegment.coConstraints.columnList[i].columnPosition > columnPosition) {
                    $scope.selectedSegment.coConstraints.columnList[i].columnPosition = $rootScope.segment.coConstraints.columnList[i].columnPosition - 1;
                }
            }

            for (var i = 0, len1 = $scope.selectedSegment.coConstraints.constraints.length; i < len1; i++) {
                $scope.selectedSegment.coConstraints.constraints[i].values.splice(columnPosition, 1);
            };
        }

    };

    $scope.checkFieldExisting = function(field) {
        for (var i = 0, len1 = $scope.selectedSegment.coConstraints.columnList.length; i < len1; i++) {
            if ($scope.selectedSegment.coConstraints.columnList[i].field.position == field.position) {
                return true;
            }
        }
        return false;
    };

    $scope.saveAndClose = function() {
        $rootScope.segment.coConstraints = $scope.selectedSegment.coConstraints;
        $modalInstance.close();
    };

    $scope.close = function() {
        $modalInstance.close();
    };

});
angular.module('igl').controller('PredicateSegmentCtrl', function($scope, $modalInstance, selectedNode, $rootScope, $q) {
    $scope.selectedNode = selectedNode;
    $scope.constraintType = 'Plain';
    $scope.constraints = [];
    $scope.firstConstraint = null;
    $scope.secondConstraint = null;
    $scope.compositeType = null;
    $scope.complexConstraint = null;
    $scope.changed = false;
    $scope.existingPredicate = null;
    $scope.tempPredicates = [];
    $scope.selectedSegment = angular.copy($rootScope.segment);
    $scope.predicateData = null;

    $scope.treeDataForContext = [];
    $scope.treeDataForContext.push($scope.selectedSegment);
    $scope.treeDataForContext[0].pathInfoSet = [];
    $scope.generatePathInfo = function(current, positionNumber, locationName, instanceNumber, isInstanceNumberEditable, nodeName) {
        var pathInfo = {};
        pathInfo.positionNumber = positionNumber;
        pathInfo.locationName = locationName;
        pathInfo.nodeName = nodeName;
        pathInfo.instanceNumber = instanceNumber;
        pathInfo.isInstanceNumberEditable = isInstanceNumberEditable;
        current.pathInfoSet.push(pathInfo);

        if (current.type == 'segment') {
            var seg = current;
            for (var i in seg.fields) {
                var f = seg.fields[i];
                f.pathInfoSet = angular.copy(current.pathInfoSet);

                var childPositionNumber = f.position;
                var childLocationName = f.position;
                var childNodeName = f.name;
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                if (f.max != '1') {
                    childInstanceNumber = '*';
                    childisInstanceNumberEditable = true;
                }
                var child = angular.copy($rootScope.datatypesMap[f.datatype.id]);
                child.id = new ObjectId().toString();
                f.child = child;
                $scope.generatePathInfo(f, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName);
            }
        } else if (current.type == 'field' || current.type == 'component') {
            var dt = current.child;
            for (var i in dt.components) {
                var c = dt.components[i];
                c.pathInfoSet = angular.copy(current.pathInfoSet);
                var childPositionNumber = c.position;
                var childLocationName = c.position;
                var childNodeName = c.name;
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                var child = angular.copy($rootScope.datatypesMap[c.datatype.id]);
                child.id = new ObjectId().toString();
                c.child = child;
                $scope.generatePathInfo(c, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName);
            }
        }
    };

    $scope.generatePathInfo($scope.treeDataForContext[0], ".", ".", "1", false);

    $scope.toggleChildren = function(data) {
        data.childrenVisible = !data.childrenVisible;
        data.folderClass = data.childrenVisible ? "fa-minus" : "fa-plus";
    };

    $scope.beforeNodeDrop = function() {
        var deferred = $q.defer();
        deferred.resolve();
        return deferred.promise;
    };

    $scope.afterNodeDrop = function() {
        $scope.draggingStatus = null;
        $scope.newConstraint.pathInfoSet_1 = $scope.firstNodeData.pathInfoSet;
        $scope.generateFirstPositionAndLocationPath();
    };

    $scope.afterSecondNodeDrop = function() {
        $scope.draggingStatus = null;
        $scope.newConstraint.pathInfoSet_2 = $scope.secondNodeData.pathInfoSet;
        $scope.generateSecondPositionAndLocationPath();
    };

    $scope.beforePredicateDrop = function() {
        var deferred = $q.defer();

        if ($scope.draggingStatus === 'PredicateDragging') {
            $scope.predicateData = null;
            deferred.resolve();
        } else {
            deferred.reject();
        }
        return deferred.promise;
    };

    $scope.afterPredicateDrop = function() {
        $scope.draggingStatus = null;
        $scope.existingPredicate = $scope.predicateData;
        $scope.existingPredicate.constraintTarget = $scope.selectedNode.position + '[1]';
    };



    $scope.draggingPredicate = function(event, ui, nodeData) {
        $scope.draggingStatus = 'PredicateDragging';
    };

    $scope.draggingNodeFromContextTree = function(event, ui, data) {
        $scope.draggingStatus = 'ContextTreeNodeDragging';
    };

    $scope.setChanged = function() {
        $scope.changed = true;
    }

    $scope.initPredicate = function() {
        $scope.newConstraint = angular.fromJson({
            pathInfoSet_1: null,
            pathInfoSet_2: null,
            position_1: null,
            position_2: null,
            location_1: null,
            location_2: null,
            freeText: null,
            verb: null,
            ignoreCase: false,
            contraintType: null,
            value: null,
            value2: null,
            valueSetId: null,
            bindingStrength: 'R',
            bindingLocation: '1'
        });
    };

    $scope.initComplexPredicate = function() {
        $scope.constraints = [];
        $scope.firstConstraint = null;
        $scope.secondConstraint = null;
        $scope.compositeType = null;
    };

    $scope.generateFirstPositionAndLocationPath = function() {
        if ($scope.newConstraint.pathInfoSet_1) {
            var positionPath = '';
            var locationPath = '';
            for (var i in $scope.newConstraint.pathInfoSet_1) {
                if (i > 0) {
                    var pathInfo = $scope.newConstraint.pathInfoSet_1[i];
                    positionPath = positionPath + "." + pathInfo.positionNumber + "[" + pathInfo.instanceNumber + "]";
                    locationPath = locationPath + "." + pathInfo.locationName + "[" + pathInfo.instanceNumber + "]";

                    if (i == $scope.newConstraint.pathInfoSet_1.length - 1) {
                        locationPath = locationPath + " (" + pathInfo.nodeName + ")";
                    }
                }
            }

            $scope.newConstraint.position_1 = positionPath.substr(1);
            $scope.newConstraint.location_1 = $rootScope.segment.name + '-' + locationPath.substr(1);
        }
    };

    $scope.generateSecondPositionAndLocationPath = function() {
        if ($scope.newConstraint.pathInfoSet_2) {
            var positionPath = '';
            var locationPath = '';
            for (var i in $scope.newConstraint.pathInfoSet_2) {
                if (i > 0) {
                    var pathInfo = $scope.newConstraint.pathInfoSet_2[i];
                    positionPath = positionPath + "." + pathInfo.positionNumber + "[" + pathInfo.instanceNumber + "]";
                    locationPath = locationPath + "." + pathInfo.locationName + "[" + pathInfo.instanceNumber + "]";

                    if (i == $scope.newConstraint.pathInfoSet_2.length - 1) {
                        locationPath = locationPath + " (" + pathInfo.nodeName + ")";
                    }
                }
            }

            $scope.newConstraint.position_2 = positionPath.substr(1);
            $scope.newConstraint.location_2 = $rootScope.segment.name + '-' + locationPath.substr(1);
        }
    };

    $scope.findExistingPredicate = function() {
        for (var i = 0, len1 = $scope.selectedSegment.predicates.length; i < len1; i++) {
            if ($scope.selectedSegment.predicates[i].constraintTarget.indexOf($scope.selectedNode.position + '[') === 0)
                return $scope.selectedSegment.predicates[i];
        }
    };

    $scope.deletePredicate = function() {
        $scope.existingPredicate = null;
        $scope.setChanged();
    };

    $scope.deleteTempPredicate = function(predicate) {
        $scope.tempPredicates.splice($scope.tempPredicates.indexOf(predicate), 1);
    };

    $scope.deletePredicateByTarget = function() {
        for (var i = 0, len1 = $scope.selectedSegment.predicates.length; i < len1; i++) {
            if ($scope.selectedSegment.predicates[i].constraintTarget.indexOf($scope.selectedNode.position + '[') === 0) {
                $scope.selectedSegment.predicates.splice($scope.selectedSegment.predicates.indexOf($scope.selectedSegment.predicates[i]), 1);
                return true;
            }
        }
        return false;
    };

    $scope.addComplexPredicate = function() {
        $scope.complexConstraint = $rootScope.generateCompositePredicate($scope.compositeType, $scope.firstConstraint, $scope.secondConstraint, $scope.constraints);
        $scope.complexConstraint.constraintId = $scope.newConstraint.segment + '-' + $scope.selectedNode.position;
        $scope.tempPredicates.push($scope.complexConstraint);
        $scope.initComplexPredicate();
        $scope.changed = true;
    };

    $scope.addFreeTextPredicate = function() {
        var cp = $rootScope.generateFreeTextPredicate($scope.selectedNode.position + '[1]', $scope.newConstraint);
        $scope.tempPredicates.push(cp);
        $scope.changed = true;
        $scope.initPredicate();
    };

    $scope.addPredicate = function() {
        var cp = $rootScope.generatePredicate($scope.selectedNode.position + '[1]', $scope.newConstraint);
        $scope.tempPredicates.push(cp);
        $scope.changed = true;
        $scope.initPredicate();
    };

    $scope.ok = function() {
        $modalInstance.close();
    };

    $scope.saveclose = function() {
        $scope.deletePredicateByTarget();
        $scope.selectedSegment.predicates.push($scope.existingPredicate);
        $rootScope.recordChanged();
        $modalInstance.close($scope.selectedSegment);
    };

    $scope.initPredicate();
    $scope.initComplexPredicate();
    $scope.existingPredicate = $scope.findExistingPredicate();

});
angular.module('igl').controller('ConformanceStatementSegmentCtrl', function($scope, $modalInstance, $rootScope, $q) {
    $scope.constraintType = 'Plain';
    $scope.constraints = [];
    $scope.firstConstraint = null;
    $scope.secondConstraint = null;
    $scope.compositeType = null;
    $scope.complexConstraint = null;
    $scope.newComplexConstraintId = $rootScope.calNextCSID($rootScope.igdocument.metaData.ext, $rootScope.segment.name + "_" + $rootScope.segment.ext);
    $scope.newComplexConstraint = [];
    $scope.firstNodeData = null;
    $scope.secondNodeData = null;
    $scope.changed = false;
    $scope.tempComformanceStatements = [];
    angular.copy($rootScope.segment.conformanceStatements, $scope.tempComformanceStatements);

    $scope.treeDataForContext = [];
    $scope.treeDataForContext.push(angular.copy($rootScope.segment));
    $scope.treeDataForContext[0].pathInfoSet = [];
    $scope.generatePathInfo = function(current, positionNumber, locationName, instanceNumber, isInstanceNumberEditable, nodeName) {
        var pathInfo = {};
        pathInfo.positionNumber = positionNumber;
        pathInfo.locationName = locationName;
        pathInfo.nodeName = nodeName;
        pathInfo.instanceNumber = instanceNumber;
        pathInfo.isInstanceNumberEditable = isInstanceNumberEditable;
        current.pathInfoSet.push(pathInfo);

        if (current.type == 'segment') {
            var seg = current;
            for (var i in seg.fields) {
                var f = seg.fields[i];
                f.pathInfoSet = angular.copy(current.pathInfoSet);

                var childPositionNumber = f.position;
                var childLocationName = f.position;
                var childNodeName = f.name;
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                if (f.max != '1') {
                    childInstanceNumber = '*';
                    childisInstanceNumberEditable = true;
                }
                var child = angular.copy($rootScope.datatypesMap[f.datatype.id]);
                child.id = new ObjectId().toString();
                f.child = child;
                $scope.generatePathInfo(f, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName);
            }
        } else if (current.type == 'field' || current.type == 'component') {
            var dt = current.child;
            for (var i in dt.components) {
                var c = dt.components[i];
                c.pathInfoSet = angular.copy(current.pathInfoSet);
                var childPositionNumber = c.position;
                var childLocationName = c.position;
                var childNodeName = c.name;
                var childInstanceNumber = "1";
                var childisInstanceNumberEditable = false;
                var child = angular.copy($rootScope.datatypesMap[c.datatype.id]);
                child.id = new ObjectId().toString();
                c.child = child;
                $scope.generatePathInfo(c, childPositionNumber, childLocationName, childInstanceNumber, childisInstanceNumberEditable, childNodeName);
            }
        }
    };

    $scope.generatePathInfo($scope.treeDataForContext[0], ".", ".", "1", false);


    $scope.setChanged = function() {
        $scope.changed = true;
    };

    $scope.toggleChildren = function(data) {
        data.childrenVisible = !data.childrenVisible;
        data.folderClass = data.childrenVisible ? "fa-minus" : "fa-plus";
    };

    $scope.beforeNodeDrop = function() {
        var deferred = $q.defer();
        deferred.resolve();
        return deferred.promise;
    };

    $scope.afterNodeDrop = function() {
        $scope.draggingStatus = null;
        $scope.newConstraint.pathInfoSet_1 = $scope.firstNodeData.pathInfoSet;
        $scope.generateFirstPositionAndLocationPath();
    };

    $scope.afterSecondNodeDrop = function() {
        $scope.draggingStatus = null;
        $scope.newConstraint.pathInfoSet_2 = $scope.secondNodeData.pathInfoSet;
        $scope.generateSecondPositionAndLocationPath();
    };

    $scope.draggingNodeFromContextTree = function(event, ui, data) {
        $scope.draggingStatus = 'ContextTreeNodeDragging';
    };

    $scope.initConformanceStatement = function() {
        $scope.newConstraint = angular.fromJson({
            pathInfoSet_1: null,
            pathInfoSet_2: null,
            position_1: null,
            position_2: null,
            location_1: null,
            location_2: null,
            freeText: null,
            verb: null,
            ignoreCase: false,
            constraintId: $rootScope.calNextCSID($rootScope.igdocument.metaData.ext, $rootScope.segment.name + "_" + $rootScope.segment.ext),
            contraintType: null,
            value: null,
            value2: null,
            valueSetId: null,
            bindingStrength: 'R',
            bindingLocation: '1'
        });
    };

    $scope.initComplexStatement = function() {
        $scope.constraints = [];
        $scope.firstConstraint = null;
        $scope.secondConstraint = null;
        $scope.compositeType = null;
        $scope.newComplexConstraintId = $rootScope.calNextCSID($rootScope.igdocument.metaData.ext, $rootScope.segment.name + "_" + $rootScope.segment.ext);
    };

    $scope.initConformanceStatement();

    $scope.generateFirstPositionAndLocationPath = function() {
        if ($scope.newConstraint.pathInfoSet_1) {
            var positionPath = '';
            var locationPath = '';
            for (var i in $scope.newConstraint.pathInfoSet_1) {
                if (i > 0) {
                    var pathInfo = $scope.newConstraint.pathInfoSet_1[i];
                    positionPath = positionPath + "." + pathInfo.positionNumber + "[" + pathInfo.instanceNumber + "]";
                    locationPath = locationPath + "." + pathInfo.locationName + "[" + pathInfo.instanceNumber + "]";

                    if (i == $scope.newConstraint.pathInfoSet_1.length - 1) {
                        locationPath = locationPath + " (" + pathInfo.nodeName + ")";
                    }
                }
            }

            $scope.newConstraint.position_1 = positionPath.substr(1);
            $scope.newConstraint.location_1 = $rootScope.segment.name + '-' + locationPath.substr(1);
        }
    };

    $scope.generateSecondPositionAndLocationPath = function() {
        if ($scope.newConstraint.pathInfoSet_2) {
            var positionPath = '';
            var locationPath = '';
            for (var i in $scope.newConstraint.pathInfoSet_2) {
                if (i > 0) {
                    var pathInfo = $scope.newConstraint.pathInfoSet_2[i];
                    positionPath = positionPath + "." + pathInfo.positionNumber + "[" + pathInfo.instanceNumber + "]";
                    locationPath = locationPath + "." + pathInfo.locationName + "[" + pathInfo.instanceNumber + "]";

                    if (i == $scope.newConstraint.pathInfoSet_2.length - 1) {
                        locationPath = locationPath + " (" + pathInfo.nodeName + ")";
                    }
                }
            }

            $scope.newConstraint.position_2 = positionPath.substr(1);
            $scope.newConstraint.location_2 = $rootScope.segment.name + '-' + locationPath.substr(1);
        }
    };

    $scope.deleteConformanceStatement = function(conformanceStatement) {
        $scope.tempComformanceStatements.splice($scope.tempComformanceStatements.indexOf(conformanceStatement), 1);
        $scope.changed = true;
    };

    $scope.addComplexConformanceStatement = function() {
        $scope.complexConstraint = $rootScope.generateCompositeConformanceStatement($scope.compositeType, $scope.firstConstraint, $scope.secondConstraint, $scope.constraints);
        $scope.tempComformanceStatements.push($scope.complexConstraint);
        $scope.initComplexStatement();
        $scope.changed = true;
    };

    $scope.addFreeTextConformanceStatement = function() {
        var cs = $rootScope.generateFreeTextConformanceStatement($scope.newConstraint);
        $scope.tempComformanceStatements.push(cs);
        $scope.changed = true;
        $scope.initConformanceStatement();
    };

    $scope.addConformanceStatement = function() {
        var cs = $rootScope.generateConformanceStatement($scope.newConstraint);
        $scope.tempComformanceStatements.push(cs);
        $scope.changed = true;
        $scope.initConformanceStatement();
    };

    $scope.ok = function() {
        $modalInstance.close();
    };

    $scope.saveclose = function() {
        angular.copy($scope.tempComformanceStatements, $rootScope.segment.conformanceStatements);
        $rootScope.recordChanged($rootScope.segment);
        $modalInstance.close();
    };
});
angular.module('igl').controller('ConfirmSegmentDeleteCtrl', function($scope, $rootScope, $modalInstance, segToDelete, $rootScope, SegmentService, SegmentLibrarySvc, MastermapSvc, CloneDeleteSvc) {
    $scope.segToDelete = segToDelete;
    $scope.loading = false;

    $scope.delete = function() {
        $scope.loading = true;
        if ($scope.segToDelete.scope === 'USER') {
            CloneDeleteSvc.deleteSegmentAndSegmentLink($scope.segToDelete);
        } else {
            CloneDeleteSvc.deleteSegmentLink($scope.segToDelete);
        }
        $modalInstance.close($scope.segToDelete);
        $scope.loading = false;
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});
angular.module('igl').controller('SegmentReferencesCtrl', function($scope, $modalInstance, segToDelete) {

    $scope.segToDelete = segToDelete;

    $scope.ok = function() {
        $modalInstance.close($scope.segToDelete);
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});
angular.module('igl').controller('AddFieldCtrl', function($scope, $modalInstance, datatypes, segment, valueSets, $rootScope, $http, ngTreetableParams, SegmentService, DatatypeLibrarySvc, MessageService, blockUI) {;


    $scope.valueSets = valueSets;
    $scope.datatypes = datatypes;

    // console.log("$scope.valueSets");
    // console.log($scope.valueSets);
    // console.log("$scope.datatypes");
    // console.log($scope.datatypes);


    $scope.newField = {
        comment: "",
        confLength: "",
        datatype: {
            ext: null,
            id: "",
            label: "",
            name: ""
        },
        hide: false,
        added: "yes",
        id: "",
        itemNo: "",
        max: "",
        maxLength: "",
        min: "",
        minLength: "",
        name: "",
        position: "",
        table: {
            bindingIdentifier: "",
            bindingLocation: null,
            bindingStrength: null,
            id: ""
        },
        text: "",
        type: "field",
        usage: ""


    };

    $scope.$watch('DT', function() {
        if ($scope.DT) {
            $scope.newField.datatype.ext = $scope.DT.ext;
            $scope.newField.datatype.id = $scope.DT.id;
            $scope.newField.datatype.name = $scope.DT.name;


        }
        // console.log($scope.DT);

    }, true);
    $scope.loadVS = function($query) {


        return valueSets.filter(function(table) {
            return table.bindingIdentifier.toLowerCase().indexOf($query.toLowerCase()) != -1;
        });

    };
    $scope.tableList = [];
    $scope.tagAdded = function(tag) {
        $scope.vsChanged = true;
        $scope.tableList.push({
            id: tag.id,
            bindingIdentifier: tag.bindingIdentifier,
            bindingLocation: null,
            bindingStrength: null
        });


        //$scope.log.push('Added: ' + tag.text);
    };

    $scope.tagRemoved = function(tag) {
        $scope.vsChanged = true;

        for (var i = 0; i < $scope.tableList.length; i++) {
            if ($scope.tableList[i].id === tag.id) {
                $scope.tableList.splice(i, 1);
            }
        };


    };

    // $scope.$watch('VS', function() {
    //     if ($scope.VS) {
    //         $scope.newField.table.bindingIdentifier = $scope.VS.bindingIdentifier;
    //         $scope.newField.table.id = $scope.VS.id;


    //     }
    //     console.log($scope.VS);

    // }, true);

    $scope.selectUsage = function(usage) {
        // console.log(usage);
        if (usage === 'X' || usage === 'W') {
            $scope.newField.max = 0;
            $scope.newField.min = 0;
            $scope.disableMin = true;
            $scope.disableMax = true;

        } else if (usage === 'R') {
            $scope.newField.min = 1;

            $scope.disableMin = true;
            $scope.disableMax = false;
        } else if (usage === 'RE' || usage === 'O') {
            $scope.newField.min = 0;

            $scope.disableMin = true;
            $scope.disableMax = false;

        } else {
            $scope.disableMin = false;
            $scope.disableMax = false;

        }

    };



    $scope.selectDT = function(datatype) {
        $scope.DT = datatype;
        //$scope.newSeg = segment;
    };
    $scope.selectedDT = function() {
        return ($scope.DT !== undefined);
        //return ($scope.newSeg !== undefined);
    };
    $scope.unselectDT = function() {
        $scope.DT = undefined;
        //$scope.newSeg = undefined;
    };
    $scope.isDTActive = function(id) {
        if ($scope.DT) {
            return $scope.DT.id === id;
        } else {
            return false;
        }

    };


    $scope.selectVS = function(valueSet) {
        $scope.VS = valueSet;
        //$scope.newSeg = segment;
    };
    $scope.selectedVS = function() {
        return ($scope.VS !== undefined);
        //return ($scope.newSeg !== undefined);
    };
    $scope.unselectVS = function() {
        $scope.VS = undefined;
        //$scope.newSeg = undefined;
    };
    $scope.isVSActive = function(id) {
        if ($scope.VS) {
            return $scope.VS.id === id;
        } else {
            return false;
        }

    };


    $scope.addField = function() {
        blockUI.start();
        if ($rootScope.segment.fields.length !== 0) {
            $scope.newField.position = $rootScope.segment.fields[$rootScope.segment.fields.length - 1].position + 1;

        } else {
            $scope.newField.position = 1
        }
        $scope.newField.id = new ObjectId().toString();
        $scope.newField.tables = $scope.tableList;

        if ($rootScope.segment != null) {
            if (!$rootScope.segment.fields || $rootScope.segment.fields === null)
                $rootScope.segment.fields = [];
            $rootScope.segment.fields.push($scope.newField);
            MessageService.updatePosition(segment.fields, $scope.newField.position - 1, $scope.position - 1);



            if ($scope.segmentsParams) {
                $scope.segmentsParams.refresh();
            }

        }
        blockUI.stop();
        $modalInstance.close();

    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


});
angular.module('igl').controller('DeleteFieldCtrl', function($scope, $modalInstance, fieldToDelete, segment, $rootScope, SegmentService, blockUI) {
    $scope.fieldToDelete = fieldToDelete;
    $scope.loading = false;
    // console.log(segment);
    // console.log($scope.fieldToDelete);
    $scope.updatePosition = function(node) {
        angular.forEach(node.fields, function(field) {
            field.position = node.fields.indexOf(field) + 1;

        })

    };
    $scope.delete = function() {
        blockUI.start();
        $scope.loading = true;
        segment.fields.splice(fieldToDelete.position - 1, 1);


        $rootScope.msg().text = "FieldDeleteSuccess";

        $rootScope.msg().type = "success";
        $rootScope.msg().show = true;
        $rootScope.manualHandle = true;
        $scope.loading = false;
        $scope.updatePosition(segment);
        blockUI.stop();
        $modalInstance.close($scope.fieldToDelete);
    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


});
angular.module('igl').controller('EditVSCtrl', function($scope, $modalInstance, valueSets, field, $rootScope, SegmentService, blockUI) {
    console.log("field");
    console.log(field);
    $scope.vsChanged = false;
    $scope.field = field;
    if (field.attributes) {
        if (field.attributes.tables && field.attributes.tables.length > 0) {
            $scope.vs = angular.copy(field.attributes.tables);
            $scope.tableList = angular.copy(field.attributes.tables);
        } else {
            $scope.vs = [];
            $scope.tableList = [];
        }

    } else {
        $scope.vs = angular.copy(field.tables);
        $scope.tableList = angular.copy(field.tables);
    }

    $scope.loadVS = function($query) {


        return valueSets.filter(function(table) {
            return table.bindingIdentifier.toLowerCase().indexOf($query.toLowerCase()) != -1;
        });

    };
    $scope.tagAdded = function(tag) {
        $scope.vsChanged = true;
        $scope.tableList.push({
            id: tag.id,
            bindingIdentifier: tag.bindingIdentifier,
            bindingLocation: null,
            bindingStrength: null
        });


        //$scope.log.push('Added: ' + tag.text);
    };

    $scope.tagRemoved = function(tag) {
        $scope.vsChanged = true;

        for (var i = 0; i < $scope.tableList.length; i++) {
            if ($scope.tableList[i].id === tag.id) {
                $scope.tableList.splice(i, 1);
            }
        };


    };

    $scope.addVS = function() {
        blockUI.start();

        $scope.vsChanged = false;
        if (field.attributes) {
            field.attributes.tables = $scope.tableList;
        } else {
            field.tables = $scope.tableList;
        }



        blockUI.stop();

        $modalInstance.close();


    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


});
angular.module('igl').controller('otherDTCtrl', function($scope, $modalInstance, datatypes, field, $rootScope, SegmentService, blockUI) {

    $scope.dtChanged = false;
    $scope.field = field;
    var oldDt = angular.copy(field.datatype);
    $scope.datatypes = datatypes;
    //$scope.vs = angular.copy(field.tables);
    //$scope.tableList = angular.copy(field.tables);;

    $scope.isInDts = function(datatype) {

        if (datatype && $scope.datatypes.indexOf(datatype) === -1) {
            return false;
        } else {
            return true;
        }

    };
    $scope.getDtLabel = function(element) {
        if (element) {
            if (element.ext !== null) {
                return element.name + "_" + element.ext;
            } else {
                return element.name;
            }
        }
        return "";
    };
    $scope.addDT = function() {
        blockUI.start();

        $scope.dtChanged = false;

        field.datatype = {
            id: $scope.newDt.id,
            name: $scope.newDt.name,
            ext: $scope.newDt.ext
        };

        blockUI.stop();

        $modalInstance.close();


    };


    $scope.cancel = function() {
        field.datatype = oldDt;
        $modalInstance.close();
    };


});
angular.module('igl').controller('cmpSegmentCtrl', function($scope, $modal, ObjectDiff, orderByFilter, $rootScope, $q, $interval, ngTreetableParams, $http, StorageService, userInfoService, IgDocumentService, SegmentService, DatatypeService, SegmentLibrarySvc, DatatypeLibrarySvc, TableLibrarySvc, CompareService) {



    $scope.segChanged = false;
    $scope.isDeltaCalled = false;
    var ctrl = this;
    this.segmentId = -1;
    $scope.setDeltaToF = function() {
        // console.log("HEEEEEEEEEEREREEE");
        $scope.isDeltaCalled = false;
    }


    $scope.scopes = [{
        name: "USER",
        alias: "My IG"
    }, {
        name: "HL7STANDARD",
        alias: "Base HL7"
    }];
    $scope.getLabel = function(element) {
        if (element) {
            if (element.ext !== null) {
                return element.name + "_" + element.ext;
            } else {
                return element.name;
            }
        }
        return "";
    };
    var listHL7Versions = function() {
        return $http.get('api/igdocuments/findVersions', {
            timeout: 60000
        }).then(function(response) {
            var hl7Versions = [];
            var length = response.data.length;
            for (var i = 0; i < length; i++) {
                hl7Versions.push(response.data[i]);
            }
            return hl7Versions;
        });
    };
    $scope.status = {
        isCustomHeaderOpen: false,
        isFirstOpen: true,
        isSecondOpen: false,
        isFirstDisabled: false
    };
    $scope.variable = false;

    $scope.initt = function() {
        $scope.isDeltaCalled = true;
        $scope.dataList = [];
        listHL7Versions().then(function(versions) {
            $scope.versions = versions;
            $scope.segment1 = angular.copy($rootScope.segment);
            $scope.version1 = angular.copy($scope.segment1.hl7Version);

            console.log($scope.segment1);
            ctrl.segmentId = -1;
            //$scope.setIG2($scope.ig2);
            $scope.variable = !$scope.variable;
            $scope.segList1 = angular.copy($rootScope.segments);
            $scope.dtList1 = angular.copy($rootScope.datatypes);
            $scope.version2 = angular.copy($rootScope.igdocument.profile.metaData.hl7Version);
            // console.log($scope.scopes);
            // console.log($scope.scopes[1]);
            //$scope.status.isFirstOpen = true;
            $scope.scope2 = "HL7STANDARD";
            if ($scope.dynamicSeg_params) {
                $scope.showDelta = true;
                $scope.status.isFirstOpen = true;
                $scope.dynamicSeg_params.refresh();
            }

        });


    };

    $scope.$on('event:loginConfirmed', function(event) {
        $scope.initt();
    });

    //$scope.initt();

    $rootScope.$on('event:initSegment', function(event) {
        // console.log("$scope.isDeltaCalled");
        // console.log($scope.isDeltaCalled);
        if ($scope.isDeltaCalled) {
            $scope.initt();
        }
        // $scope.initt();
    });

    $rootScope.$on('event:openSegDelta', function(event) {
        $scope.initt();
    });


    // $rootScope.$on('event:saveSegForDelta', function(event) {
    //     $scope.dataList = [];
    //     console.log("hereere=======");
    //     console.log($scope.segment2)
    //     console.log($scope.segments2);
    //     $scope.initt();
    // });

    $scope.scope1 = "USER";
    $scope.ig1 = angular.copy($rootScope.igdocument.metaData.title);

    $scope.setVersion2 = function(vr) {
        $scope.version2 = vr;

    };
    $scope.setScope2 = function(scope) {

        $scope.scope2 = scope;
    };

    $scope.$watchGroup(['segment1', 'segment2'], function() {
        $scope.segChanged = true;
        //$scope.segment1 = angular.copy($rootScope.activeSegment);


    }, true);
    $scope.$watchGroup(['version2', 'scope2', 'variable'], function() {
        $scope.igList2 = [];
        $scope.segments2 = [];
        $scope.ig2 = "";
        if ($scope.scope2 && $scope.version2) {
            // console.log("+++++++++++++++++++++++++++");
            IgDocumentService.getIgDocumentsByScopesAndVersion([$scope.scope2], $scope.version2).then(function(result) {
                if (result) {
                    // console.log($scope.scope2);
                    if ($scope.scope2 === "HL7STANDARD") {
                        $scope.igDisabled2 = true;
                        $scope.ig2 = {
                            id: result[0].id,
                            title: result[0].metaData.title
                        };
                        // console.log($scope.ig2);
                        $scope.igList2.push($scope.ig2);

                        $scope.setIG2($scope.ig2);
                    } else {
                        $scope.igDisabled2 = false;
                        for (var i = 0; i < result.length; i++) {
                            $scope.igList2.push({
                                id: result[i].id,
                                title: result[i].metaData.title,
                            });
                        }
                    }
                }
            });

        }

    }, true);
    $scope.setSegment2 = function(segment) {

        if (segment === -1) {
            $scope.segment2 = {};
        } else {
            $scope.segment2 = $scope.segments2[segment];
            console.log($scope.segment2);

        }
        //$scope.segment2 = segment;
    };
    $scope.setIG2 = function(ig) {
        if (ig) {
            IgDocumentService.getOne(ig.id).then(function(igDoc) {
                SegmentLibrarySvc.getSegmentsByLibrary(igDoc.profile.segmentLibrary.id).then(function(segments) {
                    DatatypeLibrarySvc.getDatatypesByLibrary(igDoc.profile.datatypeLibrary.id).then(function(datatypes) {
                        TableLibrarySvc.getTablesByLibrary(igDoc.profile.tableLibrary.id).then(function(tables) {
                            $scope.segments2 = [];
                            if (igDoc) {
                                $scope.segList2 = angular.copy(segments);
                                //$scope.segList2 = orderByFilter($scope.segList2, 'name');
                                $scope.dtList2 = angular.copy(datatypes);
                                $scope.tableList2 = angular.copy(tables);
                                //$scope.messages2 = orderByFilter(igDoc.profile.messages.children, 'name');
                                $scope.segments2 = orderByFilter(segments, 'name');

                            }
                        });
                    });
                });

            });

            //$scope.messages2 = ($scope.findIGbyID(JSON.parse(ig).id)).profile.messages.children;

        }

    };

    $scope.hideSeg = function(seg1, seg2) {

        if (seg2) {
            return !(seg1.name === seg2.name);
        } else {
            return false;
        }
    };
    $scope.disableSeg = function(seg1, seg2) {

        if (seg2) {
            return (seg1.id === seg2.id);
        } else {
            return false;
        }
    };




    $scope.dynamicSeg_params = new ngTreetableParams({
        getNodes: function(parent) {
            if ($scope.dataList !== undefined) {

                //return parent ? parent.fields : $scope.test;
                if (parent) {
                    if (parent.fields) {
                        return parent.fields;
                    } else if (parent.components) {
                        return parent.components;
                    } else if (parent.segments) {
                        return parent.segments;
                    } else if (parent.codes) {
                        return parent.codes;
                    }

                } else {
                    return $scope.dataList;
                }

            }
        },
        getTemplate: function(node) {
            return 'tree_node';
        }
    });
    $scope.cmpSegment = function(segment1, segment2) {

        $scope.loadingSelection = true;
        $scope.segChanged = false;
        $scope.vsTemplate = false;
        $scope.dataList = CompareService.cmpSegment(JSON.stringify(segment1), JSON.stringify(segment2), $scope.dtList1, $scope.dtList2, $scope.segList1, $scope.segList2);

        $scope.loadingSelection = false;
        if ($scope.dynamicSeg_params) {
            $scope.showDelta = true;
            $scope.status.isSecondOpen = true;
            $scope.dynamicSeg_params.refresh();
        }

    };


});
angular.module('igl').controller('DeleteSegmentPredicateCtrl', function($scope, $modalInstance, position, segment, $rootScope) {
    $scope.selectedSegment = segment;
    $scope.position = position;
    $scope.delete = function() {
        for (var i = 0, len1 = $scope.selectedSegment.predicates.length; i < len1; i++) {
            if ($scope.selectedSegment.predicates[i].constraintTarget.indexOf($scope.position + '[') === 0) {
                $scope.selectedSegment.predicates.splice($scope.selectedSegment.predicates.indexOf($scope.selectedSegment.predicates[i]), 1);
                $modalInstance.close();
                return;
            }
        }
        $modalInstance.close();
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});
angular.module('igl').controller('AddBindingForSegment', function($scope, $modalInstance, $rootScope, segment) {
    // console.log($rootScope.references);
    $scope.segment = segment;
    $scope.selectedMessageForBinding = null;
    $scope.selectedSegRefForBinding = null;
    $scope.segRefsList = [];
    $scope.pathForBinding = null;

    $scope.init = function() {
        $scope.selectedMessageForBinding = null;
        $scope.selectedSegRefForBinding = null;
        $scope.segRefsList = [];
        $scope.pathForBinding = null;

    };

    $scope.checkDuplicated = function(positionPath) {
        for (var i = 0; i < $rootScope.references.length; i++) {
            var ref = $rootScope.references[i];
            if (ref.positionPath == positionPath) return true;
        }
        return false;
    };


    $scope.selectMessage = function() {
        $scope.selectedSegRefForBinding = null;
        $scope.segRefsList = [];
        $scope.pathForBinding = null;

        $scope.travelMessage($scope.selectedMessageForBinding.children, $scope.selectedMessageForBinding.name + '-' + $scope.selectedMessageForBinding.identifier, $scope.selectedMessageForBinding.name + '-' + $scope.selectedMessageForBinding.identifier);
    };

    $scope.travelMessage = function(children, positionPath, namePath) {
        angular.forEach(children, function(child) {
            if (child.type === 'group') {
                var groupNames = child.name.split(".");
                var groupName = groupNames[groupNames.length - 1];
                $scope.travelMessage(child.children, positionPath + '.' + child.position, namePath + '.' + groupName);
            } else {
                var s = $rootScope.segmentsMap[child.ref.id];
                if (s.name === $scope.segment.name) {
                    var segRef = {};
                    segRef.obj = child;
                    segRef.path = namePath + '.' + s.name;
                    segRef.positionPath = positionPath + '.' + child.position;
                    $scope.segRefsList.push(segRef);
                }
            }

        });
    }

    $scope.save = function() {
        var segmentLink = {};
        segmentLink.id = $scope.segment.id;
        segmentLink.name = $scope.segment.name;
        segmentLink.ext = $scope.segment.ext;
        segmentLink.isChanged = true;
        segmentLink.isNew = true;

        $scope.selectedSegRefForBinding = JSON.parse($scope.selectedSegRefForBinding);

        var ref = angular.copy($scope.selectedSegRefForBinding.obj);
        ref.path = $scope.selectedSegRefForBinding.path;
        ref.positionPath = $scope.selectedSegRefForBinding.positionPath;
        ref.target = angular.copy($scope.selectedMessageForBinding);
        ref.segmentLink = segmentLink;
        $rootScope.references.push(ref);

        $modalInstance.close();
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});
angular
    .module('igl')
    .controller(
    'shared', ['$scope', '$http', '$rootScope', '$q', '$modal','$timeout','ngTreetableParams', 'DatatypeLibraryDocumentSvc', 'TableLibrarySvc', 'DatatypeService', 'DatatypeLibrarySvc','IGDocumentSvc', 'TableService', 'ViewSettings', 'userInfoService',
    'blockUI','CompareService','VersionAndUseService', 'TableService',

        function ($scope, $http, $rootScope, $q, $modal, $timeout,ngTreetableParams, DatatypeLibraryDocumentSvc, TableLibrarySvc, DatatypeService, DatatypeLibrarySvc,IGDocumentSvc, TableService, ViewSettings, userInfoService, blockUI,CompareService,VersionAndUseService,TableService) {

            $scope.selectedTab==0;
            $rootScope.SharingScope=true;
            $scope.sharedElementView='sharedElementView';
            $scope.sharedElementViewForTables='sharedElementViewForTables.html';
            $scope.SharedtocViewForTables='';
            $scope.SharedDataTypeTree=[]
            $scope.typeOfSharing="Pending";
            $rootScope.datatype={};
            $rootScope.datatypesMap={};
            $rootScope.TablesMap={};
            $scope.tableTab=false;
            $scope.$on('event:openTableForShare', function (event, table) {
                $scope.selectTable(table); // Should we open in a dialog ??
            });

            $scope.datatypesParams = new ngTreetableParams({
              getNodes: function(parent) {
                  return DatatypeService.getNodes(parent, $rootScope.datatype);
              },
              getTemplate: function(node) {
                  return DatatypeService.getTemplate(node, $rootScope.datatype);
              }
            });
            $scope.datatypes = [];
            $scope.pendingDatatypes = [];
            $scope.pendingTables = [];

            $scope.setTypeOfSharing=function(type){
                $scope.typeOfSharing=type;
                if(type==='datatype'){
                    $scope.SharedtocView='sharedtocView.html';
                    $scope.getSharedDatatypes();
                } else if(type==='table') {
                	$scope.SharedtocViewForTables='sharedTabletocView.html';
                  $scope.SharedsubviewForTable="datatypePending.html";
                  $scope.getSharedTables();
                }
            };

         $scope.$on('event:openDatatypeonShare', function(event, datatype) {

            $scope.selectDatatype(datatype); // Should we open in a dialog ??
        });

         $scope.editTable=function(table){
        	 $rootScope.table=table;


         };

         $scope.getOwnerName = function(element) {
           if(!element.accountId) {
             return null;
           }
           return $http.get('api/shareparticipant', { params: { id: element.accountId } })
               .then(
                   function(response) {
                       element.owner = response.data.username + " - " + response.data.fullname;
                   },
                   function(error) {
                       console.log(error);
                   }
               );
         };

            $scope.init=function(){
            	$scope.pending=true;
                $scope.getSharedDatatypes();
                $scope.setTypeOfSharing('datatype');
                $scope.datatypeTab = { active: true};
                $scope.SharedtocView='sharedtocView.html';
                $scope.Sharedsubview = "datatypePending.html";
                $scope.SharedDataTypeTree=[$scope.library];
                $scope.SharedTableTree=[$scope.library];
            };

            $scope.showPending = function() {
            	$scope.pending=true;
              $scope.Sharedsubview = "datatypePending.html";
              $scope.SharedsubviewForTable="datatypePending.html";
            };

            $scope.getSharedDatatypes = function(){
                blockUI.start();

                // Reset has pending
                $scope.hasPending = false;

                DatatypeService.getSharedDatatypes().then(function(result){
                    $scope.datatypes = result;
                    angular.forEach($scope.datatypes, function(datatype){
                      $scope.getOwnerName(datatype);
                    	$rootScope.datatypesMap[datatype.id]=datatype;

                    });
                    blockUI.stop();
                });

                DatatypeService.getPendingSharedDatatypes().then(function(result){
                    $scope.pendingDatatypes = result;
                    angular.forEach($scope.pendingDatatypes, function(datatype){
                      $scope.getOwnerName(datatype);
                    	$rootScope.datatypesMap[datatype.id]=datatype;
                    });

                    if($scope.pendingDatatypes.length > 0) {
                      $scope.hasPending = true;
                    }
                });

              //  $scope.datatypes=[{id:1, name:"dummy",description:"dummy"},{id:2, name:"dummy",description:"dummy"}];
                // $scope.tables=[{id:3, name:"dummy",description:"dummy"},{id:4, name:"dummy",description:"dummy"}];
                // $scope.library={name:"bla"};


            };

            $scope.getSharedTables = function(){

              // Reset has pending
              $scope.hasPending = false;

                TableService.getSharedTables().then(function(result){
                    $scope.tables = result;
                    angular.forEach($scope.tables, function(table){
                      $scope.getOwnerName(table);
                    	$rootScope.tablesMap[table.id]=table;
                    });
                });

                TableService.getPendingSharedTables().then(function(result){
                    $scope.pendingTables = result;
                    angular.forEach($scope.pendingTables, function(table){
                      $scope.getOwnerName(table);
                    	$rootScope.tablesMap[table.id]=table;
                    });

                    if($scope.pendingTables.length > 0) {
                      $scope.hasPending = true;
                    }
                });
            };

          function processEditDataType(data) {
            console.log("dialog not opened");
            //$rootScope.datatype=data;
            $rootScope.datatype = angular.copy(data);
            //$rootScope.datatype =result;
            $rootScope.currentData =$rootScope.datatype;
            $scope.$emit('event:openDatatypeonShare',$rootScope.datatype);
        };

        $scope.editDatatype = function(data) {
        	$scope.pending=false;
                processEditDataType(data);

        };
        $scope.editTable = function(table) {
        	$scope.pending=false;
        	$scope.tableTab=true;
        	 $scope.$emit('event:openTableForShare',table);

        };

        $scope.confirmShareDocument = function(datatype) {
                $http.get('api/shareDtconfimation/' + datatype.id).then(function(response) {
                    $rootScope.msg().text = "dtSharedConfirmationSuccessful";
                    $rootScope.msg().type ="success";
                    $rootScope.msg().show = true;
                    $scope.getSharedDatatypes();
                }, function(error) {
                    $rootScope.msg().text = "dtSharedConfirmationFailed";
                    $rootScope.msg().type ="danger";
                    $rootScope.msg().show = true;
                    console.log(error);
                });
            };

            $scope.rejectShareDocument = function(datatype) {
                $http.get('api/shareDtreject/' + datatype.id).then(function(response) {
                    $rootScope.msg().text = "dtSharedRejectedSuccessfully";
                    $rootScope.msg().type ="success";
                    $rootScope.msg().show = true;
                    $scope.getSharedDatatypes();
                }, function(error) {
                    $rootScope.msg().text = "dtSharedRejectFailed";
                    $rootScope.msg().type ="danger";
                    $rootScope.msg().show = true;
                    console.log(error);
                });
            };

            $scope.confirmShareTable = function(table) {
                    $http.get('api/shareTableconfimation/' + table.id).then(function(response) {
                        $rootScope.msg().text = "vsSharedConfirmationSuccessful";
                        $rootScope.msg().type ="success";
                        $rootScope.msg().show = true;
                        $scope.getSharedTables();
                    }, function(error) {
                        $rootScope.msg().text = "vsSharedConfirmationFailed";
                        $rootScope.msg().type ="danger";
                        $rootScope.msg().show = true;
                        console.log(error);
                    });
                };

                $scope.rejectShareTable = function(table) {
                    $http.get('api/shareTablereject/' + table.id).then(function(response) {
                        $rootScope.msg().text = "vsSharedRejectedSuccessfully";
                        $rootScope.msg().type ="success";
                        $rootScope.msg().show = true;
                        $scope.getSharedTables();
                    }, function(error) {
                        $rootScope.msg().text = "vsSharedRejectFailed";
                        $rootScope.msg().type ="danger";
                        $rootScope.msg().show = true;
                        console.log(error);
                    });
                };

            $scope.selectDatatype = function (datatype) {
            $rootScope.datatype = angular.copy(datatype);
            $rootScope.Activate(datatype.id);
            $scope.Sharedsubview = "EditDatatypes.html";
            if (datatype && datatype != null) {
                $scope.loadingSelection = true;
                blockUI.start();
                $timeout(
                    function () {


                                $rootScope.$emit("event:initDatatype");

                                $rootScope.currentData = datatype;

                                $scope.loadingSelection = false;
                                $rootScope.datatype["type"] = "datatype";
                                $rootScope.tableWidth = null;
                                $rootScope.scrollbarWidth = $rootScope.getScrollbarWidth();
                                $rootScope.csWidth = $rootScope.getDynamicWidth(1, 3, 890);
                                $rootScope.predWidth = $rootScope.getDynamicWidth(1, 3, 890);
                                $rootScope.commentWidth = $rootScope.getDynamicWidth(1, 3, 890);
                                $scope.loadingSelection = false;
                                try {
                                    if ($scope.datatypesParams)
                                        $scope.datatypesParams.refresh();
                                } catch (e) {

                                }
                                $rootScope.references = [];
                                $rootScope.tmpReferences = [].concat($rootScope.references);
                                   angular.forEach($scope.datatypes, function (dt) {
                                    if (dt && dt != null && dt.id !== $rootScope.datatype.id) $rootScope.findDatatypeRefs(datatype, dt, $rootScope.getDatatypeLabel(dt), dt);
                                });

                                $rootScope.tmpReferences = [].concat($rootScope.references);
                                $rootScope.tmpReferences = [].concat($rootScope.references);

                                $rootScope.$emit("event:initEditArea");




                                blockUI.stop();

                        }
                    , 100);

                setTimeout(function () {
                    $scope.$broadcast('reCalcViewDimensions');
                    console.log("refreshed Slider!!");
                }, 1000);
            }
        };

        $scope.selectTable = function (t) {
            $rootScope.Activate(t.id);
            $scope.SharedsubviewForTable = "ReadValueSets.html";

            $scope.loadingSelection = true;
            blockUI.start();

            $rootScope.table = t;
            $rootScope.table.smallCodes = $rootScope.table.codes.slice(0,1000);
            $rootScope.$emit("event:initTable");
            $rootScope.codeSystems = [];
            for (var i = 0; i < $rootScope.table.codes.length; i++) {
                if ($rootScope.codeSystems.indexOf($rootScope.table.codes[i].codeSystem) < 0) {
                    if ($rootScope.table.codes[i].codeSystem && $rootScope.table.codes[i].codeSystem !== '') {
                        $rootScope.codeSystems.push($rootScope.table.codes[i].codeSystem);
                    }
                }
            }
                    $rootScope.references = [];

                    angular.forEach($scope.datatypes, function (dt) {
                        $rootScope.findTableRefs($rootScope.table, dt, $rootScope.getDatatypeLabel(dt), dt);
                    });

            $scope.loadingSelection = false;
            $rootScope.$emit("event:initEditArea");
            blockUI.stop();
        };



        $scope.unshareDatatype=[
          ['Remove',
                    function ($itemScope) {
                       $rootScope.refsForDelete=[];
                angular.forEach($scope.datatypes, function (dt) {
                if (dt && dt != null && dt.id !== $itemScope.data.id) $rootScope.findTempDatatypeRefs($itemScope.data, dt, $rootScope.getDatatypeLabel(dt),dt);
                  });
                        if($rootScope.refsForDelete.length>0){
                            $scope.abortUnshare($itemScope.data);
                        }else{
                            $scope.confirmUnshare($itemScope.data);
                        }
                    }
                          
                ]
        ];

        $scope.unshareTable=[
          ['Remove',
                    function ($itemScope) {
                       $rootScope.refsForDelete=[];
                angular.forEach($scope.datatypes, function (dt) {
                if (dt && dt != null && dt.id !== $itemScope.table.id) $rootScope.findTableRefsForDelete($itemScope.table, dt,$rootScope.getDatatypeLabel(dt),dt);
                  });
                        if($rootScope.refsForDelete.length>0){
                            $scope.abortUnshare($itemScope.table);
                        }else{
                            $scope.confirmUnshareTable($itemScope.table);
                        }
                    }
                          
                ]
        ];



        $scope.removeDatatype=function(datatype){
            var accountId=userInfoService.getAccountID();
            var accountId=userInfoService.getAccountID();
            console.log(accountId);
                        DatatypeService.unshare(datatype.id,accountId).then(function(res){
                            console.log("unshared");

                            var index = $scope.datatypes.indexOf(datatype);
                                console.log(index);
	                         if (index > -1){

                                 $scope.datatypes.splice(index, 1);
                             } 
                        });

        }

            $scope.removeTable=function(table){
             var accountId=userInfoService.getAccountID();
            var accountId=userInfoService.getAccountID();
            console.log(accountId);
                        TableService.unshare(table.id,accountId).then(function(res){
                            console.log("unshared");

                            var index = $scope.tables.indexOf(table);
                                console.log(index);
	                         if (index > -1){

                                 $scope.tables.splice(index, 1);
                             } 
                        });

        }

          $rootScope.confirmUnshare = function(datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'confirmUnshare.html',
                controller: 'confirmUnshare',
                resolve: {
                    datatypeTo: function() {
                        return datatype;
                    }
                    
                }
            });
            modalInstance.result.then(function(datatype) {
            	 $scope.removeDatatype(datatype);
                
            });
        };

        $rootScope.confirmUnshareTable = function(table) {
            var modalInstance = $modal.open({
                templateUrl: 'confirmUnshare.html',
                controller: 'confirmUnshare',
                resolve: {
                    datatypeTo: function() {
                        return table;
                    }
                    
                }
            });
            modalInstance.result.then(function(table) {
            	 $scope.removeTable(table);
                
            });
        };

          $rootScope.abortUnshare = function(datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'abortDeleteDatatype.html',
                controller: 'abortUnshare',
                resolve: {
                    datatypeTo: function() {
                        return datatype;
                    }
                 
        
                }
            });
            modalInstance.result.then(function() {
                
            });
        };



}]);

angular.module('igl').controller('confirmUnshare', function($scope, $rootScope, $http, $modalInstance,datatypeTo) {
    $scope.datatypeTo=datatypeTo;
        $scope.getMessage=function(){
        if($scope.datatypeTo.type==='table'){
            return "Value Set";
        }else{
            return "Data Type"
        }
    };

    $scope.confirm = function() {
    	  $modalInstance.close($scope.datatypeTo);
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});

angular.module('igl').controller('abortUnshare', function($scope, $rootScope, $http, $modalInstance,datatypeTo) {
    $scope.datatypeTo=datatypeTo;
    $scope.getMessage=function(){
        if($scope.datatypeTo.type==='table'){
            return "Value Set";
        }else{
            return "Data Type"
        }
    };
    $scope.ok = function() {
        $modalInstance.dismiss('cancel');
    };
});

angular.module('igl').controller('TableListCtrlForDtLib', function($scope, $rootScope, Restangular, $filter, $http, $modal, $timeout, CloneDeleteSvc, TableService, TableLibrarySvc, blockUI, SegmentService, DatatypeService) {
    $scope.readonly = false;
    $scope.codeSysEditMode = false;
    $scope.codeSysForm = {};
    $scope.saved = false;
    $scope.message = false;
    $scope.params = null;
    $scope.predicate = 'value';
    $scope.reverse = false;
    $scope.selectedCodes = [];
    $scope.isDeltaCalled = false;
    $scope.tabStatus = {
        active: 1
    };
    $scope.init = function() {
        $scope.tabStatus = {
            active: 1
        };
        $scope.selectedCodes = [];
        $rootScope.$on('event:cloneTableFlavor', function(event, table) {
            $scope.copyTable(table);
        });
    };

    $scope.reset = function() {
        blockUI.start();
        cleanState();
        $rootScope.table = angular.copy($rootScope.tablesMap[$rootScope.table.id]);

        $rootScope.references = [];
        angular.forEach($rootScope.segments, function(segment) {
            $rootScope.findTableRefs($rootScope.table, segment, $rootScope.getSegmentLabel(segment), segment);
        });
        angular.forEach($rootScope.datatypes, function(dt) {
            $rootScope.findTableRefs($rootScope.table, dt, $rootScope.getDatatypeLabel(dt), dt);
        });

        blockUI.stop();
    };
    $scope.redirectSeg = function(segmentRef) {
        SegmentService.get(segmentRef.id).then(function(segment) {
            var modalInstance = $modal.open({
                templateUrl: 'redirectCtrl.html',
                controller: 'redirectCtrl',
                size: 'md',
                resolve: {
                    destination: function() {
                        return segment;
                    }
                }



            });
            modalInstance.result.then(function() {
                $rootScope.editSeg(segment);
            });



        });
    };
    $scope.redirectDT = function(datatype) {
        console.log(datatype);
        DatatypeService.getOne(datatype.id).then(function(datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'redirectCtrl.html',
                controller: 'redirectCtrl',
                size: 'md',
                resolve: {
                    destination: function() {
                        return datatype;
                    }
                }



            });
            modalInstance.result.then(function() {
                $rootScope.editDataType(datatype);
            });



        });
    };

    $scope.isBindingChanged = function() {
        for (var i = 0; i < $rootScope.references.length; i++) {
            var ref = $rootScope.references[i];

            if (ref.tableLink.isChanged) return true;
        }
        return false;
    };

    var cleanState = function() {
        $scope.saving = false;
        $scope.selectedChildren = [];
        if ($scope.editForm) {
            $scope.editForm.$setPristine();
            $scope.editForm.$dirty = false;
        }
        $rootScope.clearChanges();
    };
    $scope.callVSDelta = function() {

        $rootScope.$emit("event:openVSDelta");
    };

    $scope.changeTableLink = function(tableLink) {
        tableLink.isChanged = true;

        var t = $rootScope.tablesMap[tableLink.id];

        if (t == null) {
            tableLink.bindingIdentifier = null;
            tableLink.bindingLocation = null;
            tableLink.bindingStrength = null;
        } else {
            tableLink.bindingIdentifier = t.bindingIdentifier;
        }
    };

    $scope.AddBindingForValueSet = function(table) {
        var modalInstance = $modal.open({
            templateUrl: 'AddBindingForValueSetINLIB.html',
            controller: 'AddBindingForValueSet',
            windowClass: 'conformance-profiles-modal',
            resolve: {
                table: function() {
                    return table;
                }
            }
        });
        modalInstance.result.then(function() {
            $scope.setDirty();
        });
    };

    $scope.save = function() {
    	console.log("Calling save");
        if ($rootScope.table.status === 'UNPUBLISHED' || $rootScope.table.scope !== 'HL7STANDARD' ) {
            $scope.saving = true;
            var table = $rootScope.table;
            var bindingIdentifier = table.bindingIdentifier;


            if (table.libIds == undefined) table.libIds = [];
            if (table.libIds.indexOf($scope.tableLibrary.id) == -1) {
                table.libIds.push($scope.tableLibrary.id);
            }

            TableService.save(table).then(function(result) {
                var oldLink = TableLibrarySvc.findOneChild(result.id, $scope.tableLibrary.children);
                TableService.merge($rootScope.tablesMap[result.id], result);
                // remove unnecessary variables for toc
                delete $rootScope.tablesMap[result.id].codes;
                delete $rootScope.tablesMap[result.id].contentDefinition;
                delete $rootScope.tablesMap[result.id].extensibility;
                delete $rootScope.tablesMap[result.id].stability;
                delete $rootScope.tablesMap[result.id].comment;
                delete $rootScope.tablesMap[result.id].defPreText;
                delete $rootScope.tablesMap[result.id].defPostText;

                var newLink = TableService.getTableLink(result);
                newLink.bindingIdentifier = bindingIdentifier;
                TableLibrarySvc.updateChild($scope.tableLibrary.id, newLink).then(function(link) {
                    oldLink.bindingIdentifier = link.bindingIdentifier;
                    oldLink.ext = link.ext;
                    cleanState();
                    $rootScope.msg().text = "tableSaved";
                    $rootScope.msg().type = "success";
                    $rootScope.msg().show = true;
                }, function(error) {
                    $scope.saving = false;
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
            }, function(error) {
                $scope.saving = false;
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        }
        $rootScope.saveBindingForValueSet();
    };


    $scope.addTable = function() {
        $rootScope.newTableFakeId = $rootScope.newTableFakeId - 1;
        var newTable = angular.fromJson({
            id: new ObjectId().toString(),
            type: 'table',
            bindingIdentifier: '',
            name: '',
            version: '',
            oid: '',
            tableType: '',
            stability: '',
            extensibility: '',
            codes: []
        });
        $rootScope.tables.push(newTable);
        $rootScope.tablesMap[newTable.id] = newTable;
        $rootScope.table = newTable;
        $rootScope.recordChangeForEdit2('table', "add", newTable.id, 'table', newTable);
        $scope.setDirty();
    };


    $scope.makeCodeSystemEditable = function() {
        $scope.codeSysEditMode = true;
    };


    $scope.addCodeSystem = function() {
        if ($rootScope.codeSystems.indexOf($scope.codeSysForm.str) < 0) {
            if ($scope.codeSysForm.str && $scope.codeSysForm.str !== '') {
                $rootScope.codeSystems.push($scope.codeSysForm.str);
            }
        }
        $scope.codeSysForm.str = '';
        $scope.codeSysEditMode = false;
    };

    $scope.delCodeSystem = function(value) {
        $rootScope.codeSystems.splice($rootScope.codeSystems.indexOf(value), 1);
    }

    $scope.updateCodeSystem = function(table, codeSystem) {
        for (var i = 0; i < $rootScope.table.codes.length; i++) {
            $rootScope.table.codes[i].codeSystem = codeSystem;
            $scope.recordChangeValue($rootScope.table.codes[i], 'codeSystem', $rootScope.table.codes[i].codeSystem, table.id);
        }
    }

    $scope.addValue = function() {
        $rootScope.newValueFakeId = $rootScope.newValueFakeId ? $rootScope.newValueFakeId - 1 : -1;
        var newValue = {
            id: new ObjectId().toString(),
            type: 'value',
            value: '',
            label: '',
            codeSystem: null,
            codeUsage: 'R'
        };


        $rootScope.table.codes.unshift(newValue);
        var newValueBlock = { targetType: 'table', targetId: $rootScope.table.id, obj: newValue };
        if (!$scope.isNewObject('table', 'add', $rootScope.table.id)) {
            $rootScope.recordChangeForEdit2('value', "add", null, 'value', newValueBlock);
        }
        $scope.setDirty();
    };
    $rootScope.checkAll = false;
    $scope.ProcessChecking = function(checkAll) {


        console.log("here");
        if (checkAll) {
            $scope.checkAllValues();
        } else {
            $scope.uncheckAllValues();
        }

    }
    $scope.addOrRemoveValue = function(c) {
        if (c.selected === true) {
            $scope.selectedCodes.push(c);
        } else if (c.selected === false) {
            var index = $scope.selectedCodes.indexOf(c);
            if (index > -1) {
                $scope.selectedCodes.splice(index, 1);
            }
        }


    }
    $scope.deleteSlectedValues = function() {
        console.log()
        console.log("deleting");
        $rootScope.table.codes = _.difference($rootScope.table.codes, $scope.selectedCodes);
        $scope.selectedCodes = [];
    }
    $scope.checkAllValues = function() {
        angular.forEach($rootScope.table.codes, function(c) {
            c.selected = true;
            $scope.selectedCodes.push(c);
        });
    }
    $scope.uncheckAllValues = function() {
        console.log("deleting");
        //console.log($rootScope.displayCollection);
        angular.forEach($rootScope.table.codes, function(c) {
            if (c.selected && c.selected === true) {
                c.selected = false;
            }
        });
        $scope.selectedCodes = [];
    }
    $scope.deleteValue = function(value) {
        console.log($scope.selectedCodes);
        $rootScope.table.codes.splice($rootScope.table.codes.indexOf(value), 1);
        $scope.setDirty();
    };
    $scope.isNewValueThenDelete = function(id) {
        if ($rootScope.isNewObject('value', 'add', id)) {
            if ($rootScope.changes['value'] !== undefined && $rootScope.changes['value']['add'] !== undefined) {
                for (var i = 0; i < $rootScope.changes['value']['add'].length; i++) {
                    var tmp = $rootScope.changes['value']['add'][i];
                    if (tmp.obj.id === id) {
                        $rootScope.changes['value']['add'].splice(i, 1);
                        if ($rootScope.changes["value"]["add"] && $rootScope.changes["value"]["add"].length === 0) {
                            delete $rootScope.changes["value"]["add"];
                        }

                        if ($rootScope.changes["value"] && Object.getOwnPropertyNames($rootScope.changes["value"]).length === 0) {
                            delete $rootScope.changes["value"];
                        }
                        return true;
                    }
                }
            }
            return true;
        }
        if ($rootScope.changes['value'] !== undefined && $rootScope.changes['value']['edit'] !== undefined) {
            for (var i = 0; i < $rootScope.changes['value']['edit'].length; i++) {
                var tmp = $rootScope.changes['value']['edit'][i];
                if (tmp.id === id) {
                    $rootScope.changes['value']['edit'].splice(i, 1);
                    if ($rootScope.changes["value"]["edit"] && $rootScope.changes["value"]["edit"].length === 0) {
                        delete $rootScope.changes["value"]["edit"];
                    }

                    if ($rootScope.changes["value"] && Object.getOwnPropertyNames($rootScope.changes["value"]).length === 0) {
                        delete $rootScope.changes["value"];
                    }
                    return false;
                }
            }
            return false;
        }
        return false;
    };

    $scope.isNewValue = function(id) {
        return $scope.isNewObject('value', 'add', id);
    };

    $scope.isNewTable = function(id) {
        return $scope.isNewObject('table', 'add', id);
    };

    $scope.close = function() {
        $rootScope.table = null;
    };

    $scope.copyTable = function(table) {
        CloneDeleteSvc.copyTable(table);
    };

    $scope.recordChangeValue = function(value, valueType, tableId) {
        if (!$scope.isNewTable(tableId)) {
            if (!$scope.isNewValue(value.id)) {
                $rootScope.recordChangeForEdit2('value', 'edit', value.id, valueType, value);
            }
        }
        $scope.setDirty();
    };

    $scope.recordChangeTable = function(table, valueType, value) {
        if (!$scope.isNewTable(table.id)) {
            $rootScope.recordChangeForEdit2('table', 'edit', table.id, valueType, value);
        }
        $scope.setDirty();
    };

    $scope.setAllCodeUsage = function(table, usage) {
        for (var i = 0, len = table.codes.length; i < len; i++) {
            if (table.codes[i].codeUsage !== usage) {
                table.codes[i].codeUsage = usage;
                if (!$scope.isNewTable(table.id) && !$scope.isNewValue(table.codes[i].id)) {
                    $rootScope.recordChangeForEdit2('value', 'edit', table.codes[i].id, 'codeUsage', usage);
                }
            }
        }
        $scope.setDirty();
    };

    $scope.delete = function(table) {
        CloneDeleteSvc.deleteValueSet(table);
    };
});

angular.module('igl').controller('TableModalCtrl', function($scope) {
    $scope.showModal = false;
    $scope.toggleModal = function() {
        $scope.showModal = !$scope.showModal;
    };
});

angular.module('igl').controller('ConfirmValueSetDeleteCtrl', function($scope, $modalInstance, tableToDelete, $rootScope, TableService, TableLibrarySvc, CloneDeleteSvc) {
    $scope.tableToDelete = tableToDelete;
    $scope.loading = false;


    $scope.delete = function() {
        $scope.loading = true;
        if ($scope.tableToDelete.scope === 'USER') {
            CloneDeleteSvc.deleteTableAndTableLink($scope.tableToDelete);
        } else {
            CloneDeleteSvc.deleteTableLink($scope.tableToDelete);
        }
        $modalInstance.close($scope.tableToDelete);
        $scope.loading = false;
    };


    //    $scope.delete = function () {
    //        $scope.loading = true;
    //
    //        if (!$scope.isNewTableThenDelete(tableToDelete.id)) {
    ////        	$rootScope.recordChangeForEdit2('table', "delete", tableToDelete.id,'id', tableToDelete.id);
    //        }
    //        // We must delete from two collections.
    //        var index = $rootScope.tables.indexOf(tableToDelete);
    //        $rootScope.tables.splice(index, 1);
    //        var index = $rootScope.igdocument.profile.tableLibrary.children.indexOf($scope.tableToDelete);
    //        if (index > -1) $rootScope.igdocument.profile.tableLibrary.children.splice(index, 1);
    //        $rootScope.tablesMap[tableToDelete.id] = undefined;
    //
    //        $rootScope.generalInfo.type = 'info';
    //        $rootScope.generalInfo.message = "Table " + $scope.tableToDelete.bindingIdentifier + " deleted successfully";
    //
    //        if ($rootScope.table === $scope.tableToDelete) {
    //            $rootScope.table = null;
    //        }
    //
    //        $rootScope.references = [];
    //		$rootScope.$broadcast('event:SetToC');
    //        $modalInstance.close($scope.tableToDelete);
    //    };

    //    $scope.delete = function () {
    //        $scope.loading = true;
    //
    //        TableService.delete($scope.tableToDelete).then(function (result) {
    //                TableLibrarySvc.deleteChild($scope.tableToDelete.id).then(function (res) {
    //                    // We must delete from two collections.
    //                    var index = $rootScope.tables.indexOf($scope.tableToDelete);
    //                    $rootScope.tables.splice(index, 1);
    //                    var tmp = TableLibrarySvc.findOneChiletd($scope.tableToDelete.id, $rootScope.igdocument.profile.tableLibrary.children);
    //                    index = $rootScope.igdocument.profile.tableLibrary.children.indexOf(tmp);
    //                    $rootScope.igdocument.profile.tableLibrary.children.splice(index, 1);
    //                    $rootScope.tablesMap[$scope.tableToDelete.id] = null;
    //                    $rootScope.references = [];
    //                    if ($rootScope.table === $scope.tableToDelete) {
    //                        $rootScope.table = null;
    //                    }
    //                    $rootScope.recordDelete("table", "edit", $scope.tableToDelete.id);
    //                    $rootScope.msg().text = "tableDeleteSuccess";
    //                    $rootScope.msg().type = "success";
    //                    $rootScope.msg().show = true;
    //                    $rootScope.manualHandle = true;
    //                    $scope.loading = false;
    //                    $rootScope.$broadcast('event:SetToC');
    //                    $modalInstance.close($scope.tableToDelete);
    //                }, function (error) {
    //                    $rootScope.msg().text = error.data.text;
    //                    $rootScope.msg().type = "danger";
    //                    $rootScope.msg().show = true;
    //                    $rootScope.manualHandle = true;
    //                    $scope.loading = false;
    //                });
    //            }, function (error) {
    //                $rootScope.msg().text = error.data.text;
    //                $rootScope.msg().type = "danger";
    //                $rootScope.msg().show = true;
    //                $rootScope.manualHandle = true;
    //                $scope.loading = false;
    //            }
    //        );
    //    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


    $scope.isNewTableThenDelete = function(id) {
        if ($rootScope.isNewObject('table', 'add', id)) {
            if ($rootScope.changes['table'] !== undefined && $rootScope.changes['table']['add'] !== undefined) {
                for (var i = 0; i < $rootScope.changes['table']['add'].length; i++) {
                    var tmp = $rootScope.changes['table']['add'][i];
                    if (tmp.id == id) {
                        $rootScope.changes['table']['add'].splice(i, 1);
                        if ($rootScope.changes["table"]["add"] && $rootScope.changes["table"]["add"].length === 0) {
                            delete $rootScope.changes["table"]["add"];
                        }

                        if ($rootScope.changes["table"] && Object.getOwnPropertyNames($rootScope.changes["table"]).length === 0) {
                            delete $rootScope.changes["table"];
                        }
                        return true;
                    }
                }
            }
            return true;
        }
        if ($rootScope.changes['table'] !== undefined && $rootScope.changes['table']['edit'] !== undefined) {
            for (var i = 0; i < $rootScope.changes['table']['edit'].length; i++) {
                var tmp = $rootScope.changes['table']['edit'][i];
                if (tmp.id === id) {
                    $rootScope.changes['table']['edit'].splice(i, 1);
                    if ($rootScope.changes["table"]["edit"] && $rootScope.changes["table"]["edit"].length === 0) {
                        delete $rootScope.changes["table"]["edit"];
                    }

                    if ($rootScope.changes["table"] && Object.getOwnPropertyNames($rootScope.changes["table"]).length === 0) {
                        delete $rootScope.changes["table"];
                    }
                    return false;
                }
            }
            return false;
        }
        return false;
    };
});

angular.module('igl').controller('ValueSetReferencesCtrl', function($scope, $modalInstance, tableToDelete) {

    $scope.tableToDelete = tableToDelete;

    $scope.ok = function() {
        $modalInstance.close($scope.tableToDelete);
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});


//angular.module('igl').controller('cmpTableCtrl', function($scope, $modal, ObjectDiff, orderByFilter, $rootScope, $q, $interval, ngTreetableParams, $http, StorageService, userInfoService, IgDocumentService, SegmentService, DatatypeService, SegmentLibrarySvc, DatatypeLibrarySvc, TableLibrarySvc, CompareService) {
//    var ctrl = this;
//    this.tableId = -1;
//    $scope.vsChanged = false;
//    $scope.variable = false;
//    $scope.isDeltaCalled = false;
//
//    $scope.setDeltaToF = function() {
//        console.log("HEEEEEERREEEEE");
//        $scope.isDeltaCalled = false;
//    }
//
//
//
//    $scope.scopes = [{
//        name: "USER",
//        alias: "My IG"
//    }, {
//        name: "HL7STANDARD",
//        alias: "Base HL7"
//    }];
//    var listHL7Versions = function() {
//        return $http.get('api/igdocuments/findVersions', {
//            timeout: 60000
//        }).then(function(response) {
//            var hl7Versions = [];
//            var length = response.data.length;
//            for (var i = 0; i < length; i++) {
//                hl7Versions.push(response.data[i]);
//            }
//            return hl7Versions;
//        });
//    };
//    $scope.status = {
//        isCustomHeaderOpen: false,
//        isFirstOpen: true,
//        isSecondOpen: true,
//        isFirstDisabled: false
//    };
//
//    $scope.initt = function() {
////        $scope.isDeltaCalled = true;
////        $scope.dataList = [];
////        listHL7Versions().then(function(versions) {
////            $scope.versions = versions;
////            $scope.version1 = angular.copy($rootScope.igdocument.profile.metaData.hl7Version);
////            $scope.scope1 = "USER";
////            $scope.ig1 = angular.copy($rootScope.igdocument.profile.metaData.name);
////            $scope.table1 = angular.copy($rootScope.table);
////            ctrl.tableId = -1;
////            $scope.variable = !$scope.variable;
////            $scope.tables = null;
////            //$scope.setIG2($scope.ig2);
////            $scope.version2 = angular.copy($scope.version1);
////            //$scope.status.isFirstOpen = true;
////            $scope.scope2 = "HL7STANDARD";
////            if ($scope.dynamicVs_params) {
////                $scope.showDelta = false;
////                $scope.status.isFirstOpen = true;
////                $scope.dynamicVs_params.refresh();
////            }
////        });
//
//
//
//    };
//
//    $scope.$on('event:loginConfirmed', function(event) {
//        $scope.initt();
//    });
//
//    //$scope.initt();
//
//    $rootScope.$on('event:initTable', function(event) {
//        if ($scope.isDeltaCalled) {
//            $scope.initt();
//        }
//    });
//
//    $rootScope.$on('event:openVSDelta', function(event) {
//        $scope.initt();
//    });
//
//
//
//    $scope.setVersion2 = function(vr) {
//        $scope.version2 = vr;
//
//    };
//    $scope.setScope2 = function(scope) {
//
//        $scope.scope2 = scope;
//    };
//
//    $scope.$watchGroup(['table1', 'table2'], function() {
//        $scope.vsChanged = true;
//        //$scope.segment1 = angular.copy($rootScope.activeSegment);
//
//
//    }, true);
//    $scope.$watchGroup(['version2', 'scope2', 'variable'], function() {
//        $scope.igList2 = [];
//        $scope.tables2 = [];
//        $scope.ig2 = "";
//        if ($scope.scope2 && $scope.version2) {
//            IgDocumentService.getIgDocumentsByScopesAndVersion([$scope.scope2], $scope.version2).then(function(result) {
//                if (result) {
//                    if ($scope.scope2 === "HL7STANDARD") {
//                        $scope.igDisabled2 = true;
//                        $scope.ig2 = {
//                            id: result[0].id,
//                            title: result[0].metaData.title
//                        };
//                        $scope.igList2.push($scope.ig2);
//
//                        $scope.setIG2($scope.ig2);
//                    } else {
//                        $scope.igDisabled2 = false;
//                        for (var i = 0; i < result.length; i++) {
//                            $scope.igList2.push({
//                                id: result[i].id,
//                                title: result[i].metaData.title,
//                            });
//                        }
//                    }
//                }
//            });
//
//        }
//
//    }, true);
//    $scope.setTable2 = function(table) {
//        if (table === -1) {
//            $scope.table2 = {};
//        } else {
//            $scope.table2 = $scope.tables2[table];
//
//        }
//    };
//    $scope.setIG2 = function(ig) {
//        if (ig) {
//            IgDocumentService.getOne(ig.id).then(function(igDoc) {
//                SegmentLibrarySvc.getSegmentsByLibrary(igDoc.profile.segmentLibrary.id).then(function(segments) {
//                    DatatypeLibrarySvc.getDatatypesByLibrary(igDoc.profile.datatypeLibrary.id).then(function(datatypes) {
//                        TableLibrarySvc.getTablesByLibrary(igDoc.profile.tableLibrary.id).then(function(tables) {
//                            $scope.tables2 = [];
//                            $scope.table2 = "";
//                            if (igDoc) {
//                                //$scope.segList2 = angular.copy(segments);
//                                //$scope.segList2 = orderByFilter($scope.segList2, 'name');
//                                //$scope.dtList2 = angular.copy(datatypes);
//                                $scope.tableList2 = angular.copy(tables);
//                                //$scope.messages2 = orderByFilter(igDoc.profile.messages.children, 'name');
//                                //$scope.segments2 = orderByFilter(segments, 'name');
//                                //$scope.datatypes2 = orderByFilter(datatypes, 'name');
//                                $scope.tables2 = orderByFilter(tables, 'bindingIdentifier');
//                            }
//                        });
//                    });
//                });
//
//            });
//
//            //$scope.messages2 = ($scope.findIGbyID(JSON.parse(ig).id)).profile.messages.children;
//
//        }
//
//    };
//
//    $scope.hideVS = function(vs1, vs2) {
//
//        if (vs2) {
//            return !(vs1.name === vs2.name);
//        } else {
//            return false;
//        }
//    };
//    $scope.disableVS = function(vs1, vs2) {
//
//        if (vs2) {
//            return (vs1.id === vs2.id);
//        } else {
//            return false;
//        }
//    };
//
//
//
//
//    $scope.dynamicVs_params = new ngTreetableParams({
//        getNodes: function(parent) {
//            if ($scope.dataList !== undefined) {
//                if (parent) {
//                    if (parent.codes) {
//                        return parent.codes;
//                    }
//
//                } else {
//                    return $scope.dataList;
//                }
//
//            }
//        },
//        getTemplate: function(node) {
//            $scope.vsTemplate = true;
//            return 'valueSet_node';
//        }
//    });
//    $scope.cmpTable = function(table1, table2) {
//
//        $scope.loadingSelection = true;
//        $scope.vsChanged = false;
//        $scope.vsTemplate = false;
//        $scope.dataList = CompareService.cmpValueSet(JSON.stringify(table1), JSON.stringify(table2));
//        console.log("hg==========");
//        console.log($scope.dataList);
//        $scope.loadingSelection = false;
//        if ($scope.dynamicVs_params) {
//            console.log($scope.dataList);
//            $scope.showDelta = true;
//            $scope.status.isSecondOpen = true;
//            $scope.dynamicVs_params.refresh();
//        }
//
//    };
//
//
//});

//angular.module('igl').controller('AddBindingForValueSet', function($scope, $modalInstance, $rootScope, table) {
//    console.log($rootScope.references);
//    $scope.table = table;
//    $scope.selectedSegmentForBinding = null;
//    $scope.selectedFieldForBinding = null;
//    $scope.selectedDatatypeForBinding = null;
//    $scope.selectedComponentForBinding = null;
//    $scope.selectedBindingLocation = null;
//    $scope.selectedBindingStrength = null;
//    $scope.pathForBinding = null;
//    $scope.bindingTargetType = 'DATATYPE';
//
//    $scope.init = function() {
//        $scope.selectedSegmentForBinding = null;
//        $scope.selectedFieldForBinding = null;
//        $scope.selectedDatatypeForBinding = null;
//        $scope.selectedComponentForBinding = null;
//        $scope.selectedBindingLocation = null;
//        $scope.selectedBindingStrength = null;
//        $scope.pathForBinding = null;
//    };
//
//    $scope.checkDuplicated = function(path) {
//        for (var i = 0; i < $rootScope.references.length; i++) {
//            var ref = $rootScope.references[i];
//            if (ref.path == path) return true;
//        }
//        return false;
//    };
//
//    $scope.selectSegment = function() {
//        $scope.selectedFieldForBinding = null;
//    };
//
//    $scope.selectDatatype = function() {
//        $scope.selectedComponentForBinding = null;
//    };
//
//    $scope.save = function(bindingTargetType) {
//        var tableLink = {};
//        tableLink.id = $scope.table.id;
//        tableLink.bindingIdentifier = $scope.table.bindingIdentifier;
//        tableLink.bindingLocation = $scope.selectedBindingLocation;
//        tableLink.bindingStrength = $scope.selectedBindingStrength;
//        tableLink.isChanged = true;
//        tableLink.isNew = true;
//
//        if (bindingTargetType == 'SEGMENT') {
//            $scope.selectedFieldForBinding = JSON.parse($scope.selectedFieldForBinding);
//            $scope.pathForBinding = $rootScope.getSegmentLabel($scope.selectedSegmentForBinding) + '-' + $scope.selectedFieldForBinding.position;
//
//            var ref = angular.copy($scope.selectedFieldForBinding);
//            ref.path = $scope.pathForBinding;
//            ref.target = angular.copy($scope.selectedSegmentForBinding);
//            ref.tableLink = angular.copy(tableLink);
//            $rootScope.references.push(ref);
//        } else {
//            $scope.selectedComponentForBinding = JSON.parse($scope.selectedComponentForBinding);
//            $scope.pathForBinding = $rootScope.getDatatypeLabel($scope.selectedDatatypeForBinding) + '-' + $scope.selectedComponentForBinding.position;
//
//            var ref = angular.copy($scope.selectedComponentForBinding);
//            ref.path = $scope.pathForBinding;
//            ref.target = angular.copy($scope.selectedDatatypeForBinding);
//            ref.tableLink = angular.copy(tableLink);
//            $rootScope.references.push(ref);
//        }
//
//        $modalInstance.close();
//    };
//
//    $scope.cancel = function() {
//        $modalInstance.dismiss('cancel');
//    };
//});
/**
 * Created by Jungyub on 4/01/15.
 */

angular.module('igl').controller('TableListCtrl', function($scope, $rootScope, Restangular, $filter, $http, $modal, $timeout, CloneDeleteSvc, TableService, TableLibrarySvc, blockUI, SegmentService, DatatypeService) {
    $scope.readonly = false;
    $scope.codeSysEditMode = false;
    $scope.codeSysForm = {};
    $scope.saved = false;
    $scope.message = false;
    $scope.params = null;
    $scope.predicate = 'value';
    $scope.reverse = false;
    $scope.selectedCodes = [];
    $scope.isDeltaCalled = false;
    $scope.tabStatus = {
        active: 1
    };
    $scope.init = function() {
        $scope.tabStatus = {
            active: 1
        };
        $scope.selectedCodes = [];
        $rootScope.$on('event:cloneTableFlavor', function(event, table) {
            $scope.copyTable(table);
        });
    };

    $scope.reset = function() {
        blockUI.start();
        cleanState();
        $rootScope.table = angular.copy($rootScope.tablesMap[$rootScope.table.id]);

        $rootScope.references = [];
        angular.forEach($rootScope.segments, function(segment) {
            $rootScope.findTableRefs($rootScope.table, segment, $rootScope.getSegmentLabel(segment), segment);
        });
        angular.forEach($rootScope.datatypes, function(dt) {
            $rootScope.findTableRefs($rootScope.table, dt, $rootScope.getDatatypeLabel(dt), dt);
        });

        blockUI.stop();
    };
    $scope.redirectSeg = function(segmentRef) {
        SegmentService.get(segmentRef.id).then(function(segment) {
            var modalInstance = $modal.open({
                templateUrl: 'redirectCtrl.html',
                controller: 'redirectCtrl',
                size: 'md',
                resolve: {
                    destination: function() {
                        return segment;
                    }
                }



            });
            modalInstance.result.then(function() {
                $rootScope.editSeg(segment);
            });



        });
    };
    $scope.redirectDT = function(datatype) {
        console.log(datatype);
        DatatypeService.getOne(datatype.id).then(function(datatype) {
            var modalInstance = $modal.open({
                templateUrl: 'redirectCtrl.html',
                controller: 'redirectCtrl',
                size: 'md',
                resolve: {
                    destination: function() {
                        return datatype;
                    }
                }



            });
            modalInstance.result.then(function() {
                $rootScope.editDataType(datatype);
            });



        });
    };

    $scope.isBindingChanged = function() {
        for (var i = 0; i < $rootScope.references.length; i++) {
            var ref = $rootScope.references[i];

            if (ref.tableLink&&ref.tableLink.isChanged) return true;
        }
        return false;
    };

    var cleanState = function() {
        $scope.saving = false;
        $scope.selectedChildren = [];
        if ($scope.editForm) {
            $scope.editForm.$setPristine();
            $scope.editForm.$dirty = false;
        }
        $rootScope.clearChanges();
    };
    $scope.callVSDelta = function() {

        $rootScope.$emit("event:openVSDelta");
    };

    $scope.changeTableLink = function(tableLink) {
        tableLink.isChanged = true;

        var t = $rootScope.tablesMap[tableLink.id];

        if (t == null) {
            tableLink.bindingIdentifier = null;
            tableLink.bindingLocation = null;
            tableLink.bindingStrength = null;
        } else {
            tableLink.bindingIdentifier = t.bindingIdentifier;
        }
    };

    $scope.AddBindingForValueSet = function(table) {
        var modalInstance = $modal.open({
            templateUrl: 'AddBindingForValueSet.html',
            controller: 'AddBindingForValueSet',
            windowClass: 'conformance-profiles-modal',
            resolve: {
                table: function() {
                    return table;
                }
            }
        });
        modalInstance.result.then(function() {
            $scope.setDirty();
        });
    };

    $scope.save = function() {
        if ($rootScope.table.scope === 'USER') {
            $scope.saving = true;
            var table = $rootScope.table;
            var bindingIdentifier = table.bindingIdentifier;


            if (table.libIds == undefined) table.libIds = [];
            if (table.libIds.indexOf($rootScope.tableLibrary.id) == -1) {
                table.libIds.push($rootScope.tableLibrary.id);
            }

            TableService.save(table).then(function(result) {
                var oldLink = TableLibrarySvc.findOneChild(result.id, $rootScope.tableLibrary.children);

                $rootScope.table.dateUpdated = result.dateUpdated;
                $rootScope.$emit("event:updateIgDate");
                TableService.merge($rootScope.tablesMap[result.id], result);
                // remove unnecessary variables for toc
                delete $rootScope.tablesMap[result.id].codes;
                delete $rootScope.tablesMap[result.id].contentDefinition;
                delete $rootScope.tablesMap[result.id].extensibility;
                delete $rootScope.tablesMap[result.id].stability;
                delete $rootScope.tablesMap[result.id].comment;
                delete $rootScope.tablesMap[result.id].defPreText;
                delete $rootScope.tablesMap[result.id].defPostText;

                var newLink = TableService.getTableLink(result);
                newLink.bindingIdentifier = bindingIdentifier;
                TableLibrarySvc.updateChild($rootScope.tableLibrary.id, newLink).then(function(link) {
                    oldLink.bindingIdentifier = link.bindingIdentifier;
                    oldLink.ext = link.ext;
                    cleanState();
                    $rootScope.msg().text = "tableSaved";
                    $rootScope.msg().type = "success";
                    $rootScope.msg().show = true;
                }, function(error) {
                    $scope.saving = false;
                    $rootScope.msg().text = error.data.text;
                    $rootScope.msg().type = error.data.type;
                    $rootScope.msg().show = true;
                });
            }, function(error) {
                $scope.saving = false;
                $rootScope.msg().text = error.data.text;
                $rootScope.msg().type = error.data.type;
                $rootScope.msg().show = true;
            });
        }
        $rootScope.saveBindingForValueSet();
        $rootScope.clearChanges();
    };

    $scope.addTable = function() {
        $rootScope.newTableFakeId = $rootScope.newTableFakeId - 1;
        var newTable = angular.fromJson({
            id: new ObjectId().toString(),
            type: 'table',
            bindingIdentifier: '',
            name: '',
            version: '',
            oid: '',
            tableType: '',
            stability: '',
            extensibility: '',
            codes: []
        });
        $rootScope.tables.push(newTable);
        $rootScope.tablesMap[newTable.id] = newTable;
        $rootScope.table = newTable;
        $rootScope.recordChangeForEdit2('table', "add", newTable.id, 'table', newTable);
        $scope.setDirty();
    };


    $scope.makeCodeSystemEditable = function() {
        $scope.codeSysEditMode = true;
    };


    $scope.addCodeSystem = function() {
        if ($rootScope.codeSystems.indexOf($scope.codeSysForm.str) < 0) {
            if ($scope.codeSysForm.str && $scope.codeSysForm.str !== '') {
                $rootScope.codeSystems.push($scope.codeSysForm.str);
            }
        }
        $scope.codeSysForm.str = '';
        $scope.codeSysEditMode = false;
    };

    $scope.delCodeSystem = function(value) {
        $rootScope.codeSystems.splice($rootScope.codeSystems.indexOf(value), 1);
    }

    $scope.updateCodeSystem = function(table, codeSystem) {
        for (var i = 0; i < $rootScope.table.codes.length; i++) {
            $rootScope.table.codes[i].codeSystem = codeSystem;
            $scope.recordChangeValue($rootScope.table.codes[i], 'codeSystem', $rootScope.table.codes[i].codeSystem, table.id);
        }
    }

    $scope.addValue = function() {
        $rootScope.newValueFakeId = $rootScope.newValueFakeId ? $rootScope.newValueFakeId - 1 : -1;
        var newValue = {
            id: new ObjectId().toString(),
            type: 'value',
            value: '',
            label: '',
            codeSystem: null,
            codeUsage: 'R'
        };


        $rootScope.table.codes.unshift(newValue);
        var newValueBlock = { targetType: 'table', targetId: $rootScope.table.id, obj: newValue };
        if (!$scope.isNewObject('table', 'add', $rootScope.table.id)) {
            $rootScope.recordChangeForEdit2('value', "add", null, 'value', newValueBlock);
        }
        $scope.setDirty();
    };
    $rootScope.checkAll = false;
    $scope.ProcessChecking = function(checkAll) {


        console.log("here");
        if (checkAll) {
            $scope.checkAllValues();
        } else {
            $scope.uncheckAllValues();
        }

    }
    $scope.addOrRemoveValue = function(c) {
        if (c.selected === true) {
            $scope.selectedCodes.push(c);
        } else if (c.selected === false) {
            var index = $scope.selectedCodes.indexOf(c);
            if (index > -1) {
                $scope.selectedCodes.splice(index, 1);
            }
        }


    }
    $scope.deleteSlectedValues = function() {
        console.log()
        console.log("deleting");
        $rootScope.table.codes = _.difference($rootScope.table.codes, $scope.selectedCodes);
        $scope.selectedCodes = [];
    }
    $scope.checkAllValues = function() {
        angular.forEach($rootScope.table.codes, function(c) {
            c.selected = true;
            $scope.selectedCodes.push(c);
        });
    }
    $scope.uncheckAllValues = function() {
        console.log("deleting");
        //console.log($rootScope.displayCollection);
        angular.forEach($rootScope.table.codes, function(c) {
            if (c.selected && c.selected === true) {
                c.selected = false;
            }
        });
        $scope.selectedCodes = [];
    }
    $scope.deleteValue = function(value) {
        // if (!$scope.isNewValueThenDelete(value.id)) {
        //     $rootScope.recordChangeForEdit2('value', "delete", value.id, 'id', value.id);
        // }
        console.log($scope.selectedCodes);
        $rootScope.table.codes.splice($rootScope.table.codes.indexOf(value), 1);
        $scope.setDirty();
    };

    $scope.isNewValueThenDelete = function(id) {
        if ($rootScope.isNewObject('value', 'add', id)) {
            if ($rootScope.changes['value'] !== undefined && $rootScope.changes['value']['add'] !== undefined) {
                for (var i = 0; i < $rootScope.changes['value']['add'].length; i++) {
                    var tmp = $rootScope.changes['value']['add'][i];
                    if (tmp.obj.id === id) {
                        $rootScope.changes['value']['add'].splice(i, 1);
                        if ($rootScope.changes["value"]["add"] && $rootScope.changes["value"]["add"].length === 0) {
                            delete $rootScope.changes["value"]["add"];
                        }

                        if ($rootScope.changes["value"] && Object.getOwnPropertyNames($rootScope.changes["value"]).length === 0) {
                            delete $rootScope.changes["value"];
                        }
                        return true;
                    }
                }
            }
            return true;
        }
        if ($rootScope.changes['value'] !== undefined && $rootScope.changes['value']['edit'] !== undefined) {
            for (var i = 0; i < $rootScope.changes['value']['edit'].length; i++) {
                var tmp = $rootScope.changes['value']['edit'][i];
                if (tmp.id === id) {
                    $rootScope.changes['value']['edit'].splice(i, 1);
                    if ($rootScope.changes["value"]["edit"] && $rootScope.changes["value"]["edit"].length === 0) {
                        delete $rootScope.changes["value"]["edit"];
                    }

                    if ($rootScope.changes["value"] && Object.getOwnPropertyNames($rootScope.changes["value"]).length === 0) {
                        delete $rootScope.changes["value"];
                    }
                    return false;
                }
            }
            return false;
        }
        return false;
    };

    $scope.isNewValue = function(id) {
        return $scope.isNewObject('value', 'add', id);
    };

    $scope.isNewTable = function(id) {
        return $scope.isNewObject('table', 'add', id);
    };

    $scope.close = function() {
        $rootScope.table = null;
    };

    $scope.copyTable = function(table) {
        CloneDeleteSvc.copyTable(table);
    };

    $scope.recordChangeValue = function(value, valueType, tableId) {
        if (!$scope.isNewTable(tableId)) {
            if (!$scope.isNewValue(value.id)) {
                $rootScope.recordChangeForEdit2('value', 'edit', value.id, valueType, value);
            }
        }
        $scope.setDirty();
    };

    $scope.recordChangeTable = function(table, valueType, value) {
        if (!$scope.isNewTable(table.id)) {
            $rootScope.recordChangeForEdit2('table', 'edit', table.id, valueType, value);
        }
        $scope.setDirty();
    };

    $scope.setAllCodeUsage = function(table, usage) {
        for (var i = 0, len = table.codes.length; i < len; i++) {
            if (table.codes[i].codeUsage !== usage) {
                table.codes[i].codeUsage = usage;
                if (!$scope.isNewTable(table.id) && !$scope.isNewValue(table.codes[i].id)) {
                    $rootScope.recordChangeForEdit2('value', 'edit', table.codes[i].id, 'codeUsage', usage);
                }
            }
        }
        $scope.setDirty();
    };

    $scope.delete = function(table) {
        CloneDeleteSvc.deleteValueSet(table);
    };


    $scope.shareModal = function (table) {
      $http.get('api/usernames').then(function (response) {
        var userList = response.data;
        var filteredUserList = userList.filter(function(user) {
          // Add accountId var
          user.accountId = user.id;
          var isPresent = false;
          if(table.shareParticipantIds) {
            for(var i = 0; i < table.shareParticipantIds.length; i++) {
              if(table.shareParticipantIds[i].accountId == user.id) {
                isPresent = true;
              }
            }
          }
          if(!isPresent) return user;
        });

        var modalTemplate = "ShareTableErrorModal.html";
        if(table.status === "PUBLISHED") {
          modalTemplate = "ShareTableModal.html";
        }
        var modalInstance = $modal.open({
          templateUrl: modalTemplate
          , controller: 'ShareTableCtrl'
          , size:'lg'
          , resolve: {
            igdocumentSelected: function () {
              return table;
            }
            , userList: function () {
                return _.filter(filteredUserList, function(user){
                        return user.id != $rootScope.accountId && table.shareParticipantIds && table.shareParticipantIds != null && table.shareParticipantIds.indexOf(user.id) == -1 ;
                    });
              }
          }
        });

        modalInstance.result.then(function (result) {
        }, function () {
          if(modalTemplate === 'ShareDatatypeModal.html') {
          }
          // $log.info('Modal dismissed at: ' + new Date());
        });

      }, function (error) {
        console.log(error);
      });
    };
});

angular.module('igl').controller('TableModalCtrl', function($scope) {
    $scope.showModal = false;
    $scope.toggleModal = function() {
        $scope.showModal = !$scope.showModal;
    };
});

angular.module('igl').controller('ConfirmValueSetDeleteCtrl', function($scope, $modalInstance, tableToDelete, $rootScope, TableService, TableLibrarySvc, CloneDeleteSvc) {
    $scope.tableToDelete = tableToDelete;
    $scope.loading = false;


    $scope.delete = function() {
        $scope.loading = true;
        if ($scope.tableToDelete.scope === 'USER') {
            CloneDeleteSvc.deleteTableAndTableLink($scope.tableToDelete);
        } else {
            CloneDeleteSvc.deleteTableLink($scope.tableToDelete);
        }
        $modalInstance.close($scope.tableToDelete);
        $scope.loading = false;
    };


    //    $scope.delete = function () {
    //        $scope.loading = true;
    //
    //        if (!$scope.isNewTableThenDelete(tableToDelete.id)) {
    ////        	$rootScope.recordChangeForEdit2('table', "delete", tableToDelete.id,'id', tableToDelete.id);
    //        }
    //        // We must delete from two collections.
    //        var index = $rootScope.tables.indexOf(tableToDelete);
    //        $rootScope.tables.splice(index, 1);
    //        var index = $rootScope.tableLibrary.children.indexOf($scope.tableToDelete);
    //        if (index > -1) $rootScope.tableLibrary.children.splice(index, 1);
    //        $rootScope.tablesMap[tableToDelete.id] = undefined;
    //
    //        $rootScope.generalInfo.type = 'info';
    //        $rootScope.generalInfo.message = "Table " + $scope.tableToDelete.bindingIdentifier + " deleted successfully";
    //
    //        if ($rootScope.table === $scope.tableToDelete) {
    //            $rootScope.table = null;
    //        }
    //
    //        $rootScope.references = [];
    //		$rootScope.$broadcast('event:SetToC');
    //        $modalInstance.close($scope.tableToDelete);
    //    };

    //    $scope.delete = function () {
    //        $scope.loading = true;
    //
    //        TableService.delete($scope.tableToDelete).then(function (result) {
    //                TableLibrarySvc.deleteChild($scope.tableToDelete.id).then(function (res) {
    //                    // We must delete from two collections.
    //                    var index = $rootScope.tables.indexOf($scope.tableToDelete);
    //                    $rootScope.tables.splice(index, 1);
    //                    var tmp = TableLibrarySvc.findOneChiletd($scope.tableToDelete.id, $rootScope.tableLibrary.children);
    //                    index = $rootScope.tableLibrary.children.indexOf(tmp);
    //                    $rootScope.tableLibrary.children.splice(index, 1);
    //                    $rootScope.tablesMap[$scope.tableToDelete.id] = null;
    //                    $rootScope.references = [];
    //                    if ($rootScope.table === $scope.tableToDelete) {
    //                        $rootScope.table = null;
    //                    }
    //                    $rootScope.recordDelete("table", "edit", $scope.tableToDelete.id);
    //                    $rootScope.msg().text = "tableDeleteSuccess";
    //                    $rootScope.msg().type = "success";
    //                    $rootScope.msg().show = true;
    //                    $rootScope.manualHandle = true;
    //                    $scope.loading = false;
    //                    $rootScope.$broadcast('event:SetToC');
    //                    $modalInstance.close($scope.tableToDelete);
    //                }, function (error) {
    //                    $rootScope.msg().text = error.data.text;
    //                    $rootScope.msg().type = "danger";
    //                    $rootScope.msg().show = true;
    //                    $rootScope.manualHandle = true;
    //                    $scope.loading = false;
    //                });
    //            }, function (error) {
    //                $rootScope.msg().text = error.data.text;
    //                $rootScope.msg().type = "danger";
    //                $rootScope.msg().show = true;
    //                $rootScope.manualHandle = true;
    //                $scope.loading = false;
    //            }
    //        );
    //    };


    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };


    $scope.isNewTableThenDelete = function(id) {
        if ($rootScope.isNewObject('table', 'add', id)) {
            if ($rootScope.changes['table'] !== undefined && $rootScope.changes['table']['add'] !== undefined) {
                for (var i = 0; i < $rootScope.changes['table']['add'].length; i++) {
                    var tmp = $rootScope.changes['table']['add'][i];
                    if (tmp.id == id) {
                        $rootScope.changes['table']['add'].splice(i, 1);
                        if ($rootScope.changes["table"]["add"] && $rootScope.changes["table"]["add"].length === 0) {
                            delete $rootScope.changes["table"]["add"];
                        }

                        if ($rootScope.changes["table"] && Object.getOwnPropertyNames($rootScope.changes["table"]).length === 0) {
                            delete $rootScope.changes["table"];
                        }
                        return true;
                    }
                }
            }
            return true;
        }
        if ($rootScope.changes['table'] !== undefined && $rootScope.changes['table']['edit'] !== undefined) {
            for (var i = 0; i < $rootScope.changes['table']['edit'].length; i++) {
                var tmp = $rootScope.changes['table']['edit'][i];
                if (tmp.id === id) {
                    $rootScope.changes['table']['edit'].splice(i, 1);
                    if ($rootScope.changes["table"]["edit"] && $rootScope.changes["table"]["edit"].length === 0) {
                        delete $rootScope.changes["table"]["edit"];
                    }

                    if ($rootScope.changes["table"] && Object.getOwnPropertyNames($rootScope.changes["table"]).length === 0) {
                        delete $rootScope.changes["table"];
                    }
                    return false;
                }
            }
            return false;
        }
        return false;
    };
});

angular.module('igl').controller('ValueSetReferencesCtrl', function($scope, $modalInstance, tableToDelete) {

    $scope.tableToDelete = tableToDelete;

    $scope.ok = function() {
        $modalInstance.close($scope.tableToDelete);
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});


angular.module('igl').controller('cmpTableCtrl', function($scope, $modal, ObjectDiff, orderByFilter, $rootScope, $q, $interval, ngTreetableParams, $http, StorageService, userInfoService, IgDocumentService, SegmentService, DatatypeService, SegmentLibrarySvc, DatatypeLibrarySvc, TableLibrarySvc, CompareService) {
    var ctrl = this;
    this.tableId = -1;
    $scope.vsChanged = false;
    $scope.variable = false;
    $scope.isDeltaCalled = false;

    $scope.setDeltaToF = function() {
        console.log("HEEEEEERREEEEE");
        $scope.isDeltaCalled = false;
    }



    $scope.scopes = [{
        name: "USER",
        alias: "My IG"
    }, {
        name: "HL7STANDARD",
        alias: "Base HL7"
    }];
    var listHL7Versions = function() {
        return $http.get('api/igdocuments/findVersions', {
            timeout: 60000
        }).then(function(response) {
            var hl7Versions = [];
            var length = response.data.length;
            for (var i = 0; i < length; i++) {
                hl7Versions.push(response.data[i]);
            }
            return hl7Versions;
        });
    };
    $scope.status = {
        isCustomHeaderOpen: false,
        isFirstOpen: true,
        isSecondOpen: true,
        isFirstDisabled: false
    };

    $scope.initt = function() {
        $scope.isDeltaCalled = true;
        $scope.dataList = [];
        listHL7Versions().then(function(versions) {
            $scope.versions = versions;
            $scope.version1 = angular.copy($rootScope.igdocument.profile.metaData.hl7Version);
            $scope.scope1 = "USER";
            $scope.ig1 = angular.copy($rootScope.igdocument.profile.metaData.name);
            $scope.table1 = angular.copy($rootScope.table);
            ctrl.tableId = -1;
            $scope.variable = !$scope.variable;
            $scope.tables = null;
            //$scope.setIG2($scope.ig2);
            $scope.version2 = angular.copy($scope.version1);
            //$scope.status.isFirstOpen = true;
            $scope.scope2 = "HL7STANDARD";
            if ($scope.dynamicVs_params) {
                $scope.showDelta = false;
                $scope.status.isFirstOpen = true;
                $scope.dynamicVs_params.refresh();
            }
        });



    };

    $scope.$on('event:loginConfirmed', function(event) {
        $scope.initt();
    });

    //$scope.initt();

    $rootScope.$on('event:initTable', function(event) {
        if ($scope.isDeltaCalled) {
            $scope.initt();
        }
    });

    $rootScope.$on('event:openVSDelta', function(event) {
        $scope.initt();
    });



    $scope.setVersion2 = function(vr) {
        $scope.version2 = vr;

    };
    $scope.setScope2 = function(scope) {

        $scope.scope2 = scope;
    };

    $scope.$watchGroup(['table1', 'table2'], function() {
        $scope.vsChanged = true;
        //$scope.segment1 = angular.copy($rootScope.activeSegment);


    }, true);
    $scope.$watchGroup(['version2', 'scope2', 'variable'], function() {
        $scope.igList2 = [];
        $scope.tables2 = [];
        $scope.ig2 = "";
        if ($scope.scope2 && $scope.version2) {
            IgDocumentService.getIgDocumentsByScopesAndVersion([$scope.scope2], $scope.version2).then(function(result) {
                if (result) {
                    if ($scope.scope2 === "HL7STANDARD") {
                        $scope.igDisabled2 = true;
                        $scope.ig2 = {
                            id: result[0].id,
                            title: result[0].metaData.title
                        };
                        $scope.igList2.push($scope.ig2);

                        $scope.setIG2($scope.ig2);
                    } else {
                        $scope.igDisabled2 = false;
                        for (var i = 0; i < result.length; i++) {
                            $scope.igList2.push({
                                id: result[i].id,
                                title: result[i].metaData.title,
                            });
                        }
                    }
                }
            });

        }

    }, true);
    $scope.setTable2 = function(table) {
        if (table === -1) {
            $scope.table2 = {};
        } else {
            $scope.table2 = $scope.tables2[table];

        }
    };
    $scope.setIG2 = function(ig) {
        if (ig) {
            IgDocumentService.getOne(ig.id).then(function(igDoc) {
                SegmentLibrarySvc.getSegmentsByLibrary(igDoc.profile.segmentLibrary.id).then(function(segments) {
                    DatatypeLibrarySvc.getDatatypesByLibrary(igDoc.profile.datatypeLibrary.id).then(function(datatypes) {
                        TableLibrarySvc.getTablesByLibrary(igDoc.profile.tableLibrary.id).then(function(tables) {
                            $scope.tables2 = [];
                            $scope.table2 = "";
                            if (igDoc) {
                                //$scope.segList2 = angular.copy(segments);
                                //$scope.segList2 = orderByFilter($scope.segList2, 'name');
                                //$scope.dtList2 = angular.copy(datatypes);
                                $scope.tableList2 = angular.copy(tables);
                                //$scope.messages2 = orderByFilter(igDoc.profile.messages.children, 'name');
                                //$scope.segments2 = orderByFilter(segments, 'name');
                                //$scope.datatypes2 = orderByFilter(datatypes, 'name');
                                $scope.tables2 = orderByFilter(tables, 'bindingIdentifier');
                            }
                        });
                    });
                });

            });

            //$scope.messages2 = ($scope.findIGbyID(JSON.parse(ig).id)).profile.messages.children;

        }

    };

    $scope.hideVS = function(vs1, vs2) {

        if (vs2) {
            return !(vs1.name === vs2.name);
        } else {
            return false;
        }
    };
    $scope.disableVS = function(vs1, vs2) {

        if (vs2) {
            return (vs1.id === vs2.id);
        } else {
            return false;
        }
    };




    $scope.dynamicVs_params = new ngTreetableParams({
        getNodes: function(parent) {
            if ($scope.dataList !== undefined) {
                if (parent) {
                    if (parent.codes) {
                        return parent.codes;
                    }

                } else {
                    return $scope.dataList;
                }

            }
        },
        getTemplate: function(node) {
            $scope.vsTemplate = true;
            return 'valueSet_node';
        }
    });
    $scope.cmpTable = function(table1, table2) {

        $scope.loadingSelection = true;
        $scope.vsChanged = false;
        $scope.vsTemplate = false;
        $scope.dataList = CompareService.cmpValueSet(JSON.stringify(table1), JSON.stringify(table2));
        console.log("hg==========");
        console.log($scope.dataList);
        $scope.loadingSelection = false;
        if ($scope.dynamicVs_params) {
            console.log($scope.dataList);
            $scope.showDelta = true;
            $scope.status.isSecondOpen = true;
            $scope.dynamicVs_params.refresh();
        }

    };


});

angular.module('igl').controller('AddBindingForValueSet', function($scope, $modalInstance, $rootScope, table) {
    console.log($rootScope.references);
    $scope.table = table;
    $scope.selectedSegmentForBinding = null;
    $scope.selectedFieldForBinding = null;
    $scope.selectedDatatypeForBinding = null;
    $scope.selectedComponentForBinding = null;
    $scope.selectedBindingLocation = null;
    $scope.selectedBindingStrength = null;
    $scope.pathForBinding = null;
    $scope.bindingTargetType = 'DATATYPE';

    $scope.init = function() {
        $scope.selectedSegmentForBinding = null;
        $scope.selectedFieldForBinding = null;
        $scope.selectedDatatypeForBinding = null;
        $scope.selectedComponentForBinding = null;
        $scope.selectedBindingLocation = null;
        $scope.selectedBindingStrength = null;
        $scope.pathForBinding = null;
    };

    $scope.checkDuplicated = function(path) {
        for (var i = 0; i < $rootScope.references.length; i++) {
            var ref = $rootScope.references[i];
            if (ref.path == path) return true;
        }
        return false;
    };

    $scope.selectSegment = function() {
        $scope.selectedFieldForBinding = null;
    };

    $scope.selectDatatype = function() {
        $scope.selectedComponentForBinding = null;
    };

    $scope.save = function(bindingTargetType) {
        var tableLink = {};
        tableLink.id = $scope.table.id;
        tableLink.bindingIdentifier = $scope.table.bindingIdentifier;
        tableLink.bindingLocation = $scope.selectedBindingLocation;
        tableLink.bindingStrength = $scope.selectedBindingStrength;
        tableLink.isChanged = true;
        tableLink.isNew = true;

        if (bindingTargetType == 'SEGMENT') {
            $scope.selectedFieldForBinding = JSON.parse($scope.selectedFieldForBinding);
            $scope.pathForBinding = $rootScope.getSegmentLabel($scope.selectedSegmentForBinding) + '-' + $scope.selectedFieldForBinding.position;

            var ref = angular.copy($scope.selectedFieldForBinding);
            ref.path = $scope.pathForBinding;
            ref.target = angular.copy($scope.selectedSegmentForBinding);
            ref.tableLink = angular.copy(tableLink);
            $rootScope.references.push(ref);
        } else {
            $scope.selectedComponentForBinding = JSON.parse($scope.selectedComponentForBinding);
            $scope.pathForBinding = $rootScope.getDatatypeLabel($scope.selectedDatatypeForBinding) + '-' + $scope.selectedComponentForBinding.position;

            var ref = angular.copy($scope.selectedComponentForBinding);
            ref.path = $scope.pathForBinding;
            ref.target = angular.copy($scope.selectedDatatypeForBinding);
            ref.tableLink = angular.copy(tableLink);
            $rootScope.references.push(ref);
        }

        $modalInstance.close();
    };

    $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
    };
});

angular.module('igl').controller('ShareTableCtrl', function ($scope, $modalInstance, $http, igdocumentSelected, userList,TableService,$rootScope) {

  $scope.igdocumentSelected = igdocumentSelected;

  // Add participants username and fullname
  // Find share participants
  if ($scope.igdocumentSelected.shareParticipantIds && $scope.igdocumentSelected.shareParticipantIds.length > 0) {
      $scope.igdocumentSelected.shareParticipantIds.forEach(function(participant) {
          $http.get('api/shareparticipant', { params: { id: participant.accountId } })
              .then(
                  function(response) {
                      participant.username = response.data.username;
                      participant.fullname = response.data.fullname;
                  },
                  function(error) {
                      console.log(error);
                  }
              );
      });
  }
	$scope.userList =  userList;
	$scope.error = "";
  $scope.tags = [];
	$scope.ok = function () {
		var idsTab = $scope.tags.map(function(user) {
			return user.accountId;
		});

        TableService.share($scope.igdocumentSelected.id,idsTab, $rootScope.accountId).then(function(result){
            // Add participants for direct view
            $scope.igdocumentSelected.shareParticipantIds = $scope.igdocumentSelected.shareParticipantIds || [];
            $scope.tags.forEach(function(tag) {
                tag.permission = $scope.selectedItem.selected;
                tag.pendingApproval = true;
                $scope.igdocumentSelected.shareParticipantIds.push(tag);
            });
            $rootScope.msg().text = "vsSharedSuccessfully";
            $rootScope.msg().type ="success";
            $rootScope.msg().show = true;
            $modalInstance.close();
        }, function(error){
            $scope.error = error.data;
            console.log(error);
        });
	};
	$scope.cancel = function () {
		$modalInstance.dismiss('cancel');
	};

	$scope.selectedItem = {
		selected: "VIEW"
	};
	$scope.itemArray = ["VIEW"];

	$scope.loadUsernames = function ($query) {
		return userList.filter(function (user) {
			return user.username.toLowerCase().indexOf($query.toLowerCase()) != -1;
		});
	};

    $scope.unshare = function (shareParticipant) {
        $scope.loading = false;
        TableService.unshare($scope.igdocumentSelected.id,shareParticipant.accountId).then(function(res){
            var indexOfId = $scope.igdocumentSelected.shareParticipantIds.indexOf(shareParticipant.accountId);
            if (indexOfId > -1) {
                $scope.igdocumentSelected.shareParticipantIds.splice(indexOfId, 1);
            }
            var participantIndex = -1;
            for(var i=0; i <  $scope.igdocumentSelected.shareParticipantIds.length; i++){
                if($scope.igdocumentSelected.shareParticipantIds[i].accountId === shareParticipant.accountId){
                    participantIndex =i;
                    $scope.userList.push($scope.igdocumentSelected.shareParticipantIds[i]);
                    break;
                }
            }
            if (participantIndex > -1) {
                $scope.igdocumentSelected.shareParticipantIds.splice(participantIndex, 1);
            }
            $scope.loading = false;
            $rootScope.msg().text = "vsUnSharedSuccessfully";
            $rootScope.msg().type ="success";
            $rootScope.msg().show = true;
         }, function(error){
            $rootScope.msg().text = error.data.text;
            $rootScope.msg().type = error.data.type;
            $rootScope.msg().show = true;
            $scope.loading = false;
        });
    };


});
